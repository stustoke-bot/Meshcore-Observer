<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta http-equiv="cache-control" content="no-store, no-cache, must-revalidate, max-age=0"/>
  <meta http-equiv="pragma" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <title>MeshRank</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --ink: #0a0b0e;
      --paper: #f2f2f7;
      --panel: #ffffff;
      --line: rgba(60, 60, 67, 0.12);
      --blue: #007aff;
      --blue-dark: #0a60d1;
      --green: #34c759;
      --green-dark: #248a3d;
      --muted: rgba(60, 60, 67, 0.6);
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }
    body.theme-dark {
      --ink: #e8eef9;
      --paper: #0b0f15;
      --panel: #131a24;
      --line: rgba(231, 238, 251, 0.08);
      --blue: #63a2ff;
      --blue-dark: #2f6bd6;
      --green: #48d06a;
      --green-dark: #2aa24a;
      --muted: rgba(231, 238, 251, 0.62);
      --shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", system-ui, sans-serif;
      background:
        radial-gradient(1000px 520px at 85% -10%, rgba(0, 122, 255, 0.14) 0%, rgba(0, 122, 255, 0) 60%),
        radial-gradient(900px 520px at -10% 15%, rgba(52, 199, 89, 0.12) 0%, rgba(52, 199, 89, 0) 60%),
        var(--paper);
      color: var(--ink);
      height: 100vh;
      overflow: hidden;
    }
    body.theme-dark {
      background:
        radial-gradient(900px 520px at 85% -10%, rgba(99, 162, 255, 0.18) 0%, rgba(11, 15, 21, 0) 60%),
        radial-gradient(800px 520px at -10% 20%, rgba(72, 208, 106, 0.16) 0%, rgba(11, 15, 21, 0) 60%),
        var(--paper);
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 280px 1fr 420px;
      gap: 16px;
      padding: 16px;
      height: 100vh;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .sidebar-panel {
      min-height: 0;
    }

    .topbar {
      grid-column: 1 / -1;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      padding: 2px 12px;
      gap: 12px;
      min-height: 48px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      flex: 0 0 auto;
    }

    .brand-logo {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: block;
      overflow: hidden;
      border: none;
    }

    .brand-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display: block;
      min-width: 0;
    }

    .brand-text {
      display: grid;
      gap: 2px;
      line-height: 1.1;
    }

    .brand-text strong {
      font-size: 16px;
    }

    .brand-text span {
      font-size: 12px;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      background: #ff3b30;
      box-shadow: 0 0 0 4px rgba(255, 59, 48, 0.15);
    }

    .status-dot.ok {
      background: #34c759;
      box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.15);
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-weight: 600;
      color: var(--muted);
      margin-left: auto;
    }

    .nav a {
      color: inherit;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .nav a.active {
      color: var(--ink);
      background: rgba(0, 122, 255, 0.12);
    }
    .menu-toggle {
      display: none;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 10px;
      padding: 0;
      width: 38px;
      height: 34px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }
    .menu-toggle .burger {
      width: 18px;
      height: 12px;
      display: inline-flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .menu-toggle .burger span {
      display: block;
      height: 2px;
      border-radius: 999px;
      background: var(--ink);
    }
    .menu-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 900;
    }
    .mobile-menu {
      display: none;
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 12px;
      width: min(86vw, 320px);
      z-index: 950;
      border: 1px solid var(--line);
      border-radius: 12px 0 0 12px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 10px;
      gap: 6px;
      flex-direction: column;
      align-items: stretch;
      transform: translateX(110%);
      transition: transform 0.2s ease;
      overflow: auto;
    }
    .mobile-menu a {
      display: block;
      padding: 8px 10px;
      border-radius: 10px;
      text-decoration: none;
      color: var(--ink);
      font-weight: 600;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-menu a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .mobile-nav {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
    }
    .mobile-nav a {
      color: var(--ink);
      text-decoration: none;
      font-weight: 600;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-nav a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .theme-toggle {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .theme-toggle:hover { color: var(--blue); border-color: var(--blue); }
    .theme-toggle:focus-visible { outline: 2px solid var(--blue); outline-offset: 2px; }

    .sidebar {
      padding: 14px 12px;
      gap: 10px;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
      flex: 1 1 auto;
      max-height: 100%;
    }

    #channels {
      display: grid;
      gap: 10px;
      overflow-x: hidden;
    }

    .title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .content .title {
      position: sticky;
      top: 0;
      z-index: 4;
      background: var(--panel);
    }
    .channel-title {
      justify-content: space-between;
      gap: 8px;
    }
    .channel-title-label {
      font-weight: 700;
    }

    .title.column {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }

    .chip {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      font-weight: 600;
    }
    .chip-strong {
      color: var(--ink);
      font-weight: 700;
      border-color: rgba(60, 60, 67, 0.35);
      background: rgba(0, 0, 0, 0.06);
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(0, 122, 255, 0.18);
    }

    .channel {
      display: grid;
      grid-template-columns: 44px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
      overflow: hidden;
    }
    .channel > div { min-width: 0; }

    .channel.active {
      background: #e8f0ff;
      border-color: rgba(11, 95, 255, 0.2);
    }
    body.theme-dark .channel.active {
      background: rgba(99, 162, 255, 0.16);
      border-color: rgba(99, 162, 255, 0.4);
    }

    .channel.unread .name {
      font-weight: 800;
    }

    .badge-bubble {
      min-width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #007aff;
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
    }

    .channel .name {
      font-weight: 700;
      overflow: visible;
      text-overflow: unset;
      white-space: normal;
      overflow-wrap: anywhere;
    }

    .channel .snippet {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .channel .muted {
      color: var(--muted);
      font-size: 10px;
      line-height: 1.2;
      white-space: nowrap;
    }

    .channel-meta {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-top: 4px;
      min-width: 0;
    }
    .channel-meta .snippet {
      flex: 1 1 auto;
      min-width: 0;
    }
    .channel-time {
      font-size: 10px;
      color: var(--muted);
      white-space: nowrap;
    }

    .content {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .channel-selector {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }
    @media (min-width: 861px) {
      .channel-selector { display: none; }
    }
    @media (max-width: 860px) {
      .channel-title-label { display: none; }
    }
    .channel-selector .badge-bubble {
      min-width: 18px;
      height: 18px;
      border-radius: 999px;
      background: var(--blue);
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
    }
    .channels-rail {
      display: none;
      position: fixed;
      left: 6px;
      top: 120px;
      z-index: 9;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      gap: 6px;
      align-items: center;
      font-weight: 700;
      cursor: pointer;
    }
    .channels-rail .badge-bubble { display: inline-flex; }

    .messages {
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow: auto;
    }

    .message {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      animation: slideIn 400ms ease-out;
      min-width: 0;
    }

    .message .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .bubble {
      padding: 10px 14px;
      border-radius: 14px;
      max-width: 520px;
      color: #fff;
      font-weight: 500;
      line-height: 1.35;
      box-shadow: 0 10px 24px rgba(10, 11, 14, 0.16);
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .bubble.mesh {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
    }

    .bubble.observer {
      background: linear-gradient(135deg, var(--green), var(--green-dark));
    }

    .bubble.mixed {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
      outline: 2px solid var(--green);
    }

    .msg-footer {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .observer-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 200, 83, 0.35);
      background: rgba(0, 200, 83, 0.12);
      color: #00a849;
      font-size: 11px;
      font-weight: 700;
    }
    .repeater-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 122, 255, 0.35);
      background: rgba(0, 122, 255, 0.12);
      color: #007aff;
      font-size: 11px;
      font-weight: 700;
    }

    .msg-hops {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-hops:hover { text-decoration: underline; }

    .msg-observers {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-observers:hover { text-decoration: underline; }
    .msg-confidence {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-confidence:hover { text-decoration: underline; }

    .analysis {
      display: grid;
      grid-template-rows: 240px 1fr;
      min-height: 0;
    }
    .route-close {
      display: none;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--muted);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .route-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      z-index: 9;
    }
    .rank-detail-overlay {
      position: fixed;
      inset: 0;
      display: none;
      background: rgba(0, 0, 0, 0.4);
      align-items: center;
      justify-content: center;
      z-index: 900;
    }
    .rank-detail-overlay.open {
      display: flex;
    }
    .rank-detail-card {
      background: var(--panel);
      border-radius: 18px;
      padding: 20px;
      width: min(95vw, 820px);
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
    }
    .rank-detail-close {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 12px;
    }
    .rank-detail-close button {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
    }
    .confidence-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .confidence-meta {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 10px;
    }
    .confidence-map {
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      height: 320px;
      margin-bottom: 12px;
    }
    #confidenceMap {
      width: 100%;
      height: 100%;
    }
    .confidence-deadends {
      display: grid;
      gap: 8px;
    }
    .confidence-deadend {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
    }
    .confidence-deadend strong {
      color: var(--ink);
      font-weight: 600;
    }
    .route-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 0;
      font-size: 12px;
      color: var(--muted);
    }
    .route-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.04);
    }
    .route-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    .neighbor-map-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .neighbor-map-modal.open { display: flex; }
    .neighbor-map-card {
      width: min(92vw, 720px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      padding: 14px;
    }
    .neighbor-map {
      height: 320px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--line);
    }
    .neighbor-map-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .neighbor-map-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.04);
    }
    .neighbor-map-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .node-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rotm-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .rotm-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      overflow: auto;
    }

    .rotm-info-link {
      font-size: 12px;
      font-weight: 600;
      color: var(--blue-dark);
      cursor: pointer;
      border: 0;
      background: transparent;
      padding: 0;
    }

    .rotm-grid {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      min-height: 0;
    }

    .rotm-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      background: var(--panel);
    }

    .rotm-card-title {
      font-weight: 700;
      font-size: 14px;
    }

    .rotm-settings {
      display: grid;
      gap: 10px;
    }

    .rotm-settings-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .rotm-settings-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .rotm-settings-note {
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-feed {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
      padding-right: 6px;
      min-height: 200px;
    }

    .rotm-feed-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(0, 0, 0, 0.02);
    }

    body.theme-dark .rotm-feed-row {
      background: rgba(255, 255, 255, 0.03);
    }

    .rotm-feed-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-feed-sender {
      font-weight: 700;
      color: var(--ink);
    }

    .rotm-feed-body {
      font-size: 14px;
      line-height: 1.45;
    }

    .rotm-badge {
      align-self: flex-start;
      font-size: 11px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(60, 60, 67, 0.12);
      color: var(--muted);
    }

    .rotm-badge.ok {
      background: #d7f3e2;
      color: #1f6d39;
    }

    .rotm-badge.cq {
      background: #e0ecff;
      color: #0a60d1;
    }

    .rotm-badge.response {
      background: #fff1da;
      color: #a86400;
    }

    body.theme-dark .rotm-badge.ok { background: rgba(52, 199, 89, 0.2); color: #7ae6a1; }
    body.theme-dark .rotm-badge.cq { background: rgba(0, 122, 255, 0.2); color: #9dc1ff; }
    body.theme-dark .rotm-badge.response { background: rgba(255, 149, 0, 0.2); color: #ffd08a; }

    .rotm-leaderboard {
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: auto;
      min-height: 200px;
    }

    .rotm-leader-row {
      display: grid;
      grid-template-columns: 36px 1fr 120px 70px 110px;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      cursor: pointer;
    }

    .rotm-leader-header {
      cursor: default;
      background: rgba(0, 0, 0, 0.02);
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
    }

    body.theme-dark .rotm-leader-header {
      background: rgba(255, 255, 255, 0.04);
    }

    .rotm-leader-row.active {
      border-color: var(--blue);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.15);
    }

    .rotm-leader-rank {
      font-weight: 700;
      color: var(--muted);
    }

    .rotm-leader-node {
      font-weight: 700;
    }

    .rotm-leader-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-map-title {
      font-weight: 700;
      font-size: 13px;
    }

    #rotmMap {
      width: 100%;
      height: 320px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--line);
    }

    .rotm-claim-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-claim-chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.02);
    }

    body.theme-dark .rotm-claim-chip {
      background: rgba(255, 255, 255, 0.05);
    }

    .rank-body {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rank-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
    }

      .summary-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        background: #ffffff;
        display: grid;
        gap: 4px;
        font-size: 12px;
        color: var(--muted);
      }

    .summary-card strong {
      font-size: 16px;
      color: var(--ink);
    }

    .rank-map {
      border-radius: 16px;
      border: 1px solid var(--line);
      overflow: hidden;
      min-height: 360px;
    }

    #rankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    #observerRankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    .rank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      height: 100%;
    }

    .rank-search {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
      outline: none;
      box-shadow: 0 6px 16px rgba(10, 11, 14, 0.06);
      margin-bottom: 6px;
    }

    .rank-loading {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #ffffff;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .rank-loading.active {
      display: flex;
    }

    .rank-loading .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, 0.15);
      border-top-color: var(--blue);
      animation: rankSpin 1s linear infinite;
    }

    @keyframes rankSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .rank-scroll {
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      flex: 1;
    }

    .rank-search::placeholder {
      color: rgba(60, 60, 67, 0.45);
    }

    .rank-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
      background: #fafafa;
    }


    .rank-item.hidden {
      opacity: 0.45;
      filter: grayscale(0.4);
    }

    .rank-item.focused {
      border-color: rgba(0, 122, 255, 0.4);
      background: rgba(0, 122, 255, 0.1);
      box-shadow: 0 10px 24px rgba(0, 122, 255, 0.18);
    }

    .rank-item .row {
      font-size: 12px;
      color: var(--muted);
    }

    .rank-item .score {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .rank-dot {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: #fff;
    }

    .meshscore-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-body {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rf-table {
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .rf-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #ffffff;
    }

    .rf-input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      font-family: "IBM Plex Mono", monospace;
      background: var(--panel);
      color: var(--ink);
    }

    .rf-list {
      overflow: auto;
      min-height: 0;
    }

    .rf-row {
      display: grid;
      grid-template-columns: 90px 110px 90px 140px minmax(160px, 2fr) 140px 60px 60px 60px 60px 70px;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 12px;
      cursor: pointer;
      align-items: center;
    }
    .rf-row.rf-child {
      font-size: 11px;
      opacity: 0.85;
      padding-left: 28px;
      cursor: default;
    }
    .rf-row.rf-child:hover { background: transparent; }
    .rf-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--ink);
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
    }
    .rf-row.rf-child.is-hidden { display: none; }

    .rf-row:hover {
      background: #f7f7f7;
    }

    .rf-row.rf-header {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f4f6fb;
      font-weight: 700;
      color: #5b6b84;
      cursor: default;
    }

    .rf-type {
      font-weight: 700;
      color: #fff;
      border-radius: 8px;
      padding: 2px 6px;
      display: inline-flex;
      justify-content: center;
      background: #007aff;
      font-size: 11px;
    }

    .rf-detail {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      overflow: auto;
      min-height: 0;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .rf-summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
      font-size: 12px;
      color: var(--muted);
    }

    .rf-summary strong {
      display: block;
      color: var(--ink);
      font-size: 14px;
      margin-top: 2px;
    }

    .rf-hex {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      background: #f7f7f7;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      word-break: break-all;
    }

    .rf-kv {
      font-size: 12px;
      color: var(--muted);
      display: grid;
      gap: 4px;
    }

    .meshscore-body {
      padding: 16px;
      display: grid;
      gap: 16px;
      overflow: auto;
    }

    .meshscore-hero {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px 16px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .meshscore-cards {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .meshscore-chart {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .range-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .range-tabs button {
      border: 1px solid var(--line);
      background: #f7f7f7;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .range-tabs button.active {
      background: rgba(0, 122, 255, 0.12);
      color: var(--blue);
    }

    .meshscore-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    #routeMap {
      height: 100%;
      width: 100%;
      background: repeating-linear-gradient(
        135deg,
        rgba(10, 11, 14, 0.04),
        rgba(10, 11, 14, 0.04) 14px,
        transparent 14px,
        transparent 28px
      );
    }

    .analysis-body {
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }

    .modal.open {
      display: flex;
    }

    .modal-card {
      width: min(420px, 100%);
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 18px;
      display: grid;
      gap: 12px;
    }

    .route-modal-card {
      width: min(760px, 100%);
    }

    .flash-panel {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .flash-panel.open {
      display: flex;
    }

    .flash-log {
      background: #0c111b;
      color: #d2d9e6;
      border-radius: 12px;
      padding: 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      min-height: 180px;
      max-height: 280px;
      overflow: auto;
      white-space: pre-wrap;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .flash-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .flash-row strong {
      color: var(--ink);
    }

    .route-override-list {
      display: grid;
      gap: 10px;
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
    }

    .route-override-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 8px;
    }

    .route-override-label {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .route-override-label strong {
      font-size: 13px;
      color: var(--ink);
    }

    .route-override-select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
    }

    .route-override-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .route-override-empty {
      font-size: 13px;
      color: var(--muted);
      padding: 12px 0;
    }

    .field {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .field input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 13px;
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel {
      background: var(--panel);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .route-override-row {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .range-tabs button {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
    }
    body.theme-dark .route-override-select,
    body.theme-dark .rf-input {
      background: var(--panel);
      color: var(--ink);
    }

    body.view-rotm {
      overflow: auto;
      height: auto;
    }

    body.view-rotm .app {
      height: auto;
      min-height: 100vh;
    }

    body.view-rotm .rotm-panel,
    body.view-rotm .rotm-body {
      overflow: visible;
      height: auto;
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel,
    body.theme-dark .route-override-row,
    body.theme-dark .route-override-select,
    body.theme-dark .field input,
    body.theme-dark .observer-grid input,
    body.theme-dark .observer-grid select,
    body.theme-dark .rank-body,
    body.theme-dark .rank-map,
    body.theme-dark .observer-rank-body,
    body.theme-dark .observer-rank-map,
    body.theme-dark .observer-map,
    body.theme-dark .analysis-body,
    body.theme-dark .meshscore-body,
    body.theme-dark .rank-body,
    body.theme-dark .rf-body,
    body.theme-dark .rf-table,
    body.theme-dark .rf-row,
    body.theme-dark .route-override-list,
    body.theme-dark .modal-card {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .range-tabs button.active {
      background: rgba(99, 162, 255, 0.16);
      color: var(--blue);
    }
    body.theme-dark .modal {
      background: rgba(0, 0, 0, 0.6);
    }
    body.theme-dark #meshChart {
      background: rgba(255, 255, 255, 0.04) !important;
    }
    body.theme-dark .rank-summary {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .summary-card {
      background: var(--panel);
      color: var(--muted);
    }
    body.theme-dark .rank-search {
      background: var(--panel);
      color: var(--ink);
      box-shadow: none;
    }
    body.theme-dark .rank-item {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rank-summary,
    body.theme-dark .summary-card,
    body.theme-dark .rank-search,
    body.theme-dark .rank-item {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rank-item .row,
    body.theme-dark .rank-search::placeholder {
      color: var(--muted);
    }
      body.theme-dark .summary-card,
      body.theme-dark .observer-card,
      body.theme-dark .why-card {
        background: var(--panel) !important;
        color: var(--ink);
        border-color: var(--line);
      }
      body.theme-dark .summary-card strong,
      body.theme-dark .observer-card strong,
      body.theme-dark .why-card h3 {
        color: var(--ink);
      }
      body.theme-dark .rank-history .history-item {
        background: var(--panel);
        border-color: var(--line);
        color: var(--muted);
      }
      body.theme-dark .rank-history .history-item .history-time {
        color: var(--ink);
      }
    body.theme-dark .badge,
    body.theme-dark .chip,
    body.theme-dark .list-item {
      background: rgba(255, 255, 255, 0.04) !important;
      color: var(--ink);
      border-color: var(--line);
    }
    body.theme-dark .chip-strong {
      background: rgba(255, 255, 255, 0.1) !important;
      border-color: rgba(231, 238, 251, 0.2);
      color: var(--ink);
    }
    body.theme-dark .badge.badge-green { color: #7bdc98; }
    body.theme-dark .badge.badge-blue { color: #8bb6ff; }
    body.theme-dark .badge.badge-amber { color: #f2c88b; }
    body.theme-dark .badge.badge-purple { color: #b5a9ff; }
    body.theme-dark .badge.badge-gray { color: #c7c7cc; }
    body.theme-dark .observer-step {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
      border-color: var(--line);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    body.view-channels .rank-panel,
    body.view-channels .meshscore-panel { display: none; }
    body.view-channels .sidebar-panel,
    body.view-channels .content,
    body.view-channels .analysis-panel { display: flex; }

    body.view-rank .sidebar-panel,
    body.view-rank .content,
    body.view-rank .analysis-panel,
    body.view-rank .meshscore-panel { display: none; }
    body.view-rank .rank-panel { display: flex; }

    body.view-meshscore .sidebar-panel,
    body.view-meshscore .content,
    body.view-meshscore .analysis-panel,
    body.view-meshscore .rank-panel { display: none; }
    body.view-meshscore .meshscore-panel { display: flex; }

    body.view-rf .sidebar-panel,
    body.view-rf .content,
    body.view-rf .analysis-panel,
    body.view-rf .rank-panel,
    body.view-rf .meshscore-panel { display: none; }
    body.view-rf .rf-panel { display: flex; }

    body.view-observer .sidebar-panel,
    body.view-observer .content,
    body.view-observer .analysis-panel,
    body.view-observer .rank-panel,
    body.view-observer .meshscore-panel,
    body.view-observer .rf-panel,
    body.view-observer .observer-rank-panel,
    body.view-observer .repeater-panel { display: none; }
    body.view-observer .observer-panel { display: flex; }
    body.view-why .sidebar-panel,
    body.view-why .content,
    body.view-why .analysis-panel,
    body.view-why .rank-panel,
    body.view-why .meshscore-panel,
    body.view-why .rf-panel,
    body.view-why .observer-panel,
    body.view-why .observer-rank-panel,
    body.view-why .repeater-panel { display: none; }
    body.view-why .why-panel { display: flex; }

    body.view-observer-rank .sidebar-panel,
    body.view-observer-rank .content,
    body.view-observer-rank .analysis-panel,
    body.view-observer-rank .rank-panel,
    body.view-observer-rank .meshscore-panel,
    body.view-observer-rank .rf-panel,
    body.view-observer-rank .observer-panel,
    body.view-observer-rank .repeater-panel { display: none; }
    body.view-observer-rank .observer-rank-panel { display: flex; }

    body.view-node-rank .sidebar-panel,
    body.view-node-rank .content,
    body.view-node-rank .analysis-panel,
    body.view-node-rank .rank-panel,
    body.view-node-rank .meshscore-panel,
    body.view-node-rank .rf-panel,
    body.view-node-rank .observer-panel,
    body.view-node-rank .observer-rank-panel,
    body.view-node-rank .repeater-panel,
    body.view-node-rank .why-panel { display: none; }
    body.view-node-rank .node-rank-panel { display: flex; }

    body.view-rotm .sidebar-panel,
    body.view-rotm .content,
    body.view-rotm .analysis-panel,
    body.view-rotm .rank-panel,
    body.view-rotm .meshscore-panel,
    body.view-rotm .rf-panel,
    body.view-rotm .observer-panel,
    body.view-rotm .observer-rank-panel,
    body.view-rotm .repeater-panel,
    body.view-rotm .why-panel,
    body.view-rotm .node-rank-panel { display: none; }
    body.view-rotm .rotm-panel { display: flex; }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .badge {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-weight: 600;
      color: var(--ink);
      background: #f7f7f7;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .badge.badge-green { background: rgba(52, 199, 89, 0.16); border-color: rgba(52, 199, 89, 0.28); color: #1b6b35; }
    .badge.badge-blue { background: rgba(0, 122, 255, 0.16); border-color: rgba(0, 122, 255, 0.28); color: #0a60d1; }
    .badge.badge-amber { background: rgba(255, 149, 0, 0.18); border-color: rgba(255, 149, 0, 0.28); color: #9a5b00; }
    .badge.badge-purple { background: rgba(88, 86, 214, 0.18); border-color: rgba(88, 86, 214, 0.28); color: #3b39a5; }
    .badge.badge-gray { background: rgba(142, 142, 147, 0.18); border-color: rgba(142, 142, 147, 0.28); color: #4a4a4f; }
    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .list-item {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #fafafa;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .channel-remove {
      border: 0;
      background: transparent;
      color: #ff3b30;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
      display: none;
    }
    .admin-only {
      display: none;
    }
    .repeater-location-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .repeater-location-controls input {
      width: 92px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
    }
    .repeater-location-controls .btn {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
    }
    .channel-history-control {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .channel-history-control select {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 2px 8px;
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
    }

    .slider {
      width: 100%;
    }

    .observer-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }
    .observer-location-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .observer-location-modal.open { display: flex; }
    .observer-location-card {
      width: min(92vw, 560px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      padding: 14px;
    }
    .observer-location-map {
      height: 260px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--line);
    }
    .observer-location-meta {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .observer-location-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .observer-location-button {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 11px;
    }

    .observer-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .why-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .why-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .why-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 18px;
      background: #ffffff;
      display: grid;
      gap: 14px;
      align-content: start;
    }

    .why-card h3 {
      margin: 0;
      font-size: 16px;
    }

    .why-card p {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--ink);
    }

    .faq-item strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .faq-item p {
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }

    .observer-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .observer-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px 14px;
      background: #ffffff;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .observer-right {
      display: grid;
      gap: 16px;
      align-content: start;
    }

    .observer-log {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .observer-steps {
      display: grid;
      gap: 8px;
    }

    .observer-step {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 4px;
    }

    .observer-step strong {
      font-size: 13px;
    }

    .observer-grid {
      display: grid;
      gap: 8px;
    }

    .observer-grid label {
      font-size: 12px;
      color: var(--muted);
    }

    .observer-grid input,
    .observer-grid select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
    }

    .observer-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .observer-map {
      width: 100%;
      height: 360px;
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }

    .observer-map .leaflet-container {
      width: 100%;
      height: 100%;
    }

    .observer-legend {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .observer-legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .observer-legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #34c759;
    }

    .observer-legend i.warn { background: #ff9500; }
    .observer-legend i.bad { background: #ff3b30; }

    .observer-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .link-btn {
      border: 0;
      background: transparent;
      color: var(--blue-dark);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .install-log {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #0b1120;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .install-log.active {
      display: block;
    }

    @keyframes slideIn {
      from { transform: translateY(8px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @media (max-width: 1200px) {
      .app { grid-template-columns: 240px 1fr; }
      .analysis-panel { display: none; }
    }

    @media (max-width: 860px) {
      body { height: 100vh; overflow: hidden; }
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height: 100vh;
        padding: 8px;
      }
      .topbar {
        gap: 6px;
        padding: 6px 8px;
        min-height: 40px;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      .brand-logo { width: 32px; height: 32px; }
      .brand-text span { display: none; }
      .nav { display: none; }
      .menu-toggle { display: inline-flex; }
      .theme-toggle { margin-left: auto; }
      .menu-toggle { margin-left: 6px; }
      .nav a[data-view="observer"] { display: none; }
      .sidebar-panel {
        display: flex;
        position: fixed;
        top: 52px;
        left: 8px;
        bottom: 8px;
        width: min(86vw, 360px);
        z-index: 960;
        transform: translateX(-110%);
        transition: transform 0.2s ease;
      }
      body.view-channels.menu-open-left .sidebar-panel { transform: translateX(0); }
      body.menu-open-left .menu-backdrop,
      body.menu-open-right .menu-backdrop { display: block; }
      body.menu-open-right .mobile-menu { display: flex; transform: translateX(0); }
      .mobile-nav { display: flex; }
      .sidebar { padding: 8px; gap: 8px; }
      .channel { padding: 8px; grid-template-columns: 36px 1fr auto; gap: 8px; }
      .channel .snippet { font-size: 11px; }
      .panel { min-height: 0; }
      .content { min-height: 0; height: 100%; padding-bottom: env(safe-area-inset-bottom); }
      .channel-selector { display: inline-flex; }
      body.view-channels .channels-rail { display: inline-flex; }
      .messages {
        padding: 10px 12px;
        gap: 10px;
        flex: 1;
        overflow: auto;
        padding-bottom: calc(120px + env(safe-area-inset-bottom));
        scroll-padding-bottom: calc(120px + env(safe-area-inset-bottom));
        overflow-x: hidden;
      }
      .message { grid-template-columns: 36px 1fr; gap: 10px; min-width: 0; }
      .avatar { width: 32px; height: 32px; font-size: 12px; }
      .bubble { padding: 8px 12px; border-radius: 12px; max-width: 85%; }
      .message .meta { font-size: 11px; }
      .msg-footer { font-size: 11px; gap: 8px; }
      .analysis-panel {
        position: fixed;
        left: 8px;
        right: 8px;
        bottom: max(8px, env(safe-area-inset-bottom));
        height: 60vh;
        max-width: calc(100vw - 16px);
        z-index: 10;
        display: none;
      }
      .analysis-panel .title {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .analysis-panel .title .route-close {
        margin-left: auto;
      }
      html body.view-rotm { height: auto; overflow: auto; }
      body.view-rotm .app { height: auto; min-height: 100vh; }
      .rotm-grid { grid-template-columns: 1fr; }
      .rotm-settings-grid { grid-template-columns: 1fr; }
      .rotm-leader-row {
        grid-template-columns: 28px 1fr;
        grid-template-rows: auto auto;
      }
      .rotm-leader-row .rotm-leader-meta {
        grid-column: 1 / -1;
      }
      #rotmMap { height: 260px; }
      body.view-channels .analysis-panel { display: none; }
      body.route-open.view-channels .analysis-panel { display: flex; }
      body.route-open .route-backdrop { display: block; }
      .analysis { grid-template-rows: 1fr auto; }
      #routeMap { min-height: 200px; }
      .route-close { display: inline-flex; }
      .rank-body { grid-template-columns: 1fr; }
      .rank-summary { padding: 8px 10px; gap: 8px; }
      .summary-card { padding: 8px 10px; }
      .summary-card strong { font-size: 14px; }
      .rank-detail-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 0, 0, 0.4);
        align-items: center;
        justify-content: center;
        z-index: 900;
      }
      .rank-detail-overlay.open {
        display: flex;
      }
      .rank-detail-card {
        background: var(--panel);
        border-radius: 18px;
        padding: 20px;
        width: min(96vw, 520px);
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      }
      .rank-detail-close {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 12px;
      }
      .rank-detail-close button {
        background: none;
        border: none;
        color: var(--muted);
        font-size: 18px;
        cursor: pointer;
      }
      .rank-detail-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 14px;
      }
      .route-history-title {
        font-size: 16px;
        font-weight: 700;
        margin-bottom: 4px;
      }
      .route-history-meta {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 12px;
      }
      .route-history-list {
        display: grid;
        gap: 10px;
      }
      .route-history-item {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        background: var(--panel);
      }
      .route-history-path {
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 6px;
      }
      .route-history-sub {
        color: var(--muted);
        font-size: 12px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .rank-body { height: auto; }
      .rank-map { display: none; }
      #rankMap { display: none; }
      #observerRankMap { display: none; }
      .node-rank-map { display: none; }
      #nodeRankMap { display: none; }
      .rank-scroll,
      #channels {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      .rank-scroll::-webkit-scrollbar,
      #channels::-webkit-scrollbar {
        width: 0 !important;
        height: 0 !important;
        background: transparent !important;
      }
      .rank-scroll::-webkit-scrollbar-track,
      #channels::-webkit-scrollbar-track,
      .rank-scroll::-webkit-scrollbar-thumb,
      #channels::-webkit-scrollbar-thumb {
        background: transparent !important;
        border: none !important;
      }
      #channels {
        max-height: 100%;
        overflow: overlay;
        overflow-x: hidden;
      }
      .rf-body { grid-template-columns: 1fr; }
      .rf-table { overflow-x: auto; }
      body.view-rf .rf-row { min-width: 0; grid-template-columns: 70px 70px 1fr 70px 60px 60px; }
      body.view-rf .rf-row > div:nth-child(3),
      body.view-rf .rf-row > div:nth-child(4),
      body.view-rf .rf-row > div:nth-child(5),
      body.view-rf .rf-row > div:nth-child(10),
      body.view-rf .rf-row > div:nth-child(11),
      body.view-rf .rf-row > div:nth-child(12) { display: none; }
      .observer-body { grid-template-columns: 1fr; }
      .observer-map { height: 260px; }
      .observer-rank-body { grid-template-columns: 1fr; }
      .observer-rank-map { display: none; }
      #observerRankMap { display: none; }
      .why-body { grid-template-columns: 1fr; }
      .meshscore-panel { min-height: 0; overflow: hidden; }
      .meshscore-body { min-height: 0; height: 100%; overflow: auto; }
      body.view-rank .rank-panel,
      body.view-observer-rank .observer-rank-panel,
      body.view-node-rank .node-rank-panel { overflow: auto; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
        <div class="brand">
          <div class="brand-logo">
            <img src="/meshrank.png?v=1.1.2" alt="MeshRank logo"/>
          </div>
          <div class="brand-text">
            <strong>MeshRank.net</strong>
            <span>by G5AIL</span>
          </div>
        </div>
      <nav class="nav">
        <a href="#" class="active" data-view="channels">Channels</a>
        <a href="#" class="admin-only" data-view="rotm">#ROTM</a>
        <a href="#" data-view="rank">Repeater Rank</a>
        <a href="#" data-view="node-rank">Node Rank</a>
        <a href="#" data-view="meshscore">MeshRank</a>
        <a href="#" data-view="observer-rank">Observer Rank</a>
        <a href="#" data-view="rf">MeshFlow</a>
        <a href="#" data-view="why">Why MeshRank?</a>
        <a href="#" data-view="observer">Become an Observer</a>
      </nav>
      <button class="theme-toggle" id="themeToggle" type="button" aria-pressed="false">Dark mode</button>
      <button class="btn" id="loginBtn" type="button">Login</button>
      <button class="menu-toggle" id="menuToggle" type="button" aria-label="Open menu">
        <span class="burger" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
        </span>
      </button>
    </header>
    <div class="menu-backdrop" id="menuBackdrop"></div>
    <div class="mobile-menu" id="mobileMenu">
      <a href="#" class="active" data-view="channels">Channels</a>
      <a href="#" class="admin-only" data-view="rotm">#ROTM</a>
      <a href="#" data-view="rank">Repeater Rank</a>
      <a href="#" data-view="node-rank">Node Rank</a>
      <a href="#" data-view="meshscore">MeshRank</a>
      <a href="#" data-view="observer-rank">Observer Rank</a>
      <a href="#" data-view="rf">MeshFlow</a>
      <a href="#" data-view="why">Why MeshRank?</a>
      <a href="#" data-view="observer">Become an Observer</a>
    </div>

    <section class="panel sidebar-panel">
      <div class="title column">
        <span>Channels <span class="chip">UK Mesh</span></span>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn" id="addChannelBtn">Add Channel</button>
          <div class="admin-only channel-history-control">
            <span>History</span>
            <select id="channelHistoryLimit" aria-label="Channel history limit"></select>
          </div>
        </div>
      </div>
      <div class="sidebar">
        <div id="channels"></div>
      </div>
    </section>

    <section class="panel content">
      <div class="title channel-title">
        <button class="channel-selector" type="button" data-channels-toggle>
          <span>Other channels</span>
          <span class="badge-bubble channels-unread">0</span>
        </button>
        <span class="channel-title-label">Other channels</span>
        <button class="channel-selector" id="channelsTab" type="button" data-channels-toggle>
          <span id="activeChannel">#public</span>
        </button>
      </div>
      <div class="messages" id="messages"></div>
    </section>

    <div class="route-backdrop" id="routeBackdrop"></div>
    <section class="panel analysis-panel">
      <div class="title">Route Path <span class="chip" id="routeKey">none</span><button class="route-close" id="routeClose" type="button">Close</button></div>
      <div class="analysis">
        <div id="routeMap"></div>
        <div id="routeLegend" class="route-legend"></div>
        <div class="analysis-body">
          <div class="row"><span>Message key</span><span id="routeMessage">-</span></div>
          <div class="row"><span>Source</span><span id="routeSource">-</span></div>
          <div class="row"><span>Confidence</span><span id="routeConfidence">-</span></div>
          <div class="row"><span>Path depth</span><span id="routeDepth">-</span></div>

          <div class="row"><span>Packets heard</span><span class="badge" id="routeCount">0</span></div>
          <div class="list" id="routeList"></div>
          <div style="display:flex;align-items:center;gap:8px;">
            <button class="link-btn" id="routeOverrideBtn" type="button" onclick="window.openRouteOverride && window.openRouteOverride()">Route path wrong?</button>
            <span style="font-size:12px;color:var(--muted);">Suggest a correction for a 2-digit code.</span>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rotm-panel" id="rotm">
      <div class="title rotm-title">
        <span>#ROTM  Repeaters on the Mesh</span>
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
          <button class="rotm-info-link" type="button" id="rotmInfoBtn">What is this?</button>
          <button class="rotm-info-link admin-only" type="button" id="rotmSettingsBtn">Change ROTM key</button>
          <span class="chip" id="rotmUpdated">--</span>
        </div>
      </div>
      <div class="rotm-body">
        <div class="rotm-grid">
          <div class="rotm-card">
            <div class="rotm-card-title">Live #rotm activity feed</div>
            <div class="rotm-feed" id="rotmFeed"></div>
          </div>
          <div class="rotm-card">
            <div class="rotm-card-title">Node claims leaderboard</div>
            <div class="rotm-leaderboard" id="rotmLeaderboard"></div>
            <div class="rotm-map-title" id="rotmMapTitle">Claimed repeaters map</div>
            <div id="rotmMap"></div>
            <div class="rotm-claim-list" id="rotmClaimList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rank-panel">
      <div class="title">Repeater Rank <span class="chip" id="rankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total repeaters</div>
          <strong id="rankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="rankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>MeshRank today</div>
          <strong id="rankMeshToday">0</strong>
          <div style="font-size:11px;color:var(--muted);">Yesterday: <span id="rankMeshYesterday">0</span></div>
        </div>
      </div>
      <div class="rank-body">
        <div class="rank-map">
          <div id="rankMap"></div>
        </div>
        <div class="rank-list">
          <div class="rank-loading" id="rankLoading">
            <span class="spinner" aria-hidden="true"></span>
            <span>Running repeater rank, please hold</span>
          </div>
          <input class="rank-search" id="rankSearch" type="text" placeholder="Search repeaters"/>
          <div class="rank-scroll" id="rankScroll">
            <div id="rankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel node-rank-panel">
      <div class="title">Node Rank <span class="chip" id="nodeRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total nodes</div>
          <strong id="nodeRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="nodeRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Messages (24h)</div>
          <strong id="nodeRankMessages">0</strong>
        </div>
      </div>
      <div class="rank-body node-rank-body">
        <div class="rank-map node-rank-map">
          <div id="nodeRankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="nodeRankSearch" type="text" placeholder="Search nodes"/>
          <div class="rank-scroll" id="nodeRankScroll">
            <div id="nodeRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel meshscore-panel">
      <div class="title">MeshRank <span class="chip" id="meshUpdated">--</span></div>
      <div class="meshscore-body">
        <div class="meshscore-hero">
          <div style="font-weight:700;">MeshRank tracks network health using active repeaters, message volume, and repeat reliability.</div>
          <div style="font-size:12px;color:var(--muted);">Scores update from live RF logs and decoded mesh traffic. Higher scores mean wider coverage, better repeat density, and more reliable delivery.</div>
        </div>
        <div class="meshscore-cards">
          <div class="summary-card">
            <div>MeshRank today</div>
            <strong id="meshToday">0</strong>
          </div>
          <div class="summary-card">
            <div>MeshRank yesterday</div>
            <strong id="meshYesterday">0</strong>
          </div>
          <div class="summary-card">
            <div>Change</div>
            <strong id="meshDelta">0</strong>
          </div>
          <div class="summary-card">
            <div>Messages (24h)</div>
            <strong id="meshMessages">0</strong>
          </div>
        </div>
        <div class="meshscore-chart">
          <div class="range-tabs" id="meshRangeTabs">
            <button data-range="7" class="active">7d</button>
            <button data-range="30">30d</button>
            <button data-range="90">90d</button>
            <button data-range="365">1y</button>
          </div>
          <svg id="meshChart" viewBox="0 0 600 220" width="100%" height="220" style="background:var(--panel);border-radius:12px;">
            <polyline id="meshLine" fill="none" stroke="#007aff" stroke-width="3" points=""></polyline>
            <polyline id="meshArea" fill="rgba(0,122,255,0.12)" stroke="none" points=""></polyline>
          </svg>
        </div>
        <div class="meshscore-grid">
          <div class="summary-card">
            <div>Total devices</div>
            <strong id="meshDevices">0</strong>
          </div>
          <div class="summary-card">
            <div>Repeaters active</div>
            <strong id="meshRepeaters">0</strong>
          </div>
          <div class="summary-card">
            <div>Room servers</div>
            <strong id="meshRooms">0</strong>
          </div>
          <div class="summary-card">
            <div>Chat nodes</div>
            <strong id="meshChat">0</strong>
          </div>
          <div class="summary-card">
            <div>Companion nodes</div>
            <strong id="meshCompanions">0</strong>
          </div>
          <div class="summary-card">
            <div>Mesh msgs today</div>
            <strong id="meshMsgsToday">0</strong>
          </div>
          <div class="summary-card">
            <div>Observer msgs today</div>
            <strong id="meshMsgsObserver">0</strong>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rf-panel">
      <div class="title">MeshFlow <span class="chip" id="rfCount">0 packets</span></div>
      <div class="rf-body">
        <div class="rf-table">
          <div class="rf-controls">
            <input class="rf-input" id="rfSearch" type="text" placeholder="Search hash or hex"/>
            <select class="rf-input" id="rfTypeFilter">
              <option value="">All types</option>
              <option value="Advert">Advert</option>
              <option value="GroupText">GroupText</option>
              <option value="Request">Request</option>
              <option value="Response">Response</option>
              <option value="Path">Path</option>
              <option value="Ack">Ack</option>
            </select>
            <span class="chip" id="rfUpdated">--</span>
          </div>
          <div class="rf-summary">
            <div>Total packets<strong id="rfTotal">0</strong></div>
            <div>CRC ok<strong id="rfOk">0</strong></div>
            <div>CRC bad<strong id="rfBad">0</strong></div>
            <div>Top type<strong id="rfTopType">--</strong></div>
          </div>
          <div class="rf-list" id="rfList"></div>
        </div>
        <div class="rf-detail" id="rfDetail">
          <div class="rf-kv">Select a packet to inspect its payload.</div>
        </div>
      </div>
    </section>

    <section class="panel observer-panel">
      <div class="title">Become an Observer <span class="chip">Quick setup</span></div>
      <div class="observer-body">
          <div class="observer-card">
            <div style="font-weight:700;">Bring your observer online</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.5;">
              Observer Nodes listen silently and relay RF traffic to MeshRank without stressing repeaters.
              Place it where Wi-Fi and RF are strong. Firmware is Heltec V3 only.
            </div>
            <div class="observer-steps">
              <div class="observer-step"><strong>1</strong> Plug in your Heltec V3 in DFU mode.</div>
              <div class="observer-step">
                <strong>2</strong> Flash the firmware via MeshCore flasher.
                <div class="observer-actions">
                  <button class="btn" id="observerFlashLink" type="button">Open MeshRank Flasher</button>
                </div>
                <div style="font-size:12px;color:var(--muted);">The in-page flasher erases and writes the full merged firmware image, then reboots the device.</div>
                <div class="flash-panel" id="flashPanel">
                  <div style="font-weight:700;">MeshRank Observer Flasher</div>
                  <div style="font-size:12px;color:var(--muted);line-height:1.5;">
                    This flashes the full merged image for Heltec V3 (ESP32-S3). It will erase the device first.
                  </div>
                  <div class="flash-row">
                    <div>Firmware</div>
                    <strong id="flashVersion">observer-merged-1.1.8.bin</strong>
                  </div>
                  <div class="flash-row">
                    <div>Offset</div>
                    <strong>0x0 (full image)</strong>
                  </div>
                  <div class="flash-log" id="flashLog">Ready to flash.</div>
                  <div class="observer-actions">
                    <button class="btn" id="flashStart" type="button">Start flash</button>
                    <button class="btn" id="flashHide" type="button">Hide</button>
                  </div>
                </div>
              </div>
              <div class="observer-step">
                <strong>3</strong> Enter your Wi-Fi credentials and click send, then reboot the node.
                <div class="observer-grid">
                  <div>
                    <label for="observerName">Observer name</label>
                    <input id="observerName" type="text" placeholder="Observer name"/>
                  </div>
                  <div>
                    <label for="observerWifi">Wi-Fi SSID</label>
                    <input id="observerWifi" type="text" placeholder="MyWiFi"/>
                  </div>
                  <div>
                    <label for="observerPass">Wi-Fi password</label>
                    <input id="observerPass" type="password" placeholder="password"/>
                  </div>
                </div>
                <div class="observer-actions">
                  <button class="btn" type="button" id="observerSendConfig">Send Wi-Fi config</button>
                </div>
              </div>
              <div class="observer-step"><strong>4</strong> If your node appears in Pending Observers, send a repeater advert to speed up geolocation.</div>
              <div class="observer-step"><strong>5</strong> Once validated, it moves to Observer Rank automatically.</div>
            </div>
          <div class="observer-status" id="observerStatus"></div>
          <div id="installLog" class="install-log">Verbose install log ready.</div>
        </div>
        <div class="observer-right">
          <div class="observer-card">
            <div style="font-weight:700;">Current Observer Coverage</div>
            <div class="observer-legend">
              <span><i></i> Active &lt; 24h</span>
              <span><i class="warn"></i> Low packet rate (15m-24h)</span>
              <span><i class="bad"></i> Offline 24h+</span>
            </div>
            <div style="font-size:12px;color:var(--muted);">Location pending observers stay off the map until validated.</div>
            <div id="observerMap" class="observer-map"></div>
          </div>
          <div class="observer-card">
            <div style="font-weight:700;">Pending Observers</div>
            <div style="font-size:12px;color:var(--muted);">Only observers awaiting geolocation appear here.</div>
            <div id="observerList" class="rf-list"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel observer-rank-panel">
      <div class="title">Observer Rank <span class="chip" id="observerRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total observers</div>
          <strong id="observerRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (&lt;24h)</div>
          <strong id="observerRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Packets today</div>
          <strong id="observerRankPackets">0</strong>
        </div>
      </div>
      <div class="rank-body observer-rank-body">
        <div class="rank-map observer-rank-map">
          <div id="observerRankMap"></div>
        </div>
        <div class="rank-list">
          <div class="rank-loading" id="observerRankLoading">
            <span class="spinner" aria-hidden="true"></span>
            <span>Running observer rank, please hold</span>
          </div>
          <input class="rank-search" id="observerRankSearch" type="text" placeholder="Search observers"/>
          <div class="rank-scroll" id="observerRankScroll">
            <div id="observerRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <div class="observer-location-modal" id="observerLocationModal">
      <div class="observer-location-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong>Set Observer Location</strong>
          <button class="observer-location-button" type="button" id="observerLocationClose">Close</button>
        </div>
        <div class="observer-location-map" id="observerLocationMap"></div>
        <div class="observer-location-meta">
          <span id="observerLocationLabel">Observer: --</span>
          <span id="observerLocationCoords">Lat/Lon: --</span>
        </div>
        <div class="observer-location-actions">
          <button class="btn" type="button" id="observerLocationSave">Save location</button>
        </div>
      </div>
    </div>

    <div class="observer-location-modal" id="repeaterLocationModal">
      <div class="observer-location-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong>Set Repeater Location</strong>
          <button class="observer-location-button" type="button" id="repeaterLocationClose">Close</button>
        </div>
        <div class="observer-location-map" id="repeaterLocationMap"></div>
        <div class="observer-location-meta">
          <span id="repeaterLocationLabel">Repeater: --</span>
          <span id="repeaterLocationCoords">Lat/Lon: --</span>
        </div>
        <div class="observer-location-actions">
          <button class="btn" type="button" id="repeaterLocationSave">Save location</button>
        </div>
      </div>
    </div>

    <div class="neighbor-map-modal" id="neighborMapModal">
      <div class="neighbor-map-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong id="neighborMapTitle">Zero-hop Neighbors</strong>
          <button class="observer-location-button" type="button" id="neighborMapClose">Close</button>
        </div>
        <div class="neighbor-map" id="neighborMap"></div>
        <div class="neighbor-map-legend">
          <div class="neighbor-map-legend-item"><span class="neighbor-map-legend-swatch" style="background:#34c759;"></span>Good RSSI</div>
          <div class="neighbor-map-legend-item"><span class="neighbor-map-legend-swatch" style="background:#ffcc00;"></span>Unknown/OK</div>
          <div class="neighbor-map-legend-item"><span class="neighbor-map-legend-swatch" style="background:#ff3b30;"></span>Weak RSSI</div>
        </div>
          <div class="confidence-meta" id="neighborMapMeta">Lines show likely zero-hop neighbours matched using AI-inspired geo intelligence that blends route codes with nearby repeater clusters.</div>
      </div>
    </div>

    <section class="panel why-panel">
      <div class="title">Why MeshRank?</div>
      <div class="why-body">
        <div class="why-card">
          <h3>Why MeshRank?</h3>
          <p>Mesh networks promise resilience, but in their early stages they often struggle with something more basic: confidence.</p>
          <p>With MeshCORE, new repeaters are frequently deployed into sparse or growing networks. When messages dont appear to move  or theres no clear feedback  operators naturally assume the repeater isnt helping. Too often, it gets switched off, and the network loses coverage just when it needs it most.</p>
          <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping?</p>
          <p>By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient. MeshRank exists to change that experience.</p>
          <p>It provides visibility into how the mesh is actually performing:</p>
          <p>Which repeaters are active and contributing over time. Which messages were delivered, with a confidence score rather than guesswork. Where messages were observed but failed to fully propagate.</p>
          <p>This feedback loop keeps operators engaged and informed, even when the network is still maturing.</p>
          <p>MeshRank uses a passive observer network to provide insight without increasing mesh traffic. By reducing the need for repeated test messages, it lowers network load while giving users meaningful information about whats happening behind the scenes.</p>
          <p>Repeaters are ranked based on real contribution, not assumptions  encouraging operators to keep nodes online, improve placement, and actively strengthen the network.</p>
          <p>MeshRank doesnt replace the mesh, and it doesnt route traffic through the internet. It simply helps the mesh understand itself.</p>
          <p>Visibility builds confidence. Confidence builds resilience.</p>
        </div>
        <div class="why-card">
          <h3>Frequently Asked Questions</h3>
          <div class="faq-item">
            <strong>Does MeshRank route messages over the internet?</strong>
            <p>No. MeshRank does not forward, relay, or complete mesh messages using the internet. All mesh communication still happens entirely over RF. MeshRank only observes what has already occurred and reports that information back to users.</p>
          </div>
          <div class="faq-item">
            <strong>Does this break the idea of a pure mesh?</strong>
            <p>No. The mesh remains fully autonomous and functional without MeshRank. If MeshRank disappeared tomorrow, the mesh would continue to operate exactly as it does today. MeshRank does not participate in routing decisions, message delivery, or network control  it provides visibility, not dependency.</p>
          </div>
          <div class="faq-item">
            <strong>Why involve the internet at all?</strong>
            <p>Because feedback matters. In early and sparse networks, lack of feedback causes repeaters to be switched off, not improved. MeshRank uses off-mesh observation to help operators understand whats happening without increasing RF traffic or adding test spam to the network. This strengthens the mesh  it doesnt weaken it.</p>
          </div>
          <div class="faq-item">
            <strong>Could this become a central point of failure?</strong>
            <p>No. MeshRank is not in the message path. It cannot block, delay, or interfere with mesh traffic. If MeshRank goes offline, the mesh continues to operate unchanged. There is no reliance on MeshRank for delivery, routing, or authentication.</p>
          </div>
          <div class="faq-item">
            <strong>Does this reduce resilience by encouraging internet dependence?</strong>
            <p>Quite the opposite. MeshRank encourages: better repeater placement, higher uptime, reduced test traffic, and faster identification of coverage gaps. All of these increase RF-only resilience, even when the internet is unavailable.</p>
          </div>
          <div class="faq-item">
            <strong>Is this surveillance or message tracking?</strong>
            <p>No. Observers do not inject traffic or control the network. They report limited metadata needed to understand propagation  not to monitor users. The goal is network health, not message content analysis.</p>
          </div>
          <div class="faq-item">
            <strong>Why ranking repeaters? Isnt that gamification?</strong>
            <p>Yes  intentionally. Visibility and motivation matter. Ranking makes contribution measurable, encourages operators to keep repeaters online, and helps the network grow during its most fragile phase. Strong networks are built by engaged operators.</p>
          </div>
          <div class="faq-item">
            <strong>What happens when the mesh becomes dense and mature?</strong>
            <p>MeshRank becomes less critical  and thats a success. As density increases, confidence becomes self-sustaining. MeshRanks role naturally shifts toward diagnostics, optimisation, and historical insight rather than reassurance.</p>
          </div>
          <div class="faq-item">
            <strong>So what is MeshRank really for?</strong>
            <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping? By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient.</p>
          </div>
        </div>
      </div>
    </section>
  </div>

    <div class="modal" id="channelModal">
      <div class="modal-card">
        <strong>Add Channel</strong>
      <div class="field">
        <label for="channelName"># Channel name</label>
        <input id="channelName" type="text" placeholder="#public"/>
      </div>
      <div class="field">
        <label for="channelSecret">Secret (32 hex chars)</label>
        <input id="channelSecret" type="text" placeholder="8b3387e9c5cdea6ac9e4edbaa115cd72"/>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelChannel">Cancel</button>
        <button class="btn" id="saveChannel">Save</button>
      </div>
      </div>
    </div>

    <div class="modal" id="rotmInfoModal">
      <div class="modal-card">
        <strong>#ROTM  Repeaters on the Mesh</strong>
        <p>Repeaters on the Mesh (#ROTM) gamifies your mesh activity! Send a "CQ" message on the #rotm channel to activate a repeater, get a reply from another node, and claim that repeater toward your personal score. It's inspired by POTA/SOTA activations and FT8-style quick QSOs  encouraging real-world exploration of mesh coverage while building community.</p>
        <p>How it works: 1. Send CQ on #rotm (e.g. "CQ ROTM testing from @YourNode via hill repeater"). 2. Another node replies mentioning your @node within 5 minutes. 3. If both messages are observed by the network, the repeater is credited to the CQ sender and both nodes log the QSO. Only high-confidence observer data counts!</p>
        <p>MeshRank applies AI-inspired geo intelligence to resolve likely repeater hops before scoring a claim.</p>
        <p>Leaderboards and maps update live. Expand the observer network to hear more repeaters and improve accuracy. Coming soon: badges, milestones, and public access once stable.</p>
        <p><strong>Tips for success:</strong> send clear CQ calls, reply quickly, and place observers strategically to boost confidence and coverage.</p>
        <div class="modal-actions">
          <button class="btn" type="button" id="rotmInfoClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal admin-only" id="rotmSettingsModal">
      <div class="modal-card rotm-settings">
        <strong>ROTM channel settings</strong>
        <div class="rotm-settings-grid">
          <label class="field">
            <span>Channel name</span>
            <input id="rotmChannelName" type="text" placeholder="#rotm"/>
          </label>
          <label class="field">
            <span>Channel secret (32 hex chars)</span>
            <input id="rotmChannelSecret" type="text" placeholder="0123456789abcdef0123456789abcdef"/>
          </label>
        </div>
        <div class="rotm-settings-actions">
          <button class="btn" type="button" id="rotmChannelSave">Save ROTM settings</button>
          <button class="btn" type="button" id="rotmSettingsClose">Close</button>
          <span class="rotm-settings-note" id="rotmChannelStatus">Secret is stored until you update it.</span>
        </div>
      </div>
    </div>

    <div class="modal" id="routeOverrideModal">
      <div class="modal-card route-modal-card">
        <strong>Suggest route fixes</strong>
        <div style="font-size:12px;color:var(--muted);line-height:1.5;">
          Pick the correct repeater for each 2-digit code. Suggestions are weighted over time, so one user cannot rewrite the route.
        </div>
        <div class="route-override-list" id="routeOverrideList"></div>
        <div class="route-override-status" id="routeOverrideStatus">No changes submitted yet.</div>
        <div class="modal-actions">
          <button class="btn" id="routeOverrideClose">Close</button>
          <button class="btn" id="routeOverrideSave">Submit suggestions</button>
        </div>
      </div>
    </div>

    <div class="modal" id="observerHitsModal">
      <div class="modal-card">
        <strong>Observers</strong>
        <div id="observerHitsSummary" style="font-size:12px;color:var(--muted);margin-top:6px;">No observers available.</div>
        <div id="observerHitsList" style="display:grid;gap:8px;margin-top:12px;"></div>
        <div class="modal-actions">
          <button class="btn" id="observerHitsClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="authModal">
      <div class="modal-card">
        <strong>Account</strong>
        <div style="display:grid;gap:10px;margin-top:12px;">
          <input id="authUsername" class="rf-input" type="text" placeholder="Username"/>
          <input id="authPassword" class="rf-input" type="password" placeholder="Password"/>
          <div id="authStatus" style="font-size:12px;color:var(--muted);"></div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="authLogin">Login</button>
          <button class="btn" id="authBootstrap">Setup admin</button>
          <button class="btn" id="authLogout">Logout</button>
          <button class="btn" id="authClose">Close</button>
        </div>
      </div>
    </div>

  </div>

  <script type="module" src="https://unpkg.com/esp-web-tools@9.1.0/dist/web/install-button.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    document.body.classList.add("view-channels");
      const appData = {
        channels: [],
        messages: [],
        lastChannelsSig: "",
        lastMessagesSig: "",
        renderedIdsByChannel: {},
        meshScore: null,
        rankSummary: null,
      rankData: [],
      rankTotalCount: 0,
      rankFilter: "",
        nodeRankSummary: null,
        nodeRank: null,
        unreadByChannel: {},
        lastReadByChannel: {},
        historyByChannel: {},
        rfPackets: [],
        rfSelected: null,
        rfLastSig: "",
        observerRank: null,
        observerRankSummary: null,
        observersById: {},
        observersByName: {},
        observersByIdUpper: {},
        observersByNameLower: {},
        observersUpdatedAt: 0,
        routeSuggestions: null,
        repeatersByCode: null,
        routeActivePathCodes: [],
        routeActivePathPoints: [],
          routeActiveMsg: null,
          channelHistoryLimit: 10,
          authUser: null,
        rotmData: null,
        rotmConfigLoaded: false,
        rotmChannelName: null,
        rotmSelectedNodeKey: null,
        rotmLastFetch: 0,
        latestByChannel: {},
        recentStatsByChannel: {},
        livePulse: {
          timer: null,
          running: false,
          channelId: null,
            startedAt: 0,
            latestSeenTs: 0,
            newMessageCount: 0,
            limitMs: 5000,
            maxNewMessages: 2
          },
          messageStream: {
            es: null
          },
          authToken: null
        };

    const colors = ["#007aff", "#5856d6", "#ff9500", "#34c759"];

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function hasValidGps(r) {
      const lat = r?.gps?.lat;
      const lon = r?.gps?.lon;
      return Number.isFinite(lat) && Number.isFinite(lon) && !(lat === 0 && lon === 0);
    }

    function isRepeaterHidden(r) {
      return !!r?.hiddenOnMap || !hasValidGps(r) || r?.stale;
    }

    function confidence(msg) {
      const repeats = msg.repeats || msg.pathLength || 1;
      const observerCount = Number.isFinite(msg.observerCount)
        ? msg.observerCount
        : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
      const repeatScore = clamp(repeats / 8, 0, 1);
      const observerScore = clamp(observerCount / 3, 0, 1);
      const score = 100 * clamp(0.2 + (0.5 * repeatScore) + (0.3 * observerScore), 0, 1);
      return Math.round(score);
    }

    function mapObserverLabels(list) {
      const byId = appData.observersById || {};
      const byIdUpper = appData.observersByIdUpper || {};
      const byName = appData.observersByName || {};
      const byNameLower = appData.observersByNameLower || {};
      const rawList = Array.isArray(list) ? list : [];
      return rawList.map((raw) => {
        const key = String(raw || "").trim();
        if (!key) return "";
        const upper = key.toUpperCase();
        const lower = key.toLowerCase();
        const entry = byId[key] || byIdUpper[upper] || byName[key] || byNameLower[lower] || null;
        return entry?.name || entry?.id || key;
      }).filter(Boolean);
    }

    function resolveObserverLabel(raw) {
      const key = String(raw || "").trim();
      if (!key) return "";
      const upper = key.toUpperCase();
      const lower = key.toLowerCase();
      const entry =
        appData.observersById?.[key] ||
        appData.observersByIdUpper?.[upper] ||
        appData.observersByName?.[key] ||
        appData.observersByNameLower?.[lower] ||
        null;
      return entry?.name || entry?.id || key;
    }

    function normalizeChannelId(value) {
      return String(value || "").trim().replace(/^#/, "").toLowerCase();
    }

    function loadAuthToken() {
      try {
        return localStorage.getItem("mesh_session_token");
      } catch {
        return null;
      }
    }

    function setRankLoading(show) {
      const el = document.getElementById("rankLoading");
      if (!el) return;
      el.classList.toggle("active", !!show);
    }

    function setObserverRankLoading(show) {
      const el = document.getElementById("observerRankLoading");
      if (!el) return;
      el.classList.toggle("active", !!show);
    }

    function formatRelativeMinutes(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) return "--";
      if (totalMinutes < 60) return `${Math.round(totalMinutes)}m ago`;
      const hours = Math.round(totalMinutes / 60);
      if (hours < 48) return `${hours}h ago`;
      const days = Math.round(totalMinutes / (60 * 24));
      return `${days}d ago`;
    }

    function saveAuthToken(token) {
      try {
        if (token) localStorage.setItem("mesh_session_token", token);
        else localStorage.removeItem("mesh_session_token");
      } catch {}
    }

    function loadChannelHistoryLimit() {
      try {
        const raw = localStorage.getItem("meshrank.channelHistoryLimit");
        const value = Number(raw);
        if (Number.isFinite(value) && value >= 1 && value <= 50) return value;
      } catch {}
      return 10;
    }

    function saveChannelHistoryLimit(value) {
      try {
        localStorage.setItem("meshrank.channelHistoryLimit", String(value));
      } catch {}
    }

    function authHeaders() {
      const token = appData.authToken || loadAuthToken();
      if (!token) return {};
      return { Authorization: `Bearer ${token}` };
    }

    function setAuthUser(user) {
      appData.authUser = user || null;
      const btn = document.getElementById("loginBtn");
      if (btn) {
        btn.textContent = user ? user.username : "Login";
      }
      const status = document.getElementById("authStatus");
      if (status) {
        status.textContent = user
          ? `Logged in as ${user.username}${user.isAdmin ? " (admin)" : ""}`
          : "Not logged in.";
      }
      const isAdmin = !!user?.isAdmin;
      document.querySelectorAll(".admin-only").forEach((el) => {
        if (!isAdmin) {
          el.style.display = "none";
          return;
        }
        if (el.classList.contains("repeater-location-controls")) {
          el.style.display = "flex";
          return;
        }
        if (el.classList.contains("panel") || el.classList.contains("modal")) {
          el.style.display = "";
          return;
        }
        el.style.display = "inline-flex";
      });
      if (!isAdmin && document.body.classList.contains("view-rotm")) {
        document.body.classList.remove("view-rotm");
        document.body.classList.add("view-channels");
      }
      if (isAdmin) {
        fetchRotmConfig()
          .then((cfg) => {
            if (cfg?.channel) appData.rotmChannelName = cfg.channel;
            renderChannels();
          })
          .catch(() => {});
      }
      updateNodeRankVisibility();
      renderChannels();
    }

    function setBootstrapVisibility(hasAdmin) {
      const btn = document.getElementById("authBootstrap");
      if (!btn) return;
      btn.style.display = hasAdmin ? "none" : "inline-flex";
    }

    function updateNodeRankVisibility() {
      const isAuthed = !!appData.authUser;
      document.querySelectorAll('[data-view="node-rank"]').forEach((el) => {
        el.style.display = isAuthed ? "" : "none";
      });
      if (!isAuthed && document.body.classList.contains("view-node-rank")) {
        document.body.classList.remove("view-node-rank");
        document.body.classList.add("view-channels");
        navLinks.forEach((l) => l.classList.remove("active"));
        navLinks.forEach((l) => {
          if (l.dataset.view === "channels") l.classList.add("active");
        });
      }
    }

    async function fetchAuthMe() {
      const res = await fetch("/api/auth/me", { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) return null;
      const data = await res.json();
      return data.user || null;
    }

    function getChannelNameById(id) {
      const entry = appData.channels.find((c) => c.id === id);
      return entry ? entry.name : `#${id}`;
    }

    function stopLiveMessagePulse() {
      const pulse = appData.livePulse;
      if (pulse.timer) clearInterval(pulse.timer);
      pulse.timer = null;
      pulse.running = false;
      pulse.channelId = null;
      pulse.startedAt = 0;
      pulse.latestSeenTs = 0;
      pulse.newMessageCount = 0;
    }

    async function runLiveMessagePulse() {
      const pulse = appData.livePulse;
      if (pulse.running) return;
      if (!pulse.channelId || pulse.channelId !== activeChannelId) return stopLiveMessagePulse();
      if (!document.body.classList.contains("view-channels")) return stopLiveMessagePulse();
      if (Date.now() - pulse.startedAt > pulse.limitMs) return stopLiveMessagePulse();

      pulse.running = true;
      try {
        await loadMessages(false, {
          limit: Math.max(10, appData.channelHistoryLimit),
          channel: getChannelNameById(pulse.channelId),
          preserveScroll: true,
          liveEnrich: true
        });
      } catch {}
      pulse.running = false;

      const latest = appData.latestByChannel[pulse.channelId] || 0;
      if (latest > pulse.latestSeenTs) {
        pulse.latestSeenTs = latest;
        pulse.newMessageCount += 1;
      }
      if (pulse.newMessageCount >= pulse.maxNewMessages) stopLiveMessagePulse();
    }

    function startLiveMessagePulse(channelId, latestTs) {
      const pulse = appData.livePulse;
      if (!channelId) return;
      if (pulse.timer) clearInterval(pulse.timer);
      pulse.channelId = channelId;
      pulse.startedAt = Date.now();
      pulse.latestSeenTs = latestTs || 0;
      pulse.newMessageCount = 0;
      pulse.running = false;
      pulse.timer = setInterval(runLiveMessagePulse, 1000);
      runLiveMessagePulse();
    }

    let activeChannelId = "public";
    function applyChannels(channels) {
      appData.channels = (channels || []).map((c) => ({
        ...c,
        id: normalizeChannelId(c.id || c.name)
      }));
      if (appData.authUser?.isAdmin) {
        const rotmName = appData.rotmChannelName || "#rotm";
        const rotmId = normalizeChannelId(rotmName);
        const exists = appData.channels.some((c) => c.id === rotmId);
        if (!exists) {
          appData.channels.unshift({
            id: rotmId,
            name: rotmName,
            snippet: "Admin-only ROTM feed",
            time: "--"
          });
        }
      }
      if (appData.channels.length) {
        const exists = appData.channels.some((c) => c.id === activeChannelId);
        if (!exists) activeChannelId = appData.channels[0].id;
        const active = appData.channels.find((c) => c.id === activeChannelId);
        if (active) document.getElementById("activeChannel").textContent = active.name;
      } else {
        activeChannelId = "public";
        document.getElementById("activeChannel").textContent = "#public";
      }
      renderChannels();
    }
    function updateChannelParam(channelId) {
      const url = new URL(window.location.href);
      if (channelId) {
        url.searchParams.set("channel", channelId);
      } else {
        url.searchParams.delete("channel");
      }
      window.history.replaceState({}, "", url.toString());
    }

    function renderChannels() {
      const el = document.getElementById("channels");
      const tabBadges = document.querySelectorAll(".channels-unread");
      el.innerHTML = "";
      const list = appData.channels.length
        ? appData.channels
        : [{ id: "public", name: "#public", snippet: "No channels yet.", time: "--" }];
      const totalUnread = Object.values(appData.unreadByChannel || {}).reduce((sum, v) => sum + (v || 0), 0);
      tabBadges.forEach((badge) => {
        badge.textContent = totalUnread || 0;
        badge.style.display = totalUnread ? "inline-flex" : "none";
      });
      const isAdmin = !!appData.authUser?.isAdmin;
      list.forEach((ch, idx) => {
        const unread = appData.unreadByChannel[ch.id] || 0;
        const displayName = ch.name || "#unknown";
        const avatarChar = (displayName[1] || displayName[0] || "?").toUpperCase();
        const snippet = ch.snippet || "No recent messages.";
        const time = ch.time || "--";
        const row = document.createElement("div");
        row.className = "channel" + (ch.id === activeChannelId ? " active" : "") + (unread ? " unread" : "");
        row.innerHTML = `
          <div class="avatar" style="background:${colors[idx % colors.length]}">${avatarChar}</div>
          <div>
            <div class="name">${displayName}</div>
            <div class="channel-meta">
              <div class="snippet">${snippet}</div>
              <div class="channel-time">${time}</div>
            </div>
          </div>
          <div style="display:grid;gap:6px;justify-items:end;">
            ${unread ? `<div class="badge-bubble">${unread}</div>` : ""}
            ${isAdmin ? `<button class="channel-remove" type="button" data-remove="${displayName}">Remove</button>` : ""}
          </div>
        `;
        if (isAdmin) {
          const removeBtn = row.querySelector(".channel-remove");
          removeBtn.style.display = "inline-flex";
          removeBtn.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            if (!confirm(`Remove ${displayName}?`)) return;
            try {
              const res = await fetch(`/api/channels?name=${encodeURIComponent(displayName)}`, {
                method: "DELETE",
                headers: authHeaders()
              });
              if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                alert(err.error || "Failed to remove channel.");
                return;
              }
              await loadChannels();
              await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
            } catch (err) {
              alert(err?.message || err);
            }
          });
        }
        row.addEventListener("click", () => {
          activeChannelId = ch.id;
          document.getElementById("activeChannel").textContent = ch.name;
          updateChannelParam(activeChannelId);
          const latest = appData.messages
            .filter((msg) => msg.channelId === activeChannelId)
            .map((msg) => msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0)
            .reduce((a, b) => Math.max(a, b), 0);
          if (latest) appData.lastReadByChannel[activeChannelId] = latest;
          appData.unreadByChannel[activeChannelId] = 0;
          saveReadState();
          renderChannels();
          renderMessages(true);
          loadMessages(false, { limit: appData.channelHistoryLimit });
          document.body.classList.remove("menu-open-left", "menu-open-right");
        });
        el.appendChild(row);
      });
    }

    function renderMessages(full, opts = {}) {
      const preserveScroll = !!opts.preserveScroll;
      const el = document.getElementById("messages");
      const nearBottom = (el.scrollHeight - el.scrollTop - el.clientHeight) < 80;
      const filtered = appData.messages.filter((msg) => msg.channelId === activeChannelId);
      const key = activeChannelId;
      const historyState = appData.historyByChannel[key] || { loading: false, done: false };
      if (!filtered.length && !historyState.loading && !historyState.done) {
        loadMoreHistory();
      }
      let rendered = appData.renderedIdsByChannel[key] || new Set();
      if (!full && rendered.size !== filtered.length) {
        full = true;
      }
      if (full) {
        el.innerHTML = "";
        rendered = new Set();
        appData.renderedIdsByChannel[key] = rendered;
      }

      filtered.forEach((msg, idx) => {
        const keyId = msg.frameHash || msg.id;
        if (rendered.has(keyId)) {
          const existing = el.querySelector(`.message[data-id="${keyId}"]`);
          if (existing) {
            const observerEl = existing.querySelector(".msg-observers");
            if (observerEl) {
              const updatedCount = Number.isFinite(msg.observerCount)
                ? msg.observerCount
                : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
              const updatedHits = Array.isArray(msg.observerHits) ? msg.observerHits : [];
              observerEl.textContent = `Observers: ${updatedCount}`;
              observerEl.dataset.observers = updatedHits.map((v) => String(v).trim()).filter(Boolean).join("|");
              observerEl.dataset.id = keyId;
            }
            const hopsEl = existing.querySelector(".msg-hops");
            if (hopsEl) {
              hopsEl.textContent = `Total hops: ${getHopCount(msg)}`;
            }
            const confEl = existing.querySelector(".msg-confidence");
            if (confEl) {
              confEl.textContent = `MeshRank Confidence: ${conf}%`;
              confEl.dataset.id = keyId;
            }
          }
          return;
        }
        const row = document.createElement("div");
        row.className = "message";
        row.dataset.id = keyId;
        const conf = confidence(msg);
        const observerCount = Number.isFinite(msg.observerCount)
          ? msg.observerCount
          : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
        const observerList = (Array.isArray(msg.observerHits) ? msg.observerHits : [])
          .map((v) => String(v).trim())
          .filter(Boolean)
          .join("|");
        const hopCount = getHopCount(msg);
        row.innerHTML = `
          <div class="avatar" style="background:${colors[(idx + 1) % colors.length]}">${msg.sender[0]}</div>
          <div>
            <div class="meta">
              <strong>${msg.sender}</strong>
              <span>${msg.ts}</span>
              <span class="badge">${msg.type}</span>
            </div>
            <div class="bubble ${msg.type}">${msg.body}</div>
              <div class="msg-footer">
                <a class="msg-observers" href="#" data-id="${keyId}" data-observers="${observerList.replace(/"/g, "&quot;")}">Observers: ${observerCount}</a>
                <a class="msg-hops" href="#" data-id="${keyId}">Total hops: ${hopCount}</a>
                <a class="msg-confidence" href="#" data-id="${keyId}">MeshRank Confidence: ${conf}%</a>
              </div>
          </div>
        `;
        el.appendChild(row);
        rendered.add(keyId);
      });
      appData.renderedIdsByChannel[key] = rendered;
      if (!preserveScroll && nearBottom) el.scrollTop = el.scrollHeight;
    }

    function getOldestTs(channelId) {
      let oldest = null;
      appData.messages.forEach((msg) => {
        if (msg.channelId !== channelId || !msg.tsRaw) return;
        if (!oldest || new Date(msg.tsRaw) < new Date(oldest)) oldest = msg.tsRaw;
      });
      return oldest;
    }

    async function loadMoreHistory() {
      const channelId = activeChannelId;
      const state = appData.historyByChannel[channelId] || { loading: false, done: false };
      if (state.loading || state.done) return;
      const before = getOldestTs(channelId) || new Date().toISOString();

      state.loading = true;
      appData.historyByChannel[channelId] = state;
      const el = document.getElementById("messages");
      const prevHeight = el.scrollHeight;
      try {
        const added = await loadMessages(false, {
          channel: getChannelNameById(channelId),
          before,
          limit: appData.channelHistoryLimit,
          preserveScroll: true
        });
        const newHeight = el.scrollHeight;
        el.scrollTop = newHeight - prevHeight;
        if (!added) {
          state.done = true;
        }
      } finally {
        state.loading = false;
        appData.historyByChannel[channelId] = state;
      }
    }

    let map;
    let routeLayer;
    let confidenceMap;
    let confidenceLayers = [];
    let confidenceTimer = null;

    function initMap() {
      map = L.map("routeMap", { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);
      routeLayer = L.layerGroup().addTo(map);
    }

    async function showRoute(msgId) {
      const msg = appData.messages.find((m) => (m.frameHash || m.id) === msgId || m.id === msgId);
      if (!msg) return;
      appData.routeActiveId = msgId;
      appData.routeActiveMsg = msg;
      if (window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.add("route-open");
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 120);
      }

      await ensureRouteSuggestions();
      await ensureObservers();
      document.getElementById("routeKey").textContent = msg.id;
      document.getElementById("routeMessage").textContent = msg.frameHash || msg.messageHash || msg.id;
      document.getElementById("routeSource").textContent = msg.type;
      document.getElementById("routeConfidence").textContent = confidence(msg) + "%";

      const depth = Math.max(1, msg.path.length || 1);
      const maxDepth = depth;
      document.getElementById("routeDepth").textContent = maxDepth + " hops";

      routeLayer.clearLayers();
      const routeLegend = document.getElementById("routeLegend");
      if (routeLegend) routeLegend.innerHTML = "";

      const list = document.getElementById("routeList");
      list.innerHTML = "";
        const lines = msg.path && msg.path.length ? msg.path : ["no route data"];
        const names = msg.pathNames && msg.pathNames.length ? msg.pathNames : [];
        const slicedLines = lines.slice(0, maxDepth);
        const slicedNames = names.slice(0, maxDepth);
        appData.routeActivePathCodes = slicedLines.slice();
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        slicedLines.forEach((node, idx) => {
          const label = resolveRouteName(node, slicedNames[idx] ? slicedNames[idx] : node);
          const code = String(node || "").toUpperCase();
          const isRepeater = repeatersByCode && repeatersByCode.has(code);
          const item = document.createElement("div");
          item.className = "list-item";
        item.innerHTML = isRepeater
          ? `<span>${label}</span><span class="repeater-tag">Repeater</span>`
          : `<span>${label}</span>`;
        list.appendChild(item);
      });

      const observerHits = Array.isArray(msg.observerHits) ? msg.observerHits : [];
      if (observerHits.length) {
        const byId = appData.observersById || {};
        const byName = appData.observersByName || {};
        observerHits.forEach((raw) => {
          const key = String(raw || "").trim();
          if (!key) return;
          const entry = byId[key] || byName[key] || null;
          const label = entry?.name || entry?.id || key;
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `<span>${label}</span><span class="observer-tag">Observer</span>`;
          list.appendChild(item);
        });
      }

      document.getElementById("routeCount").textContent = slicedLines.length + observerHits.length;

      if (routeLayer) {
        routeLayer.clearLayers();
        const path = Array.isArray(msg.path) ? msg.path.slice(0, maxDepth) : [];
          const rawPoints = Array.isArray(msg.pathPoints) ? msg.pathPoints.slice(0, maxDepth) : [];
          appData.routeActivePathPoints = rawPoints.slice();
        const pathLen = Math.max(path.length, rawPoints.length);
        const normalized = [];

        function hasGps(p) {
          if (!p || !p.gps || !Number.isFinite(p.gps.lat) || !Number.isFinite(p.gps.lon)) return false;
          if (p.gps.lat === 0 && p.gps.lon === 0) return false;
          return true;
        }

          for (let i = 0; i < pathLen; i += 1) {
            const base = rawPoints[i] || { hash: path[i], name: msg.pathNames?.[i] || path[i] || "#unknown" };
            const resolvedName = resolveRouteName(base.hash || path[i], base.name);
            normalized.push({ ...base, name: resolvedName });
          }

          const latlngs = [];
          normalized.forEach((p) => {
            if (!hasGps(p)) return;
            const gps = p.gps;
            const latlng = [gps.lat, gps.lon];
            latlngs.push(latlng);
            const color = "#007aff";
            L.circleMarker(latlng, {
              radius: 5,
              color,
              fillColor: color,
              fillOpacity: 0.9,
              weight: 2
            }).bindPopup(p.name || "#unknown").addTo(routeLayer);
          });

        const observerPaths = Array.isArray(msg.observerPaths) ? msg.observerPaths : [];
        const branchPalette = ["#34c759", "#007aff", "#ff9500", "#ff2d55", "#5856d6", "#8e8e93"];
        const branchEntries = observerPaths.map((entry) => {
          const points = (entry.pathPoints || [])
            .filter((pt) => pt?.gps && Number.isFinite(pt.gps.lat) && Number.isFinite(pt.gps.lon) && !(pt.gps.lat === 0 && pt.gps.lon === 0))
            .map((pt) => [pt.gps.lat, pt.gps.lon]);
          return {
            label: entry.observerName || entry.observerId || "Observer",
            points
          };
        }).filter((entry) => entry.points.length >= 2);
        branchEntries.sort((a, b) => b.points.length - a.points.length);
        if (branchEntries.length && routeLegend) {
          routeLegend.innerHTML = "";
        }
        branchEntries.forEach((entry, idx) => {
          const color = branchPalette[idx % branchPalette.length];
          const line = L.polyline(entry.points, {
            color,
            weight: idx === 0 ? 3 : 2,
            opacity: 0.9
          }).addTo(routeLayer);
          entry.points.forEach((pt) => latlngs.push(pt));
          if (routeLegend) {
            const label = idx === 0 ? `${entry.label} (longest)` : entry.label;
            routeLegend.insertAdjacentHTML("beforeend",
              `<div class="route-legend-item"><span class="route-legend-swatch" style="background:${color}"></span>${label}</div>`
            );
          }
        });

        if (observerHits.length) {
          const byId = appData.observersById || {};
          const byName = appData.observersByName || {};
          observerHits.forEach((raw) => {
            const key = String(raw || "").trim();
            if (!key) return;
            const entry = byId[key] || byName[key] || null;
              const gps = entry?.gps || null;
              if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
              const latlng = [gps.lat, gps.lon];
              latlngs.push(latlng);
              const label = entry?.name || entry?.id || key;
              L.circleMarker(latlng, {
                radius: 6,
                color: "#00c853",
                fillColor: "#00c853",
                fillOpacity: 0.9,
                weight: 2
              }).bindPopup(`Observer: ${label}`).addTo(routeLayer);
            });
          }

        if (latlngs.length >= 2) {
          map.fitBounds(latlngs, { padding: [20, 20] });
        } else if (latlngs.length === 1) {
          map.setView(latlngs[0], 9);
        }
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 120);
      }
    }

    document.addEventListener("click", async (e) => {
      const hops = e.target.closest(".msg-hops");
      if (hops) {
        e.preventDefault();
        showRoute(hops.dataset.id);
        return;
      }
      const observers = e.target.closest(".msg-observers");
      if (observers) {
        e.preventDefault();
        const msgId = observers.dataset.id;
        let list = [];
        if (msgId) {
          const msg = appData.messages.find((m) =>
            m.id === msgId || m.frameHash === msgId || m.messageHash === msgId
          );
          list = Array.isArray(msg?.observerHits) ? msg.observerHits : [];
        }
        if (!list.length) {
          list = String(observers.dataset.observers || "")
            .split("|")
            .map((v) => v.trim())
            .filter(Boolean);
        }
        await openObserverHitsModal(list);
        return;
      }
      const confidence = e.target.closest(".msg-confidence");
      if (confidence) {
        e.preventDefault();
        const id = confidence.dataset.id;
        if (id) openMessageRouteOverlay(id);
      }
    });

    const routeClose = document.getElementById("routeClose");
    const routeBackdrop = document.getElementById("routeBackdrop");
    function closeRouteOverlay() {
      document.body.classList.remove("route-open");
    }
    routeClose?.addEventListener("click", closeRouteOverlay);
    routeBackdrop?.addEventListener("click", closeRouteOverlay);
    const messageList = document.getElementById("messages");
    const isMobile = () => window.matchMedia?.("(max-width: 860px)")?.matches;
    messageList?.addEventListener("scroll", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
      if (messageList.scrollTop <= 10) {
        loadMoreHistory();
      }
    });
    messageList?.addEventListener("click", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
    });
    messageList?.addEventListener("touchstart", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
    }, { passive: true });
    window.addEventListener("resize", () => {
      if (!window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
    });

    const routeOverrideBtn = document.getElementById("routeOverrideBtn");
    const routeOverrideModal = document.getElementById("routeOverrideModal");
    const routeOverrideList = document.getElementById("routeOverrideList");
    const routeOverrideStatus = document.getElementById("routeOverrideStatus");
    const routeOverrideClose = document.getElementById("routeOverrideClose");
    const routeOverrideSave = document.getElementById("routeOverrideSave");

    const observerHitsModal = document.getElementById("observerHitsModal");
    const observerHitsList = document.getElementById("observerHitsList");
    const observerHitsSummary = document.getElementById("observerHitsSummary");
    const observerHitsClose = document.getElementById("observerHitsClose");

    async function openObserverHitsModal(list) {
      if (!observerHitsModal || !observerHitsList || !observerHitsSummary) return;
      try {
        await ensureObservers(true);
      } catch {}
      const items = Array.isArray(list) ? list.filter(Boolean) : [];
      const resolved = items.map(resolveObserverLabel).filter(Boolean);
      observerHitsSummary.textContent = resolved.length
        ? `${resolved.length} observer${resolved.length === 1 ? "" : "s"}`
        : "No observers available.";
      observerHitsList.innerHTML = resolved.length
        ? resolved.map((name) => `<div class="list-item">${name}</div>`).join("")
        : "";
      observerHitsModal.classList.add("open");
    }

    function closeObserverHitsModal() {
      observerHitsModal?.classList.remove("open");
    }

    observerHitsClose?.addEventListener("click", closeObserverHitsModal);
    observerHitsModal?.addEventListener("click", (e) => {
      if (e.target === observerHitsModal) closeObserverHitsModal();
    });

    function getRouteVoterId() {
      const key = "routeVoterId";
      let id = localStorage.getItem(key);
      if (id) return id;
      id = Math.random().toString(36).slice(2, 12);
      localStorage.setItem(key, id);
      return id;
    }

    function openRouteOverrideModal() {
      if (!routeOverrideModal || !routeOverrideList) return;
      const codes = appData.routeActivePathCodes || [];
      routeOverrideList.innerHTML = "";
      if (!codes.length) {
        routeOverrideList.innerHTML = `<div class="route-override-empty">Select a packet in MeshFlow first, then try again.</div>`;
        if (routeOverrideStatus) routeOverrideStatus.textContent = "No route selected yet.";
        routeOverrideModal.classList.add("open");
        return;
      }
      const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const suggestions = appData.routeSuggestions?.byCode || {};
      const points = appData.routeActivePathPoints || [];

      codes.forEach((code, idx) => {
        const key = String(code || "").toUpperCase();
        const options = repeatersByCode.get(key) || [];
        const pointName = points[idx]?.name || appData.routeActiveMsg?.pathNames?.[idx] || key;
        const currentName = resolveRouteName(key, pointName);
        const best = suggestions[key];
        const bestText = best && best.accepted ? `${best.name || best.pub} (${best.confidence}% confidence)` : "No community match yet";

        const row = document.createElement("div");
        row.className = "route-override-row";

        const label = document.createElement("div");
        label.className = "route-override-label";
        label.innerHTML = `<strong>${key}</strong><div>Current: ${currentName}</div><div>Community: ${bestText}</div>`;

        const select = document.createElement("select");
        select.className = "route-override-select";
        select.dataset.code = key;

        const optKeep = document.createElement("option");
        optKeep.value = "keep";
        optKeep.textContent = "Keep current";
        select.appendChild(optKeep);

        const optNone = document.createElement("option");
        optNone.value = "none";
        optNone.textContent = "None of these";
        select.appendChild(optNone);

        if (options.length) {
          const divider = document.createElement("option");
          divider.disabled = true;
          divider.textContent = "-- Repeaters with this code --";
          select.appendChild(divider);
          options.forEach((opt) => {
            const o = document.createElement("option");
            o.value = opt.pub || "";
            o.textContent = opt.name || opt.pub || key;
            select.appendChild(o);
          });
        }

        row.appendChild(label);
        row.appendChild(select);
        routeOverrideList.appendChild(row);
      });

      if (routeOverrideStatus) routeOverrideStatus.textContent = "Select repeaters, then submit.";
      routeOverrideModal.classList.add("open");
    }

    if (routeOverrideBtn) {
      routeOverrideBtn.addEventListener("click", async () => {
        await ensureRouteSuggestions();
        openRouteOverrideModal();
      });
    }

    window.openRouteOverride = async () => {
      await ensureRouteSuggestions();
      openRouteOverrideModal();
    };

    if (routeOverrideClose) {
      routeOverrideClose.addEventListener("click", () => {
        if (routeOverrideModal) routeOverrideModal.classList.remove("open");
      });
    }

    if (routeOverrideSave) {
      routeOverrideSave.addEventListener("click", async () => {
        if (!routeOverrideList) return;
        const voterId = getRouteVoterId();
        const pathGps = (appData.routeActivePathPoints || []).map((p) => p?.gps).filter(Boolean);
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        const selects = routeOverrideList.querySelectorAll("select[data-code]");
        const requests = [];

        selects.forEach((select) => {
          const code = select.dataset.code;
          const choice = select.value;
          if (!code || choice === "keep") return;
          if (choice === "none") {
            overrideRouteName(code, "");
            return;
          }
          const options = repeatersByCode.get(code) || [];
          const picked = options.find((opt) => opt.pub === choice);
          if (!picked) return;
          overrideRouteName(code, picked.name || code);
          requests.push(fetch("/api/route-suggest", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              code,
              repeaterPub: picked.pub,
              repeaterName: picked.name || "",
              voterId,
              pathGps
            })
          }));
        });

        if (!requests.length) {
          if (routeOverrideStatus) routeOverrideStatus.textContent = "No changes selected.";
          return;
        }

        if (routeOverrideStatus) routeOverrideStatus.textContent = "Submitting suggestions...";
        await Promise.allSettled(requests);
        try {
          appData.routeSuggestions = await fetchRouteSuggestions();
        } catch {}
        if (routeOverrideStatus) routeOverrideStatus.textContent = "Suggestions saved. Community scores update over time.";
        if (appData.routeActiveId) showRoute(appData.routeActiveId);
        renderRfList();
        renderRfDetail();
      });
    }

    const observerLocationModal = document.getElementById("observerLocationModal");
    const observerLocationClose = document.getElementById("observerLocationClose");
    const observerLocationSave = document.getElementById("observerLocationSave");
    const observerListEl = document.getElementById("observerList");
    const repeaterLocationModal = document.getElementById("repeaterLocationModal");
    const repeaterLocationClose = document.getElementById("repeaterLocationClose");
    const repeaterLocationSave = document.getElementById("repeaterLocationSave");
    const neighborMapModal = document.getElementById("neighborMapModal");
    const neighborMapClose = document.getElementById("neighborMapClose");

    observerLocationClose?.addEventListener("click", closeObserverLocationModal);
    observerLocationModal?.addEventListener("click", (e) => {
      if (e.target === observerLocationModal) closeObserverLocationModal();
    });
    repeaterLocationClose?.addEventListener("click", closeRepeaterLocationModal);
    repeaterLocationModal?.addEventListener("click", (e) => {
      if (e.target === repeaterLocationModal) closeRepeaterLocationModal();
    });
    neighborMapClose?.addEventListener("click", closeNeighborMapModal);
    neighborMapModal?.addEventListener("click", (e) => {
      if (e.target === neighborMapModal) closeNeighborMapModal();
    });

    observerListEl?.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-observer-locate]");
      if (!btn) return;
      const id = btn.getAttribute("data-observer-locate");
      const entry = appData.observersById?.[id];
      if (!entry) return;
      openObserverLocationModal(entry);
    });

    observerLocationSave?.addEventListener("click", async () => {
      if (!observerLocationTarget || !observerLocationCoords) {
        alert("Click a location on the map first.");
        return;
      }
      try {
        const res = await fetch("/api/observer-location", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            id: observerLocationTarget.id,
            lat: observerLocationCoords.lat,
            lon: observerLocationCoords.lng
          })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await fetchObservers();
        updateObserversData(data);
        renderObserverMap(data);
        renderObserverList(data);
        closeObserverLocationModal();
      } catch (err) {
        alert("Unable to save location: " + (err?.message || err));
      }
    });

    repeaterLocationSave?.addEventListener("click", async () => {
      if (!repeaterLocationTarget || !repeaterLocationCoords) {
        alert("Click a location on the map first.");
        return;
      }
      try {
        const res = await fetch("/api/repeater-location", {
          method: "POST",
          headers: { "content-type": "application/json", ...authHeaders() },
          body: JSON.stringify({
            pub: repeaterLocationTarget.pub,
            lat: repeaterLocationCoords.lat,
            lon: repeaterLocationCoords.lng
          })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        await loadRankDefault();
        fetchRankSummary().then(renderRankSummary).catch(() => {});
        closeRepeaterLocationModal();
      } catch (err) {
        alert("Unable to save location: " + (err?.message || err));
      }
    });

    const modal = document.getElementById("channelModal");
    const addBtn = document.getElementById("addChannelBtn");
    const cancelBtn = document.getElementById("cancelChannel");
    const saveBtn = document.getElementById("saveChannel");

    function openModal() {
      document.getElementById("channelName").value = "";
      document.getElementById("channelSecret").value = "";
      modal.classList.add("open");
    }

    function closeModal() {
      modal.classList.remove("open");
    }

    addBtn.addEventListener("click", openModal);
    cancelBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e) => {
      if (e.target === modal) closeModal();
    });

    saveBtn.addEventListener("click", async () => {
      const name = document.getElementById("channelName").value.trim();
      const secret = document.getElementById("channelSecret").value.trim();
      if (!name.startsWith("#")) {
        alert("Channel name must start with #");
        return;
      }
      if (!/^[0-9a-fA-F]{32}$/.test(secret)) {
        alert("Secret must be 32 hex characters");
        return;
      }
      try {
        const res = await fetch("/api/channels", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, secretHex: secret })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        await loadChannels();
        closeModal();
      } catch (err) {
        alert("Failed to add channel: " + (err?.message || err));
      }
    });

    const rotmInfoModal = document.getElementById("rotmInfoModal");
    const rotmInfoBtn = document.getElementById("rotmInfoBtn");
    const rotmInfoClose = document.getElementById("rotmInfoClose");
    rotmInfoBtn?.addEventListener("click", () => rotmInfoModal?.classList.add("open"));
    rotmInfoClose?.addEventListener("click", () => rotmInfoModal?.classList.remove("open"));
    rotmInfoModal?.addEventListener("click", (e) => {
      if (e.target === rotmInfoModal) rotmInfoModal.classList.remove("open");
    });

    const rotmSettingsModal = document.getElementById("rotmSettingsModal");
    const rotmSettingsBtn = document.getElementById("rotmSettingsBtn");
    const rotmSettingsClose = document.getElementById("rotmSettingsClose");
    rotmSettingsBtn?.addEventListener("click", async () => {
      rotmSettingsModal?.classList.add("open");
      appData.rotmConfigLoaded = false;
      await loadRotm();
    });
    rotmSettingsClose?.addEventListener("click", () => rotmSettingsModal?.classList.remove("open"));
    rotmSettingsModal?.addEventListener("click", (e) => {
      if (e.target === rotmSettingsModal) rotmSettingsModal.classList.remove("open");
    });

    async function loadChannels() {
      const res = await fetch("/api/channels", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      applyChannels(data.channels || []);
    }

    function mergeMessages(raw) {
      const byKey = new Map();
      raw.forEach((m) => {
        const stableId = m.hash || m.fp || m.id;
        const ts = m.ts ? new Date(m.ts).getTime() : 0;
        const bucket = ts ? Math.round(ts / 10000) * 10000 : 0;
        const body = (m.body || "").trim();
        const key = stableId
          ? String(stableId).toLowerCase()
          : `${m.channelName || ""}|${m.sender || ""}|${body}|${bucket}`;
        let entry = byKey.get(key);
        if (!entry) {
          entry = {
            ...m,
            id: m.id || stableId || key,
            _observerSet: new Set(),
            _pathSet: new Set()
          };
          byKey.set(key, entry);
        }
        const observerHits = Array.isArray(m.observerHits) ? m.observerHits : [];
        observerHits.forEach((o) => entry._observerSet.add(o));
        const singleObserver = m.observerName || m.observerId || m.observer || null;
        if (singleObserver) entry._observerSet.add(singleObserver);
        const path = Array.isArray(m.path) ? m.path : [];
        path.forEach((code) => {
          if (code !== undefined && code !== null && String(code).length) {
            entry._pathSet.add(String(code));
          }
        });
        if (!entry.path?.length && path.length) entry.path = path;
        if (!entry.pathNames?.length && Array.isArray(m.pathNames) && m.pathNames.length) entry.pathNames = m.pathNames;
        if (!entry.pathPoints?.length && Array.isArray(m.pathPoints) && m.pathPoints.length) entry.pathPoints = m.pathPoints;
        entry.repeats = Math.max(entry.repeats || 0, m.repeats || 0);
        if (Number.isFinite(m.pathLength)) {
          entry.pathLength = Math.max(entry.pathLength || 0, m.pathLength || 0);
        }
      });
      return Array.from(byKey.values()).map((entry) => {
        const observerHits = Array.from(entry._observerSet || []);
        const uniqueHopCount = entry._pathSet && entry._pathSet.size ? entry._pathSet.size : 1;
        const { _observerSet, _pathSet, ...clean } = entry;
        return {
          ...clean,
          observerHits,
          observerCount: observerHits.length || entry.observerCount || 0,
          uniqueHopCount
        };
      });
    }

    function mergeMappedMessages(existing, incoming) {
      const byId = new Map();
      existing.forEach((msg) => {
        byId.set(msg.id, { ...msg });
      });
      incoming.forEach((next) => {
        const current = byId.get(next.id);
        if (!current) {
          byId.set(next.id, { ...next });
          return;
        }
        const mergedHits = new Set([...(current.observerHits || []), ...(next.observerHits || [])]);
        const nextTs = next.tsRaw ? new Date(next.tsRaw).getTime() : 0;
        const curTs = current.tsRaw ? new Date(current.tsRaw).getTime() : 0;
        byId.set(next.id, {
          ...current,
          frameHash: current.frameHash || next.frameHash,
          messageHash: current.messageHash || next.messageHash,
          tsRaw: nextTs > curTs ? next.tsRaw : current.tsRaw,
          ts: nextTs > curTs ? next.ts : current.ts,
          repeats: Math.max(current.repeats || 0, next.repeats || 0),
          pathLength: Number.isFinite(next.pathLength)
            ? Math.max(current.pathLength || 0, next.pathLength || 0)
            : current.pathLength,
          path: (next.path?.length || 0) > (current.path?.length || 0) ? next.path : current.path,
          pathNames: (next.pathNames?.length || 0) > (current.pathNames?.length || 0) ? next.pathNames : current.pathNames,
          pathPoints: (next.pathPoints?.length || 0) > (current.pathPoints?.length || 0) ? next.pathPoints : current.pathPoints,
          observerHits: Array.from(mergedHits),
          observerCount: mergedHits.size
        });
      });
      return Array.from(byId.values()).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
    }

    async function fetchMessages(params = {}) {
      const url = new URL("/api/messages", window.location.origin);
      if (params.channel) url.searchParams.set("channel", params.channel);
      if (params.limit) url.searchParams.set("limit", String(params.limit));
      if (params.before) url.searchParams.set("before", params.before);
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function loadMessages(forceFull, opts = {}) {
      const previousLatest = appData.latestByChannel || {};
      const data = await fetchMessages(opts);
      const raw = mergeMessages(data.messages || []);
      const mapped = raw.map((m) => ({
        id: m.id,
        frameHash: m.frameHash || null,
        messageHash: m.messageHash || null,
        channelId: normalizeChannelId(m.channelName || "#unknown"),
        sender: m.sender,
        body: m.body,
        tsRaw: m.ts || null,
        ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
        type: "mesh",
        repeats: m.repeats || 1,
        pathLength: Number.isFinite(m.pathLength) ? m.pathLength : null,
        uniqueHopCount: Number.isFinite(m.uniqueHopCount) ? m.uniqueHopCount : null,
        path: Array.isArray(m.path) ? m.path : [],
        pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
        pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : [],
        observerHits: Array.isArray(m.observerHits) ? m.observerHits : [],
        observerCount: Number.isFinite(m.observerCount) ? m.observerCount : null
      })).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
      appData.messages = opts.replace
        ? mapped
        : mergeMappedMessages(appData.messages || [], mapped);
      const unread = {};
      const latestByChannel = {};
      appData.messages.forEach((msg) => {
        if (!msg.channelId) return;
        const t = msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0;
        if (!latestByChannel[msg.channelId] || t > latestByChannel[msg.channelId]) {
          latestByChannel[msg.channelId] = t;
        }
        const lastRead = appData.lastReadByChannel[msg.channelId] || 0;
        if (t > lastRead) {
          unread[msg.channelId] = (unread[msg.channelId] || 0) + 1;
        }
      });
      const activeLatest = latestByChannel[activeChannelId] || 0;
      if (activeLatest) {
        appData.lastReadByChannel[activeChannelId] = activeLatest;
        unread[activeChannelId] = 0;
        saveReadState();
      }
      appData.latestByChannel = latestByChannel;
      appData.unreadByChannel = unread;
      if (Array.isArray(data.channels)) {
        applyChannels(data.channels);
      } else {
        renderChannels();
      }
      renderMessages(!!forceFull, { preserveScroll: !!opts.preserveScroll });
      if (forceFull && appData.messages.length && !isMobile()) {
        showRoute(appData.messages[0].id);
      }
      if (document.body.classList.contains("view-channels")) {
        const prev = previousLatest[activeChannelId] || 0;
        const next = latestByChannel[activeChannelId] || 0;
        if (next && next > prev) {
          scheduleRecentStatsRefresh(activeChannelId);
        }
      }
      return mapped.length;
    }

    async function refreshRecentStats(channelId) {
      if (!channelId) return;
      try {
        const data = await fetchMessages({ channel: getChannelNameById(channelId), limit: 3 });
        const raw = mergeMessages(data.messages || []);
        const mapped = raw.map((m) => ({
          id: m.id,
          frameHash: m.frameHash || null,
          messageHash: m.messageHash || null,
          channelId: normalizeChannelId(m.channelName || "#unknown"),
          sender: m.sender,
          body: m.body,
          tsRaw: m.ts || null,
          ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
          type: "mesh",
          repeats: m.repeats || 1,
          pathLength: Number.isFinite(m.pathLength) ? m.pathLength : null,
          uniqueHopCount: Number.isFinite(m.uniqueHopCount) ? m.uniqueHopCount : null,
          path: Array.isArray(m.path) ? m.path : [],
          pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
          pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : [],
          observerHits: Array.isArray(m.observerHits) ? m.observerHits : [],
          observerCount: Number.isFinite(m.observerCount) ? m.observerCount : null
        })).sort((a, b) => {
          const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
          const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
          return ta - tb;
        });
        appData.messages = mergeMappedMessages(appData.messages || [], mapped);
        renderMessages(false, { preserveScroll: true });
      } catch {}
    }

    function scheduleRecentStatsRefresh(channelId) {
      const now = Date.now();
      const last = appData.recentStatsByChannel[channelId] || 0;
      if (now - last < 1000) return;
      appData.recentStatsByChannel[channelId] = now;
      setTimeout(() => refreshRecentStats(channelId), 1000);
      setTimeout(() => refreshRecentStats(channelId), 3000);
    }

    function applyMessageObserverUpdates(payload) {
      if (!payload?.updates?.length || !Array.isArray(appData.messages)) return;
      let changed = false;
      payload.updates.forEach((update) => {
        const key = String(update.messageHash || "").toUpperCase();
        if (!key) return;
        const nextHits = Array.isArray(update.observerHits) ? update.observerHits : [];
        appData.messages.forEach((msg) => {
          const msgKey = String(msg.messageHash || msg.frameHash || "").toUpperCase();
          if (msgKey !== key) return;
          const merged = new Set([...(msg.observerHits || []), ...nextHits]);
          if (merged.size !== (msg.observerHits || []).length) {
            msg.observerHits = Array.from(merged);
            msg.observerCount = merged.size;
            changed = true;
          }
          if (Number.isFinite(update.pathLength) && (msg.pathLength || 0) < update.pathLength) {
            msg.pathLength = update.pathLength;
            changed = true;
          }
        });
      });
      if (changed) renderMessages(false, { preserveScroll: true });
    }

    function initMessageStream() {
      if (!window.EventSource) return;
      if (appData.messageStream?.es) return;
      const es = new EventSource("/api/message-stream");
      appData.messageStream.es = es;
      es.addEventListener("updates", (event) => {
        if (!document.body.classList.contains("view-channels")) return;
        try {
          const data = JSON.parse(event.data);
          applyMessageObserverUpdates(data);
        } catch {}
      });
    }

    async function checkServerStatus() {
      try {
        const res = await fetch("/api/channels?ts=" + Date.now(), { cache: "no-store" });
        setServerStatus(res.ok);
        return res.ok;
      } catch {
        setServerStatus(false);
        return false;
      }
    }

    function loadReadState() {
      try {
        const raw = localStorage.getItem("meshmonitor.lastReadByChannel");
        const parsed = raw ? JSON.parse(raw) : {};
        if (parsed && typeof parsed === "object") appData.lastReadByChannel = parsed;
      } catch {}
    }

    function saveReadState() {
      localStorage.setItem("meshmonitor.lastReadByChannel", JSON.stringify(appData.lastReadByChannel));
    }

    function initChannelHistoryControl() {
      const select = document.getElementById("channelHistoryLimit");
      if (!select) return;
      select.innerHTML = "";
      for (let i = 1; i <= 50; i += 1) {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = String(i);
        select.appendChild(opt);
      }
      select.value = String(appData.channelHistoryLimit);
      select.addEventListener("change", async () => {
        const next = Number(select.value);
        if (!Number.isFinite(next) || next < 1 || next > 50) return;
        appData.channelHistoryLimit = next;
        saveChannelHistoryLimit(next);
        try {
          await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
        } catch {}
      });
    }

    async function boot() {
      const url = new URL(window.location.href);
      const channelParam = url.searchParams.get("channel");
      if (channelParam) {
        activeChannelId = normalizeChannelId(channelParam);
      }
      appData.authToken = loadAuthToken();
      try {
        const user = await fetchAuthMe();
        setAuthUser(user);
      } catch {}
      try {
        const res = await fetch("/api/admin/status", { cache: "no-store" });
        const data = await res.json();
        setBootstrapVisibility(!!data.hasAdmin);
      } catch {}
      updateNodeRankVisibility();
      await checkServerStatus();
      if (window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
      try {
        await loadChannels();
        await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
        initMessageStream();
        try {
          const mesh = await fetchMeshScore();
          renderMeshScore(mesh, meshRangeDays);
        } catch {}
        setServerStatus(true);
      } catch (err) {
        const msg = document.createElement("div");
        msg.className = "rank-item";
        msg.textContent = "No messages yet.";
        document.getElementById("messages").appendChild(msg);
        setServerStatus(false);
      }
      initMap();
      initObserverMap();
      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        await refreshRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        const activeNodeRank = document.body.classList.contains("view-node-rank");
        if (!activeNodeRank) return;
        await refreshNodeRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        await refreshObserverRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        const ok = await checkServerStatus();
        if (!ok) return;
        try {
          await loadMessages(false, { limit: appData.channelHistoryLimit });
        } catch {}
      }, 2000);

      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        try {
          await refreshRankSummary();
          await loadRankDefault();
          setTimeout(async () => {
            try {
              const mesh = await fetchMeshScore();
              renderMeshScore(mesh, meshRangeDays);
            } catch {}
          }, 0);
        } catch {}
      }, 15 * 60 * 1000);

      setInterval(async () => {
        const activeNodeRank = document.body.classList.contains("view-node-rank");
        if (!activeNodeRank) return;
        try {
          await refreshNodeRankSummary();
          const data = await fetchNodeRank();
          renderNodeRank(data);
        } catch {}
      }, 5 * 60 * 1000);

      setInterval(async () => {
        const activeRf = document.body.classList.contains("view-rf");
        if (!activeRf) return;
        try {
          const payload = await fetchRfLatest();
          const items = payload.items || [];
          const last = items[items.length - 1];
          const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
          if (sig !== appData.rfLastSig) {
            appData.rfLastSig = sig;
            appData.rfPackets = items;
            document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
            renderRfList();
          }
          if (!appData.rfSelected && appData.rfPackets.length) {
            appData.rfSelected = appData.rfPackets[appData.rfPackets.length - 1];
            renderRfDetail();
          }
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserver = document.body.classList.contains("view-observer");
        if (!activeObserver) return;
        try {
          const data = await fetchObservers();
          updateObserversData(data);
          renderObserverMap(data);
          renderObserverList(data);
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        try {
          setObserverRankLoading(true);
          await refreshObserverRankSummary();
          const data = await fetchObserverRank();
          appData.observerRank = data;
          renderObserverRank(data);
          renderObserverRankMap(data);
        } catch {}
        finally {
          setObserverRankLoading(false);
        }
      }, 15 * 60 * 1000);
    }

    boot();

    let rankMap;
    let rankLayer;
    let rankMarkers = new Map();
    let meshRangeDays = 7;
    let nodeRankMap;
    let nodeRankLayer;
    let nodeRankMarkers = new Map();
    let observerMap;
    let observerLayer;
    let observerRankMap;
    let observerRankLayer;
    let observerRankRadiusLayer;

    function initRankMap() {
      rankMap = L.map("rankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rankMap);
      rankLayer = L.layerGroup().addTo(rankMap);
    }

    function initNodeRankMap() {
      nodeRankMap = L.map("nodeRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(nodeRankMap);
      nodeRankLayer = L.layerGroup().addTo(nodeRankMap);
    }

    function initObserverMap() {
      const el = document.getElementById("observerMap");
      if (!el) return;
      observerMap = L.map("observerMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerMap);
      observerLayer = L.layerGroup().addTo(observerMap);
    }

    function initObserverRankMap() {
      const el = document.getElementById("observerRankMap");
      if (!el) return;
      observerRankMap = L.map("observerRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerRankMap);
      observerRankLayer = L.layerGroup().addTo(observerRankMap);
      observerRankRadiusLayer = L.layerGroup().addTo(observerRankMap);
    }

    async function fetchObservers() {
      const res = await fetch("/api/observers?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRank() {
      const res = await fetch(`/api/observer-rank?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRankSummary() {
      const res = await fetch(`/api/observer-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshObserverRankSummary() {
      try {
        const summary = await fetchObserverRankSummary();
        appData.observerRankSummary = summary;
        renderObserverRankSummary(summary);
      } catch {}
    }

    function updateObserversData(data) {
      const byId = data?.byId || {};
      appData.observersById = byId;
      appData.observersByIdUpper = {};
      appData.observersByName = {};
      appData.observersByNameLower = {};
      Object.entries(byId).forEach(([rawKey, entry]) => {
        if (!entry) return;
        const idKey = String(entry.id || rawKey || "").trim();
        if (idKey) appData.observersByIdUpper[idKey.toUpperCase()] = entry;
        const name = String(entry.name || "").trim();
        if (name) {
          appData.observersByName[name] = entry;
          appData.observersByNameLower[name.toLowerCase()] = entry;
        }
      });
      appData.observersUpdatedAt = Date.now();
    }

    async function ensureObservers(force) {
      if (!force && Date.now() - appData.observersUpdatedAt < 60000) return;
      const data = await fetchObservers();
      updateObserversData(data);
    }

    function observerColor(ageHours) {
      if (ageHours <= 1) return "#34c759";
      if (ageHours <= 24) return "#ff9500";
      if (ageHours <= 48) return "#ff3b30";
      return null;
    }

    function renderObserverMap(data) {
      if (!observerLayer || !data) return;
      observerLayer.clearLayers();
      const entries = Object.values(data.byId || {});
      const now = Date.now();
      const points = [];
        entries.forEach((entry) => {
          const gps = entry.gps || null;
          if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
          if (gps.lat === 0 && gps.lon === 0) return;
          const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
          const ageHours = ts ? (now - ts) / 3600000 : 999;
          const color = observerColor(ageHours);
          if (!color) return;
          const circle = L.circle([gps.lat, gps.lon], {
            radius: 5000,
            color,
            fillColor: color,
            fillOpacity: 0.35,
            weight: 2
          });
          const name = entry.name || entry.id || "Observer";
          circle.bindTooltip(name, { direction: "top", opacity: 0.9 });
          circle.addTo(observerLayer);
          points.push([gps.lat, gps.lon]);
        });
      if (points.length) {
        observerMap.fitBounds(points, { padding: [20, 20], maxZoom: 6 });
      } else {
        observerMap.setView([54.0, -2.5], 6);
      }
      if (observerMap) {
        observerMap.invalidateSize();
      }
    }

    function renderObserverList(data) {
      const list = document.getElementById("observerList");
      if (!list || !data) return;
        const entries = Object.values(data.byId || {}).filter((entry) => {
          const gps = entry?.gps;
          if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return true;
          return gps.lat === 0 && gps.lon === 0;
        });
      if (!entries.length) {
        list.innerHTML = "<div class='rf-row'>No pending observers.</div>";
        return;
      }
      const now = Date.now();
      entries.sort((a, b) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
      list.innerHTML = entries.map((entry) => {
        const name = entry.name || entry.id || "Observer";
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        let status = "Active";
        if (ageHours > 24) status = "Idle 24h+";
        else if (ageHours > 1) status = "Idle 1h+";
          const location = "Location pending";
        const source = entry.locSource ? ` | ${entry.locSource}` : "";
        return `<div class="rf-row">
          <div class="rf-head">${name}</div>
          <div class="rf-meta">${status} | ${location}${source}</div>
          <div><button class="observer-location-button" type="button" data-observer-locate="${entry.id}">Set location</button></div>
        </div>`;
      }).join("");
    }

    function renderObserverRank(data) {
      const list = document.getElementById("observerRankList");
      if (!list || !data?.items) return;
      const query = (document.getElementById("observerRankSearch")?.value || "").trim().toLowerCase();
      const items = data.items.filter((o) => !query || String(o.name || o.id).toLowerCase().includes(query));
      list.innerHTML = items.length
        ? items.map((o) => {
              const scoreBadge = String(Math.round(o.score || 0)).padStart(2, "0");
              return `
                <div class="rank-item${o.stale ? " hidden" : ""}">
                  <div class="score">
                    <span class="rank-dot" style="background:${o.scoreColor}">${scoreBadge}</span>
                    <div class="rank-main">
                      <strong>${o.name || o.id}</strong>
                      <div class="rank-meta">Uptime: ${o.uptimeHours.toFixed(1)}h | Packets today: ${o.packetsToday}${o.offline && Number.isFinite(o.lastSeenAgoMinutes) ? ` | Last heard ${formatRelativeMinutes(o.lastSeenAgoMinutes)}` : ""}</div>
                      <div class="rank-meta">Coverage: ${o.coverageKm.toFixed(1)}km | Repeaters: ${o.coverageCount}</div>
                      <div class="rank-meta">Nearest repeater: ${o.nearestRepeaterName || "--"}${Number.isFinite(o.nearestRepeaterKm) ? ` (${o.nearestRepeaterKm}km)` : ""}</div>
                      ${o.lowPacketRate ? "<div class=\"rank-meta\" style=\"color:#f2c88b;\">Low packet rate  try moving observer closer to repeater.</div>" : ""}
                      ${badgeHtml(buildObserverBadges(o))}
                    </div>
                  </div>
                </div>
              `;
            }).join("")
          : "<div class='rank-item'>No observers yet.</div>";


      document.getElementById("observerRankUpdated").textContent = data.updatedAt
        ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = data.items.length;
      document.getElementById("observerRankActive").textContent = data.items.filter((o) => o.ageHours < 24).length;
      document.getElementById("observerRankPackets").textContent = data.items.reduce((sum, o) => sum + o.packetsToday, 0);
    }

    function renderObserverRankSummary(summary) {
      if (!summary) return;
      document.getElementById("observerRankUpdated").textContent = summary.updatedAt
        ? new Date(summary.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = summary.count ?? 0;
      document.getElementById("observerRankActive").textContent = summary.totals?.active ?? 0;
      document.getElementById("observerRankPackets").textContent = summary.totals?.packetsToday ?? 0;
    }

    function renderObserverRankMap(data) {
      if (isMobile()) return;
      if (!observerRankMap || !observerRankLayer || !observerRankRadiusLayer || !data?.items) return;
      observerRankLayer.clearLayers();
      observerRankRadiusLayer.clearLayers();
      const points = [];
      data.items.forEach((o) => {
        if (!o.gps) return;
        const latlng = [o.gps.lat, o.gps.lon];
        points.push(latlng);
        const marker = L.circleMarker(latlng, {
          radius: 7,
          weight: 2,
          color: o.scoreColor,
          fillColor: o.scoreColor,
          fillOpacity: 0.9
        }).bindPopup(`${o.name || o.id} | ${o.packetsToday} pkts today`);
        marker.addTo(observerRankLayer);
        if (o.coverageKm > 0) {
          const circle = L.circle(latlng, {
            radius: o.coverageKm * 1000,
            color: o.scoreColor,
            weight: 1,
            fillColor: o.scoreColor,
            fillOpacity: 0.08,
            interactive: false
          });
          circle.addTo(observerRankRadiusLayer);
        }
      });
      if (observerRankMap) observerRankMap.setView([54.0, -2.5], 6);
    }

    let observerLocationMap;
    let observerLocationMarker;
    let observerLocationTarget = null;
    let observerLocationCoords = null;
    let repeaterLocationMap;
    let repeaterLocationMarker;
    let repeaterLocationTarget = null;
    let repeaterLocationCoords = null;
    let neighborMap;
    let neighborMapLayer;

    function openObserverLocationModal(entry) {
      const modal = document.getElementById("observerLocationModal");
      const label = document.getElementById("observerLocationLabel");
      const coords = document.getElementById("observerLocationCoords");
      if (!modal) return;
      observerLocationTarget = entry;
      observerLocationCoords = null;
      label.textContent = `Observer: ${entry?.name || entry?.id || "--"}`;
      coords.textContent = "Lat/Lon: --";
      modal.classList.add("open");

      if (!observerLocationMap) {
        observerLocationMap = L.map("observerLocationMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(observerLocationMap);
        observerLocationMap.on("click", (ev) => {
          observerLocationCoords = ev.latlng;
          coords.textContent = `Lat/Lon: ${ev.latlng.lat.toFixed(5)}, ${ev.latlng.lng.toFixed(5)}`;
          if (observerLocationMarker) observerLocationMarker.remove();
          observerLocationMarker = L.circleMarker(ev.latlng, {
            radius: 6,
            color: "#007aff",
            fillColor: "#007aff",
            fillOpacity: 0.9,
            weight: 2
          }).addTo(observerLocationMap);
        });
      }

      const gps = entry?.gps || null;
      if (gps && Number.isFinite(gps.lat) && Number.isFinite(gps.lon)) {
        observerLocationMap.setView([gps.lat, gps.lon], 10);
        observerLocationCoords = { lat: gps.lat, lng: gps.lon };
        coords.textContent = `Lat/Lon: ${gps.lat.toFixed(5)}, ${gps.lon.toFixed(5)}`;
        if (observerLocationMarker) observerLocationMarker.remove();
        observerLocationMarker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).addTo(observerLocationMap);
      } else {
        observerLocationMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => observerLocationMap.invalidateSize(), 80);
    }

    function closeObserverLocationModal() {
      const modal = document.getElementById("observerLocationModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    function openRepeaterLocationModal(entry) {
      const modal = document.getElementById("repeaterLocationModal");
      const label = document.getElementById("repeaterLocationLabel");
      const coords = document.getElementById("repeaterLocationCoords");
      if (!modal) return;
      repeaterLocationTarget = entry;
      repeaterLocationCoords = null;
      label.textContent = `Repeater: ${entry?.name || entry?.pub || "--"}`;
      coords.textContent = "Lat/Lon: --";
      modal.classList.add("open");

      if (!repeaterLocationMap) {
        repeaterLocationMap = L.map("repeaterLocationMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(repeaterLocationMap);
        repeaterLocationMap.on("click", (ev) => {
          repeaterLocationCoords = ev.latlng;
          coords.textContent = `Lat/Lon: ${ev.latlng.lat.toFixed(5)}, ${ev.latlng.lng.toFixed(5)}`;
          if (repeaterLocationMarker) repeaterLocationMarker.remove();
          repeaterLocationMarker = L.circleMarker(ev.latlng, {
            radius: 6,
            color: "#007aff",
            fillColor: "#007aff",
            fillOpacity: 0.9,
            weight: 2
          }).addTo(repeaterLocationMap);
        });
      }

      const gps = entry?.gps || null;
      if (gps && Number.isFinite(gps.lat) && Number.isFinite(gps.lon)) {
        repeaterLocationMap.setView([gps.lat, gps.lon], 10);
        repeaterLocationCoords = { lat: gps.lat, lng: gps.lon };
        coords.textContent = `Lat/Lon: ${gps.lat.toFixed(5)}, ${gps.lon.toFixed(5)}`;
        if (repeaterLocationMarker) repeaterLocationMarker.remove();
        repeaterLocationMarker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).addTo(repeaterLocationMap);
      } else {
        repeaterLocationMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => repeaterLocationMap.invalidateSize(), 80);
    }

    function closeRepeaterLocationModal() {
      const modal = document.getElementById("repeaterLocationModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    function rssiTone(rssi) {
      if (!Number.isFinite(rssi)) return { color: "#ffcc00", label: "RSSI n/a" };
      if (rssi >= -75) return { color: "#34c759", label: `${rssi} dBm` };
      if (rssi >= -95) return { color: "#ffcc00", label: `${rssi} dBm` };
      return { color: "#ff3b30", label: `${rssi} dBm` };
    }

    function openNeighborMapModal(entry) {
      const modal = document.getElementById("neighborMapModal");
      const title = document.getElementById("neighborMapTitle");
      const meta = document.getElementById("neighborMapMeta");
      if (!modal) return;
      const repeaterName = entry?.name || entry?.pub || "Repeater";
      if (title) title.textContent = `Zero-hop neighbours: ${repeaterName}`;
      if (meta) meta.textContent = "Lines show likely zero-hop neighbours matched using AI-inspired geo intelligence that blends route codes with nearby repeater clusters.";
      modal.classList.add("open");

      if (!neighborMap) {
        neighborMap = L.map("neighborMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(neighborMap);
        neighborMapLayer = L.layerGroup().addTo(neighborMap);
      }
      if (neighborMapLayer) neighborMapLayer.clearLayers();

      const repeaterGps = entry?.gps;
      const neighbors = Array.isArray(entry?.zeroHopNeighborDetails) ? entry.zeroHopNeighborDetails : [];
      const byHash = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const points = [];

      if (repeaterGps && Number.isFinite(repeaterGps.lat) && Number.isFinite(repeaterGps.lon)) {
        const root = L.circleMarker([repeaterGps.lat, repeaterGps.lon], {
          radius: 7,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).bindPopup(repeaterName).addTo(neighborMapLayer);
        points.push([repeaterGps.lat, repeaterGps.lon]);
      }

      neighbors.forEach((n) => {
        const candidates = byHash.get(String(n.hash || "").toUpperCase()) || [];
        const target = candidates.find((c) => c?.gps && Number.isFinite(c.gps.lat) && Number.isFinite(c.gps.lon)) || null;
        const gps = n.gps || target?.gps || null;
        if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
        const tone = rssiTone(n.rssiAvg);
        const label = n.name || n.hash || "Neighbor";
        const marker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: tone.color,
          fillColor: tone.color,
          fillOpacity: 0.85,
          weight: 2
        }).bindPopup(`${label} | ${tone.label}`).addTo(neighborMapLayer);
        if (repeaterGps && Number.isFinite(repeaterGps.lat) && Number.isFinite(repeaterGps.lon)) {
          const line = L.polyline([[repeaterGps.lat, repeaterGps.lon], [gps.lat, gps.lon]], {
            color: tone.color,
            weight: 2,
            opacity: 0.8
          }).addTo(neighborMapLayer);
          line.bindTooltip(`${label} (${tone.label})`, { sticky: true });
        }
        points.push([gps.lat, gps.lon]);
      });

      if (points.length) {
        neighborMap.fitBounds(points, { padding: [20, 20] });
      } else {
        neighborMap.setView([52.2, -1.5], 6);
      }
      setTimeout(() => neighborMap.invalidateSize(), 80);
    }

    function closeNeighborMapModal() {
      const modal = document.getElementById("neighborMapModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    let rotmMap;
    let rotmMapLayer;
    let rotmRefreshTimer = null;
    let rotmTimerTick = null;
    const ROTM_QSO_WINDOW_MS = 5 * 60 * 1000;

    function formatRotmTime(ts) {
      if (!ts) return "--";
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return "--";
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    async function fetchRotmData() {
      const res = await fetch(`/api/rotm?_ts=${Date.now()}`, { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    async function fetchRotmConfig() {
      const res = await fetch("/api/rotm-config", { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    function initRotmMap() {
      if (rotmMap) return;
      rotmMap = L.map("rotmMap", { zoomControl: true });
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rotmMap);
      rotmMapLayer = L.layerGroup().addTo(rotmMap);
      rotmMap.setView([54.0, -2.5], 6);
    }

    function renderRotmFeed(feed) {
      const el = document.getElementById("rotmFeed");
      if (!el) return;
      if (!Array.isArray(feed) || feed.length === 0) {
        el.innerHTML = "<div class='rotm-feed-row'>No #rotm activity yet.</div>";
        return;
      }
      el.innerHTML = feed.map((item) => {
        const badgeClass = item.tone ? `rotm-badge ${item.tone}` : "rotm-badge";
        const via = item.viaRepeater ? `via ${item.viaRepeater}` : "via --";
        const channelLabel = item.channel || "#rotm";
        const isCq = item.tone === "cq" && !item.confirmed;
        const timer = isCq ? `<span class="rotm-cq-timer" data-ts="${item.ts || ""}">--</span>` : "";
        const responder = item.responseSender
          ? `<div class="rotm-feed-body"><strong>Responder:</strong> @${item.responseSender}  ${item.responseBody || ""}</div>`
          : "";
        return `
          <div class="rotm-feed-row">
            <div class="rotm-feed-meta">
              <span>${formatRotmTime(item.ts)}</span>
              <span>${channelLabel}</span>
              <span class="rotm-feed-sender">@${item.sender || "unknown"}</span>
              <span>${via}</span>
              ${timer}
            </div>
            <div class="rotm-feed-body">${item.body || ""}</div>
            ${responder}
            <span class="${badgeClass}">${item.badge || "Message"}</span>
          </div>
        `;
      }).join("");
      updateRotmTimers();
    }

    function renderRotmLeaderboard(leaderboard) {
      const el = document.getElementById("rotmLeaderboard");
      if (!el) return;
      if (!Array.isArray(leaderboard) || leaderboard.length === 0) {
        el.innerHTML = "<div class='rotm-feed-row'>No confirmed QSOs yet.</div>";
        return;
      }
      const header = `
        <div class="rotm-leader-row rotm-leader-header">
          <div>Rank</div>
          <div>Node</div>
          <div>Unique</div>
          <div>QSOs</div>
          <div>Last activity</div>
        </div>
      `;
      const rows = leaderboard.map((row, idx) => {
        const last = row.lastActivity ? formatDateTime(row.lastActivity) : "--";
        const isActive = appData.rotmSelectedNodeKey === row.nodeKey;
        return `
          <div class="rotm-leader-row${isActive ? " active" : ""}" data-rotm-node="${row.nodeKey}">
            <div class="rotm-leader-rank">${idx + 1}</div>
            <div>
              <div class="rotm-leader-node">${row.node || row.nodeKey}</div>
              <div class="rotm-leader-meta">${row.nodeKey || ""}</div>
            </div>
            <div>
              <div class="rotm-leader-node">${row.uniqueRepeaters || 0}</div>
              <div class="rotm-leader-meta">Unique</div>
            </div>
            <div>
              <div class="rotm-leader-node">${row.qsos || 0}</div>
              <div class="rotm-leader-meta">QSOs</div>
            </div>
            <div class="rotm-leader-meta">${last}</div>
          </div>
        `;
      }).join("");
      el.innerHTML = header + rows;
    }

    function renderRotmMap(node) {
      const title = document.getElementById("rotmMapTitle");
      const list = document.getElementById("rotmClaimList");
      if (!title || !list) return;
      if (!node) {
        title.textContent = "Claimed repeaters map";
        list.innerHTML = "";
        if (rotmMapLayer) rotmMapLayer.clearLayers();
        return;
      }
      title.textContent = `Claimed repeaters for ${node.node || node.nodeKey}`;
      const repeaters = Array.isArray(node.repeaters) ? node.repeaters : [];
      list.innerHTML = repeaters.length
        ? repeaters.map((r) => `<span class="rotm-claim-chip">${r.name || r.hash || "Unknown"}</span>`).join("")
        : "<span class='rotm-claim-chip'>No repeater claims yet.</span>";

      if (!rotmMap) initRotmMap();
      if (rotmMapLayer) rotmMapLayer.clearLayers();
      const points = [];
      repeaters.forEach((r) => {
        if (!r.gps || !Number.isFinite(r.gps.lat) || !Number.isFinite(r.gps.lon)) return;
        const marker = L.circleMarker([r.gps.lat, r.gps.lon], {
          radius: 7,
          color: "#34c759",
          fillColor: "#34c759",
          fillOpacity: 0.85,
          weight: 2
        }).bindPopup(r.name || r.hash || "Repeater");
        rotmMapLayer.addLayer(marker);
        points.push([r.gps.lat, r.gps.lon]);
      });
      if (points.length) {
        rotmMap.fitBounds(points, { padding: [20, 20] });
      } else {
        rotmMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => rotmMap.invalidateSize(), 80);
    }

    function selectRotmNode(nodeKey) {
      appData.rotmSelectedNodeKey = nodeKey;
      const node = (appData.rotmData?.leaderboard || []).find((n) => n.nodeKey === nodeKey) || null;
      renderRotmLeaderboard(appData.rotmData?.leaderboard || []);
      renderRotmMap(node);
    }

    async function loadRotm() {
      if (!appData.authUser?.isAdmin) return;
      if (!appData.rotmConfigLoaded) {
        try {
          const cfg = await fetchRotmConfig();
          const channelInput = document.getElementById("rotmChannelName");
          if (channelInput && cfg?.channel) channelInput.value = cfg.channel;
          if (cfg?.channel) appData.rotmChannelName = cfg.channel;
          const status = document.getElementById("rotmChannelStatus");
          if (status) status.textContent = "Secret is stored until you update it.";
          appData.rotmConfigLoaded = true;
        } catch {
          const status = document.getElementById("rotmChannelStatus");
          if (status) status.textContent = "Unable to load channel settings.";
        }
      }
      try {
        const data = await fetchRotmData();
        appData.rotmData = data;
        const updated = document.getElementById("rotmUpdated");
        if (updated) updated.textContent = data.updatedAt ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "--";
        renderRotmFeed(data.feed || []);
        renderRotmLeaderboard(data.leaderboard || []);
        if (!appData.rotmSelectedNodeKey && data.leaderboard?.length) {
          appData.rotmSelectedNodeKey = data.leaderboard[0].nodeKey;
        }
        if (appData.rotmSelectedNodeKey) {
          selectRotmNode(appData.rotmSelectedNodeKey);
        } else {
          renderRotmMap(null);
        }
      } catch (err) {
        const el = document.getElementById("rotmFeed");
        if (el) el.innerHTML = "<div class='rotm-feed-row'>Unable to load #rotm data.</div>";
      }
    }

    function startRotmRefresh() {
      if (rotmRefreshTimer) clearInterval(rotmRefreshTimer);
      rotmRefreshTimer = setInterval(() => {
        if (document.body.classList.contains("view-rotm")) loadRotm();
      }, 15000);
    }

    function stopRotmRefresh() {
      if (!rotmRefreshTimer) return;
      clearInterval(rotmRefreshTimer);
      rotmRefreshTimer = null;
    }

    function updateRotmTimers() {
      const timers = document.querySelectorAll(".rotm-cq-timer");
      if (!timers.length) return;
      const now = Date.now();
      timers.forEach((el) => {
        const ts = new Date(el.getAttribute("data-ts") || "").getTime();
        if (!Number.isFinite(ts)) {
          el.textContent = "--";
          return;
        }
        const remaining = Math.max(0, ROTM_QSO_WINDOW_MS - (now - ts));
        const mins = Math.floor(remaining / 60000);
        const secs = Math.floor((remaining % 60000) / 1000);
        el.textContent = `QSO window: ${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
      });
    }

    function startRotmTimers() {
      if (rotmTimerTick) clearInterval(rotmTimerTick);
      rotmTimerTick = setInterval(() => {
        if (document.body.classList.contains("view-rotm")) updateRotmTimers();
      }, 1000);
    }

    function stopRotmTimers() {
      if (!rotmTimerTick) return;
      clearInterval(rotmTimerTick);
      rotmTimerTick = null;
    }

    function formatDateTime(value) {
      const d = new Date(value);
      if (!Number.isFinite(d.getTime())) return "unknown";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
    }

    function distanceKm(a, b) {
      const toRad = (v) => (v * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const val = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(val), Math.sqrt(1 - val));
    }

    function badgeHtml(badges) {
      if (!badges.length) return "";
      return `<div class="badge-row">${badges.map((b) => `<span class="badge badge-${b.tone}">${b.label}</span>`).join("")}</div>`;
    }

    function formatDriftMinutes(minutes) {
      if (!Number.isFinite(minutes)) return null;
      const sign = minutes < 0 ? "-" : "+";
      const abs = Math.abs(minutes);
      if (abs < 60) return `${sign}${Math.round(abs)}m`;
      if (abs < 60 * 24) return `${sign}${Math.round(abs / 60)}h`;
      if (abs < 60 * 24 * 365) return `${sign}${Math.round(abs / (60 * 24))}d`;
      return `${sign}${Math.round(abs / (60 * 24 * 365))}y`;
    }

    function buildNearestObserverRepeaters(repeaters, observers) {
      const flagged = new Set();
      if (!Array.isArray(observers) || !Array.isArray(repeaters)) return flagged;
      const repeaterPoints = repeaters.filter((r) => r?.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon) && !(r.gps.lat === 0 && r.gps.lon === 0));
      observers.forEach((o) => {
        if (!o?.gps || !Number.isFinite(o.gps.lat) || !Number.isFinite(o.gps.lon)) return;
        let best = null;
        let bestKm = Infinity;
        repeaterPoints.forEach((r) => {
          const km = distanceKm(o.gps, r.gps);
          if (km < bestKm) {
            bestKm = km;
            best = r;
          }
        });
        if (best?.pub) flagged.add(String(best.pub).toUpperCase());
      });
      return flagged;
    }

    function buildRepeaterBadges(r, nearestObserverSet) {
      const badges = [];
      if (r.stale) badges.push({ label: "Stale repeater", tone: "gray" });
      if (r.gpsImplausible) badges.push({ label: "GPS implausible", tone: "amber" });
      if (r.gpsEstimated) badges.push({ label: "Location estimated", tone: "blue" });
      if (Number(r.total24h || 0) >= 10) badges.push({ label: "Great TX", tone: "green" });
      if (Number.isFinite(r.avgRssi) && r.avgRssi >= -75) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(r.zeroHopNeighbors24h || 0) >= 4) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(r.zeroHopNeighbors24h || 0) >= 3) badges.push({ label: "Great Mesh Neighbour", tone: "amber" });
      if (Number(r.avgRepeats || 0) >= 3 && Number(r.total24h || 0) >= 10) badges.push({ label: "Great Throughput", tone: "amber" });
      if (Number.isFinite(r.clockDriftMinutes) && Math.abs(r.clockDriftMinutes) >= 60) {
        const driftLabel = formatDriftMinutes(r.clockDriftMinutes);
        if (driftLabel) badges.push({ label: `Clock drift ${driftLabel}`, tone: "amber" });
      }
      if (nearestObserverSet && r.pub && nearestObserverSet.has(String(r.pub).toUpperCase())) {
        badges.push({ label: "Close to Observer", tone: "green" });
      }
      return badges;
    }

    function showRankDetail(repeater) {
      const overlay = document.getElementById("rankDetailOverlay");
      const content = document.getElementById("rankDetailContent");
      if (!overlay || !content || !repeater) return;
      const drift = repeater.clockDriftMinutes;
      const driftLabel = Number.isFinite(drift)
        ? formatDriftMinutes(drift)
        : "Clock drift data unavailable";
      const gpsLabel = repeater.gpsImplausible
        ? (repeater.hiddenOnMap ? "Implausible (hidden)" : "Implausible")
        : (repeater.gpsEstimated ? "Estimated" : "Confirmed");
      content.innerHTML = `
        <div class="rank-detail-close">
          <button type="button" onclick="closeRankDetail()"></button>
        </div>
        <div class="rank-detail-row"><span>Repeater</span><strong>${repeater.name}</strong></div>
        <div class="rank-detail-row"><span>Pub</span><strong>${repeater.pub}</strong></div>
        <div class="rank-detail-row"><span>Location</span><strong>${gpsLabel}</strong></div>
        <div class="rank-detail-row"><span>Score</span><strong>${repeater.score}</strong></div>
        <div class="rank-detail-row"><span>Throughput (24h)</span><strong>${repeater.total24h}</strong></div>
        <div class="rank-detail-row"><span>Zero-hop neighbours</span><strong>${repeater.zeroHopNeighbors24h}</strong></div>
        <div class="rank-detail-row"><span>Avg repeats</span><strong>${repeater.avgRepeats}</strong></div>
        <div class="rank-detail-row"><span>Clock drift</span><strong>${driftLabel}</strong></div>
      `;
      overlay.classList.add("open");
    }

    function closeRankDetail() {
      const overlay = document.getElementById("rankDetailOverlay");
      if (overlay) overlay.classList.remove("open");
    }

    async function fetchMessageRoutes(hash, hours = 24) {
      const url = new URL("/api/message-routes", window.location.origin);
      url.searchParams.set("hash", hash);
      url.searchParams.set("hours", String(hours));
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function fetchConfidenceHistory(sender, channel, hours = 168, limit = 400) {
      const url = new URL("/api/confidence-history", window.location.origin);
      if (sender) url.searchParams.set("sender", sender);
      if (channel) url.searchParams.set("channel", channel);
      url.searchParams.set("hours", String(hours));
      url.searchParams.set("limit", String(limit));
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    function resetConfidenceMap() {
      if (confidenceTimer) {
        clearTimeout(confidenceTimer);
        confidenceTimer = null;
      }
      if (confidenceMap) {
        confidenceMap.remove();
        confidenceMap = null;
      }
      confidenceLayers = [];
    }

    function initConfidenceMap(paths, extraPoints) {
      const mapEl = document.getElementById("confidenceMap");
      if (!mapEl || !window.L) return;
      confidenceMap = L.map(mapEl, { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(confidenceMap);

      const bounds = [];
      paths.forEach((path) => {
        (path.pathPoints || []).forEach((pt) => {
          if (Number.isFinite(pt.lat) && Number.isFinite(pt.lon)) bounds.push([pt.lat, pt.lon]);
        });
      });
      (extraPoints || []).forEach((pt) => {
        if (Number.isFinite(pt.lat) && Number.isFinite(pt.lon)) bounds.push([pt.lat, pt.lon]);
      });
      if (bounds.length) {
        confidenceMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    function animateConfidencePaths(paths) {
      if (!confidenceMap) return;
      let idx = 0;
      const list = Array.isArray(paths) ? paths : [];
      const total = list.length;
      const step = () => {
        if (idx >= total) return;
        const entry = list[idx];
        const points = (entry.pathPoints || [])
          .filter((pt) => Number.isFinite(pt.lat) && Number.isFinite(pt.lon))
          .map((pt) => [pt.lat, pt.lon]);
        if (points.length >= 2) {
          const routeColor = entry.observed ? "#34c759" : "#ff3b30";
          const line = L.polyline(points, {
            color: routeColor,
            weight: 2,
            opacity: 0.8
          }).addTo(confidenceMap);
          confidenceLayers.push(line);
        }
        idx += 1;
        confidenceTimer = setTimeout(step, 120);
      };
      step();
    }

    function formatRoutePath(route) {
      const names = Array.isArray(route?.pathNames) ? route.pathNames : [];
      if (names.length) return names.join(" > ");
      const hashes = Array.isArray(route?.path) ? route.path : [];
      if (hashes.length) return hashes.join(" > ");
      return "Direct";
    }

    function formatRouteTime(ts) {
      if (!ts) return "--";
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return "--";
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function openMessageRouteOverlay(messageId) {
      const overlay = document.getElementById("messageRouteOverlay");
      const content = document.getElementById("messageRouteContent");
      if (!overlay || !content) return;
      const msg = (appData.messages || []).find((m) =>
        m.id === messageId || m.frameHash === messageId || m.messageHash === messageId
      );
      const sender = msg?.sender || "Unknown";
      const channelName = msg?.channelName || "";
      overlay.classList.add("open");
      resetConfidenceMap();
      content.innerHTML = `
        <div class="rank-detail-close">
          <button type="button" onclick="closeMessageRouteOverlay()">x</button>
        </div>
        <div class="confidence-title">MeshRank Confidence (7 days)</div>
        <div class="confidence-meta" id="confidenceMeta">Sender: ${sender}${channelName ? ` | Channel: ${channelName}` : ""}</div>
        <div class="confidence-meta" id="confidenceStatus">Loading path history...</div>
        <div class="confidence-map"><div id="confidenceMap"></div></div>
        <div class="confidence-meta" style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn" type="button" id="confidenceViewSuccess">Successful routes</button>
          <button class="btn" type="button" id="confidenceViewFailed">Failed routes</button>
        </div>
        <div class="confidence-meta" id="confidenceExplain"></div>
        <div class="confidence-title">Dead ends</div>
        <div class="confidence-deadends" id="confidenceDeadEnds"></div>
      `;

      fetchConfidenceHistory(sender, channelName || null, 168, 400)
        .then((data) => {
          if (!data?.ok) throw new Error(data?.error || "History lookup failed");
          const paths = Array.isArray(data.paths) ? data.paths : [];
          const deadEnds = Array.isArray(data.deadEnds) ? data.deadEnds : [];
          const meta = document.getElementById("confidenceMeta");
          const status = document.getElementById("confidenceStatus");
          const deadEl = document.getElementById("confidenceDeadEnds");
          const explain = document.getElementById("confidenceExplain");
          const btnSuccess = document.getElementById("confidenceViewSuccess");
          const btnFailed = document.getElementById("confidenceViewFailed");
          if (meta) {
            const channelLabel = data.channel ? ` | Channel: ${data.channel}` : "";
            meta.textContent = `Sender: ${data.sender}${channelLabel} ? Messages: ${data.total || 0}`;
          }
          const renderDeadEnds = () => {
            if (!deadEl) return;
            deadEl.innerHTML = deadEnds.length
              ? deadEnds.map((stop) => `
                  <div class="confidence-deadend">
                    <strong>${stop.name || stop.hash}</strong>
                    <span>${stop.count || 0}</span>
                  </div>
                `).join("")
              : "<div class='confidence-meta'>No dead ends detected.</div>";
          };
          const renderMode = (mode) => {
            const successOnly = mode === "success";
            const filtered = successOnly ? paths.filter((p) => p.observed) : paths.filter((p) => !p.observed);
            const points = deadEnds
              .map((d) => ({ lat: d.gps?.lat, lon: d.gps?.lon }))
              .filter((p) => Number.isFinite(p.lat) && Number.isFinite(p.lon));
            resetConfidenceMap();
            initConfidenceMap(filtered, successOnly ? [] : points);
            if (status) {
              status.textContent = filtered.length
                ? `Animating ${filtered.length} ${successOnly ? "successful" : "failed"} routes from the last ${data.hours || 168} hours.`
                : `No ${successOnly ? "successful" : "failed"} routes found in the last ${data.hours || 168} hours.`;
            }
            if (explain) {
              explain.textContent = successOnly
                ? "Successful routes are messages observed by the MeshRank observer network."
                : "Failed routes end before we see the final hop. This can be observer coverage gaps or a repeater failing to forward.";
            }
            if (!successOnly && confidenceMap && points.length) {
              points.forEach((pt) => {
                const dot = L.circleMarker([pt.lat, pt.lon], {
                  radius: 5,
                  color: "#ff9500",
                  fillColor: "#ff9500",
                  fillOpacity: 0.9,
                  weight: 2
                }).addTo(confidenceMap);
                confidenceLayers.push(dot);
              });
            }
            animateConfidencePaths(filtered);
          };
          renderDeadEnds();
          if (btnSuccess) btnSuccess.onclick = () => renderMode("success");
          if (btnFailed) btnFailed.onclick = () => renderMode("failed");
          renderMode("success");
        })
        .catch((err) => {
          content.innerHTML = `
            <div class="rank-detail-close">
              <button type="button" onclick="closeMessageRouteOverlay()">x</button>
            </div>
            <div class="confidence-title">MeshRank Confidence (7 days)</div>
            <div class="confidence-meta">Unable to load confidence data: ${err?.message || err}</div>
          `;
        });
    }

    function closeMessageRouteOverlay() {
      const overlay = document.getElementById("messageRouteOverlay");
      if (overlay) overlay.classList.remove("open");
      resetConfidenceMap();
    }

    function buildObserverBadges(o) {
      const badges = [];
      if (Number.isFinite(o.ageHours)) {
        const ageMinutes = o.ageHours * 60;
        if (ageMinutes <= 15) {
          badges.push({ label: "Live", tone: "green" });
        } else if (o.lowPacketRate || o.ageHours <= 24) {
          badges.push({ label: "Low packet rate", tone: "amber" });
        } else {
          badges.push({ label: "Offline", tone: "gray" });
        }
      }
      if (o.stale) badges.push({ label: "Stale observer", tone: "gray" });
      if (Number.isFinite(o.ageHours) && o.ageHours <= 1 && Number(o.uptimeHours || 0) >= 48) {
        badges.push({ label: "Great Uptime", tone: "green" });
      }
      if (Number(o.packetsToday || 0) >= 200) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(o.coverageCount || 0) >= 5) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(o.coverageKm || 0) >= 20) badges.push({ label: "Wide Coverage", tone: "amber" });
      if (Number(o.nearestRepeaterKm || 999) <= 5) badges.push({ label: "Close to Repeater", tone: "green" });
      return badges;
    }

    const MOBILE_RANK_PAGE_SIZE = 40;

    async function fetchRank(opts = {}) {
      const params = new URLSearchParams();
      params.set("_ts", Date.now().toString());
      if (Number.isFinite(opts.limit) && opts.limit > 0) params.set("_limit", opts.limit);
      if (Number.isFinite(opts.skip) && opts.skip > 0) params.set("_skip", opts.skip);
      const res = await fetch(`/api/repeater-rank?${params.toString()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function loadRankChunk(limit, skip, replace) {
      const data = await fetchRank({ limit, skip });
      if (!data?.items?.length) return 0;
      if (replace) {
        appData.rankData = data.items.slice();
      } else {
        appData.rankData = appData.rankData.concat(data.items);
      }
      appData.rankTotalCount = typeof data.count === "number" ? data.count : appData.rankTotalCount;
      renderRank({ ...data, items: appData.rankData });
      return data.items.length;
    }

    let rankMobileLoadingMore = false;

    function loadMoreRankChunks() {
      if (rankMobileLoadingMore) return;
      if (appData.rankData.length >= (appData.rankTotalCount || Infinity)) return;
      rankMobileLoadingMore = true;
      loadRankChunk(MOBILE_RANK_PAGE_SIZE, appData.rankData.length, false)
        .then((count) => {
          if (count >= MOBILE_RANK_PAGE_SIZE) {
            setTimeout(loadMoreRankChunks, 200);
          }
        })
        .finally(() => {
          rankMobileLoadingMore = false;
        });
    }

    async function loadRankForMobile() {
      appData.rankData = [];
      setRankLoading(true);
      await loadRankChunk(MOBILE_RANK_PAGE_SIZE, 0, true);
      setRankLoading(false);
      loadMoreRankChunks();
    }

    async function loadRankDefault() {
      setRankLoading(true);
      try {
        if (isMobile()) {
          await loadRankForMobile();
        } else {
          const data = await fetchRank();
          renderRank(data);
        }
      } finally {
        setRankLoading(false);
      }
    }

    async function fetchNodeRank() {
      const res = await fetch(`/api/node-rank?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRankSummary() {
      const res = await fetch(`/api/repeater-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshRankSummary() {
      try {
        const summary = await fetchRankSummary();
        appData.rankSummary = summary;
        renderRankSummary(summary);
      } catch {}
    }

    async function fetchNodeRankSummary() {
      const res = await fetch(`/api/node-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshNodeRankSummary() {
      try {
        const summary = await fetchNodeRankSummary();
        appData.nodeRankSummary = summary;
        renderNodeRankSummary(summary);
      } catch {}
    }

    async function fetchMeshScore() {
      const res = await fetch("/api/meshscore", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRfLatest() {
      const res = await fetch("/api/rf-latest?limit=100", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRouteSuggestions() {
      const res = await fetch(`/api/route-suggestions?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function shortHex(value, len) {
      if (!value) return "--";
      const s = String(value);
      if (s.length <= len) return s;
      return s.slice(0, len);
    }

    function getHopCount(msg) {
      const pathLen = Array.isArray(msg.path) ? msg.path.length : 0;
      const pathLength = Number.isFinite(msg.pathLength) ? msg.pathLength : 0;
      const uniqueHop = Number.isFinite(msg.uniqueHopCount) ? msg.uniqueHopCount : 0;
      const repeats = Number.isFinite(msg.repeats) ? msg.repeats : 0;
      return Math.max(pathLen, pathLength, uniqueHop, repeats);
    }

    function buildRepeatersByCode(data) {
      const map = new Map();
      const items = data?.items || [];
      for (const item of items) {
        const code = String(item.hashByte || "").toUpperCase();
        if (!code) continue;
        if (!map.has(code)) map.set(code, []);
        map.get(code).push({
          pub: item.pub,
          name: item.name || code,
          gps: item.gps || null
        });
      }
      return map;
    }

    async function ensureRouteSuggestions() {
      if (appData.routeSuggestions) return;
      try {
        appData.routeSuggestions = await fetchRouteSuggestions();
      } catch {
        appData.routeSuggestions = { byCode: {} };
      }
    }

    const routeOverrides = (() => {
      try {
        return JSON.parse(localStorage.getItem("routeOverrides") || "{}");
      } catch {
        return {};
      }
    })();

    function saveRouteOverrides() {
      try {
        localStorage.setItem("routeOverrides", JSON.stringify(routeOverrides));
      } catch {}
    }

    function overrideRouteName(hash, name) {
      const key = String(hash || "").toUpperCase();
      if (!key) return;
      if (!name) {
        delete routeOverrides[key];
      } else {
        routeOverrides[key] = name;
      }
      saveRouteOverrides();
    }

    function resolveRouteName(hash, fallback) {
      const key = String(hash || "").toUpperCase();
      if (key && routeOverrides[key]) return routeOverrides[key];
      const suggestion = appData.routeSuggestions?.byCode?.[key];
      if (suggestion?.accepted && suggestion.name) return suggestion.name;
      return fallback || hash || "#unknown";
    }

    function formatPathLabel(p) {
      const names = Array.isArray(p.pathNames) ? p.pathNames : [];
      const codes = Array.isArray(p.path) ? p.path : [];
      if (names.length) {
        const merged = names.map((name, idx) => {
          const code = codes[idx] || "";
          if (name === "#unknown") return resolveRouteName(code, code || "#unknown");
          const resolved = resolveRouteName(code, name);
          return code ? `${resolved} (${code})` : resolved;
        });
        return merged.join(" > ");
      }
      if (codes.length) return codes.join(" > ");
      return "--";
    }

    function renderRfList() {
      const list = document.getElementById("rfList");
      if (!list) return;
      const search = document.getElementById("rfSearch")?.value?.trim().toLowerCase() || "";
      const typeFilter = document.getElementById("rfTypeFilter")?.value || "";
      const filtered = appData.rfPackets.filter((p) => {
        if (typeFilter && p.payloadType !== typeFilter) return false;
        if (!search) return true;
        const hay = [
          p.hash,
          p.fp,
          p.senderPublicKey,
          p.destinationHash,
          p.channelHash,
          p.channelName,
          p.routeTypeName,
          ...(p.path || []),
          ...(p.pathNames || [])
        ].filter(Boolean).join(" ").toLowerCase();
        return hay.includes(search);
      });
      list.innerHTML = "";
      document.getElementById("rfCount").textContent = `${filtered.length} packets`;
      const total = appData.rfPackets.length;
      const ok = appData.rfPackets.filter((p) => p.crc === true).length;
      const bad = appData.rfPackets.filter((p) => p.crc === false).length;
      const typeCounts = {};
      appData.rfPackets.forEach((p) => {
        const t = p.payloadType || "Unknown";
        typeCounts[t] = (typeCounts[t] || 0) + 1;
      });
      const topType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "--";
      document.getElementById("rfTotal").textContent = total;
      document.getElementById("rfOk").textContent = ok;
      document.getElementById("rfBad").textContent = bad;
      document.getElementById("rfTopType").textContent = topType;
      const slice = filtered.slice(-150).reverse();
      const frag = document.createDocumentFragment();
      const header = document.createElement("div");
      header.className = "rf-row rf-header";
      header.innerHTML = `
          <div>Time</div>
          <div>Type</div>
          <div>Route</div>
          <div>Hash</div>
          <div>Hops</div>
          <div>Sender</div>
          <div>Observers</div>
          <div>RSSI</div>
          <div>SNR</div>
          <div>Len</div>
          <div>CRC</div>
          <div>Edit</div>
        `;
      frag.appendChild(header);
      slice.forEach((p) => {
        const row = document.createElement("div");
        row.className = "rf-row";
        row.dataset.key = String(p.hash || p.fp || "--");
        const time = p.ts ? new Date(p.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" }) : "--";
        const hash = shortHex(p.hash || p.fp || "--", 10);
        const route = p.routeTypeName || "--";
        const pathLabel = formatPathLabel(p);
        const hopCount = Number.isFinite(p.hopCount) ? p.hopCount : (p.pathLength ?? 0);
        const sender = p.senderName || (p.senderPublicKey ? shortHex(p.senderPublicKey, 12) : "--");
        const entries = Array.isArray(p.observerEntries) ? p.observerEntries : [];
        const toggle = entries.length
          ? `<button class="rf-toggle" data-rf-toggle="${row.dataset.key}">+</button> ${p.observerCount ?? 1}`
          : `${p.observerCount ?? 1}`;
        row.innerHTML = `
          <div>${time}</div>
          <div><span class="rf-type">${p.payloadType || "Unknown"}</span></div>
          <div>${route}</div>
          <div>${hash}</div>
          <div title="${pathLabel}">${hopCount}</div>
          <div>${sender}</div>
          <div>${toggle}</div>
          <div>${Number.isFinite(p.rssi) ? p.rssi : "--"}</div>
          <div>${Number.isFinite(p.snr) ? p.snr : "--"}</div>
          <div>${p.len ?? "--"}</div>
          <div>${p.crc === true ? "CRC" : p.crc === false ? "BAD" : "--"}</div>
          <div><button class="link-btn rf-edit" type="button">Edit</button></div>
        `;
        row.addEventListener("click", () => {
          appData.rfSelected = p;
          renderRfDetail();
        });
        row.querySelector(".rf-edit")?.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          appData.routeActiveId = p.hash || null;
          appData.routeActiveMsg = {
            id: p.hash || "--",
            path: Array.isArray(p.path) ? p.path : [],
            pathNames: Array.isArray(p.pathNames) ? p.pathNames : []
          };
          appData.routeActivePathCodes = Array.isArray(p.path) ? p.path.slice() : [];
          appData.routeActivePathPoints = [];
          await ensureRouteSuggestions();
          openRouteOverrideModal();
        });
        frag.appendChild(row);
        entries.forEach((entry) => {
          const child = document.createElement("div");
          child.className = "rf-row rf-child is-hidden";
          child.dataset.parentKey = row.dataset.key;
          const childTime = entry.ts
            ? new Date(entry.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" })
            : "--";
          const childPath = formatPathLabel(entry);
          const childObserver = entry.observerName || entry.observerId || "--";
          child.innerHTML = `
            <div>${childTime}</div>
            <div><span class="rf-type">Obs</span></div>
            <div>via</div>
            <div>--</div>
            <div title="${childPath}">${childPath}</div>
            <div>${childObserver}</div>
            <div>1</div>
            <div>${Number.isFinite(entry.rssi) ? entry.rssi : "--"}</div>
            <div>${Number.isFinite(entry.snr) ? entry.snr : "--"}</div>
            <div>${entry.len ?? "--"}</div>
            <div>--</div>
          `;
          frag.appendChild(child);
        });
      });
      list.appendChild(frag);
    }

    function renderRfDetail() {
      const detail = document.getElementById("rfDetail");
      if (!detail) return;
      const p = appData.rfSelected;
      if (!p) {
        detail.innerHTML = `<div class="rf-kv">Select a packet to inspect its payload.</div>`;
        return;
      }
      const pathLabel = formatPathLabel(p);
      const sender = p.senderName || p.senderPublicKey || "--";
      const channelLabel = p.channelName ? `${p.channelName} (${p.channelHash || "--"})` : (p.channelHash || "--");
      const appFlags = Number.isFinite(p.appFlags) ? `0x${p.appFlags.toString(16).toUpperCase().padStart(2, "0")}` : "--";
      const observerNames = Array.isArray(p.observerHits) && p.observerHits.length
        ? p.observerHits.join(", ")
        : (p.observerName || "--");
      detail.innerHTML = `
        <div class="rf-kv"><strong>Packet</strong></div>
        <div class="rf-kv">Type: ${p.payloadType || "Unknown"}</div>
        <div class="rf-kv">Route: ${p.routeTypeName || "--"}</div>
        <div class="rf-kv">Hash: ${(p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Full hash: ${(p.frameHash || p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Time: ${p.ts ? new Date(p.ts).toLocaleString() : "--"}</div>
        <div class="rf-kv">RSSI/SNR: ${Number.isFinite(p.rssi) ? p.rssi : "--"} / ${Number.isFinite(p.snr) ? p.snr : "--"}</div>
        <div class="rf-kv">CRC: ${p.crc === true ? "ok" : p.crc === false ? "fail" : "unknown"}</div>
        <div class="rf-kv">Length: ${p.len ?? "--"}</div>
        <div class="rf-kv">Observers: ${observerNames}</div>
        <div class="rf-kv">Fingerprint: ${p.fp || "--"}</div>
        <div class="rf-kv">Sender: ${sender}</div>
        <div class="rf-kv">Destination: ${p.destinationHash || "--"}</div>
        <div class="rf-kv">Channel: ${channelLabel}</div>
        <div class="rf-kv">Path (${p.pathLength ?? 0} hops): ${pathLabel}</div>
        <div class="rf-kv">Advert name: ${p.advertName || "--"}</div>
        <div class="rf-kv">App flags: ${appFlags}</div>
        <div class="rf-kv">Payload bytes: ${p.payloadBytes ?? "--"}</div>
        <div class="rf-kv">Decrypted: ${p.decrypted === true ? "yes" : "no"}</div>
        <div class="rf-kv">Valid: ${p.isValid === true ? "yes" : p.isValid === false ? "no" : "unknown"}</div>
      `;
    }

    function renderMeshScore(data, rangeDays) {
      if (!data) return;
      appData.meshScore = data;
      document.getElementById("meshUpdated").textContent = new Date(data.updatedAt).toLocaleTimeString();
      document.getElementById("meshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("meshYesterday").textContent = data.scores?.yesterday ?? 0;
      document.getElementById("meshDelta").textContent = data.scores?.delta ?? 0;
      document.getElementById("meshMessages").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshDevices").textContent = data.totals?.devices ?? 0;
      document.getElementById("meshRepeaters").textContent = data.totals?.activeRepeaters ?? 0;
      document.getElementById("meshRooms").textContent = data.totals?.roomServers ?? 0;
      document.getElementById("meshChat").textContent = data.totals?.chatNodes ?? 0;
      document.getElementById("meshCompanions").textContent = data.totals?.companions ?? 0;
      document.getElementById("meshMsgsToday").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshMsgsObserver").textContent = data.messages?.observerToday ?? 0;

      const series = data.series || [];
      const days = rangeDays || 7;
      const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const filtered = series.filter((s) => new Date(s.date) >= cutoff);
      const points = filtered.map((s, idx) => {
        const x = (idx / Math.max(1, filtered.length - 1)) * 580 + 10;
        const y = 200 - (Math.max(0, Math.min(100, s.score)) / 100) * 160;
        return `${x},${y}`;
      });
      const line = document.getElementById("meshLine");
      const area = document.getElementById("meshArea");
      if (points.length) {
        line.setAttribute("points", points.join(" "));
        const areaPoints = [`10,200`, ...points, `590,200`];
        area.setAttribute("points", areaPoints.join(" "));
      } else {
        line.setAttribute("points", "");
        area.setAttribute("points", "");
      }

      document.getElementById("rankMeshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("rankMeshYesterday").textContent = data.scores?.yesterday ?? 0;
    }

    function renderRank(data) {
      if (!data?.items) return;
      appData.rankData = data.items.slice();
      appData.rankPayload = data;
      renderRankWithOptions({ ...data, items: appData.rankData }, { preserveView: true });
    }

    function renderRankSummary(summary) {
      if (!summary) return;
      document.getElementById("rankUpdated").textContent = summary.updatedAt
        ? formatDateTime(summary.updatedAt)
        : "--";
      document.getElementById("rankTotal").textContent = summary.count ?? 0;
      document.getElementById("rankActive").textContent = summary.totals?.active ?? 0;
    }


    function renderNodeRankSummary(summary) {
      if (!summary) return;
      document.getElementById("nodeRankUpdated").textContent = summary.updatedAt
        ? formatDateTime(summary.updatedAt)
        : "--";
      document.getElementById("nodeRankTotal").textContent = summary.count ?? 0;
      document.getElementById("nodeRankActive").textContent = summary.totals?.active ?? 0;
      document.getElementById("nodeRankMessages").textContent = summary.totals?.messages24h ?? 0;
    }

    function renderNodeRank(data) {
      if (!data?.items) return;
      appData.nodeRank = data;
      const list = document.getElementById("nodeRankList");
      list.innerHTML = "";
      if (nodeRankLayer) nodeRankLayer.clearLayers();
      nodeRankMarkers = new Map();

      const needle = (document.getElementById("nodeRankSearch")?.value || "").trim().toLowerCase();
      const onMobile = isMobile();
      const visible = data.items.filter((n) => {
        if (!needle) return true;
        const name = String(n.name || "").toLowerCase();
        const pub = String(n.pub || "").toLowerCase();
        const model = String(n.model || "").toLowerCase();
        return name.includes(needle) || pub.includes(needle) || model.includes(needle);
      });

      visible.forEach((n) => {
        const scoreBadge = String(Math.round(n.score || 0)).padStart(2, "0");
        const lastMsg = n.lastMessageAt ? formatDateTime(n.lastMessageAt) : "unknown";
        const lastSeen = n.lastSeen ? formatDateTime(n.lastSeen) : "unknown";
        const model = n.model || "--";
        const item = document.createElement("div");
        item.className = "rank-item";
        item.innerHTML = `
          <div class="score">
            <span class="rank-dot" style="background:${n.scoreColor}">${scoreBadge}</span>
            <div class="rank-main">
              <strong>${n.name || n.pub || "Unknown"}</strong>
              <div class="rank-meta">Messages 24h: ${n.messages24h ?? 0} | Unique: ${n.uniqueMessages24h ?? 0}</div>
              <div class="rank-meta">Last message: ${lastMsg}</div>
              <div class="rank-meta">Last seen: ${lastSeen}</div>
              <div class="rank-meta">Model: ${model}</div>
            </div>
          </div>
        `;
        list.appendChild(item);

        if (!onMobile && n.gps && Number.isFinite(n.gps.lat) && Number.isFinite(n.gps.lon)) {
          const marker = L.circleMarker([n.gps.lat, n.gps.lon], {
            radius: 7,
            color: n.scoreColor,
            fillColor: n.scoreColor,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(`${n.name || n.pub} | ${n.messages24h ?? 0} msgs`);
          marker.addTo(nodeRankLayer);
          if (n.pub) nodeRankMarkers.set(n.pub, marker);
        }
      });

      if (!onMobile && nodeRankMap && visible.length) {
        const bounds = visible
          .filter((n) => n.gps && Number.isFinite(n.gps.lat) && Number.isFinite(n.gps.lon))
          .map((n) => [n.gps.lat, n.gps.lon]);
        if (bounds.length) nodeRankMap.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    function scrollRankItemToTop(pub) {
      if (!pub) return;
      const list = document.getElementById("rankList");
      const scroll = document.getElementById("rankScroll");
      const item = document.querySelector(`.rank-item[data-pub="${String(pub).toUpperCase()}"]`);
      if (!list || !scroll || !item) return;
      scroll.scrollTop = item.offsetTop - scroll.offsetTop;
    }

    function renderRankWithOptions(data, options) {
      const opts = options || {};
      appData.rankData = data.items || [];
      appData.repeatersByCode = buildRepeatersByCode(data);
      const list = document.getElementById("rankList");
      list.innerHTML = "";
      rankLayer.clearLayers();
      rankMarkers = new Map();

      if (appData.meshScore) {
        document.getElementById("rankMeshToday").textContent = appData.meshScore.scores?.today ?? 0;
        document.getElementById("rankMeshYesterday").textContent = appData.meshScore.scores?.yesterday ?? 0;
      }

      const needle = (appData.rankFilter || "").toLowerCase();
      const onMobile = isMobile();
      const sorted = [...data.items]
        .sort((a, b) => (b.score || 0) - (a.score || 0))
        .filter((r) => {
          if (!needle) return true;
          const name = String(r.name || "").toLowerCase();
          const pub = String(r.pub || "").toLowerCase();
          const code = String(r.hashByte || "").toLowerCase();
          return name.includes(needle) || pub.includes(needle) || code.includes(needle);
        });
      const visible = sorted;
      const nearestObserverSet = buildNearestObserverRepeaters(sorted, appData.observerRank?.items || []);
      visible.forEach((r) => {
          const item = document.createElement("div");
          const isHidden = isRepeaterHidden(r);
          const hiddenLabel = r.gpsImplausible ? "GPS implausible" : (r.stale ? "Stale repeater" : "GPS unreliable");
          const badges = buildRepeaterBadges(r, nearestObserverSet);
          item.className = "rank-item" + (isHidden ? " hidden" : "");
          item.dataset.pub = (r.pub || "").toUpperCase();
          const observerBadge = r.isObserver ? `<div class="row"><span class="badge">Observer</span></div>` : "";
          const adminControls = `
            <div class="row repeater-location-controls" data-repeater-controls="${r.pub || ""}">
              <span class="admin-only">
                <button class="btn" type="button" data-repeater-locate="${r.pub || ""}">Set location</button>
              </span>
            </div>
          `;
          const code = r.hashByte ? `<span class="chip" style="margin-left:6px;">${r.hashByte}</span>` : "";
            const scoreBadge = String(Math.round(r.score || 0)).padStart(2, "0");
            item.innerHTML = `
              <div class="score">
                <span class="rank-dot" style="background:${r.color}">${scoreBadge}</span>
                ${r.name} ${code}
              </div>
            <div class="row">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
            <div class="row">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
            <div class="row">
              <a class="link-btn" href="#" data-repeater-neighbors="${r.pub || ""}">Zero-hop neighbours (24hrs): ${r.zeroHopNeighbors24h ?? 0}</a>
              <span style="color:var(--muted);">|</span>
              <a class="link-btn" href="#" data-repeater-pub="${r.pub || ""}">Public key</a>
            </div>
            <div class="row">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
            <div class="row">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
            ${badgeHtml(badges)}
              ${isHidden ? `<div class="row"><span class="badge">${hiddenLabel}</span></div>` : ""}
            ${observerBadge}
            ${adminControls}
          `;
        item.addEventListener("click", () => {
          openRankPopup(r, false);
        });
        list.appendChild(item);

        if (!onMobile && !isHidden && r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon)) {
          const marker = L.circleMarker([r.gps.lat, r.gps.lon], {
            radius: 8,
            color: r.color,
            fillColor: r.color,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(buildRankPopupHtml(r)).addTo(rankLayer)
            .on("click", () => openRankPopup(r, true));
          if (r.pub) rankMarkers.set(r.pub, marker);
        }
      });

      if (onMobile && rankMap) {
        setTimeout(() => rankMap.invalidateSize(), 80);
      }

      if (!onMobile && !opts.preserveView && sorted.length) {
        const bounds = sorted
          .filter((r) => {
            if (isRepeaterHidden(r)) return false;
            return r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon);
          })
          .map((r) => [r.gps.lat, r.gps.lon]);
        if (bounds.length) rankMap.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    function buildRankPopupHtml(r) {
      const impact = Math.min(100, Math.max(0, r.score || 0));
      const code = r.hashByte ? ` <span class="chip chip-strong">${r.hashByte}</span>` : "";
      const isAdmin = !!appData.authUser?.isAdmin;
      const flaggedNote = r.gpsImplausible
        ? `<div style="font-size:12px;color:#9a5b00;margin-top:4px;">GPS implausible${r.hiddenOnMap ? "  hidden from map" : ""}</div>`
        : "";
      const estimatedNote = r.gpsEstimated
        ? `<div style="font-size:12px;color:#356">Location estimated (${r.gpsEstimateNeighbors || "?"} neighbors)</div>`
        : "";
      const actionButtons = `
        <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn" type="button" data-repeater-flag="${r.pub}">Flag wrong location</button>
          ${isAdmin ? `<button class="btn" type="button" data-repeater-correct="${r.pub}">Correct location</button>` : ""}
        </div>
        ${isAdmin ? "" : `<div style="margin-top:6px;font-size:12px;color:rgba(60,60,67,0.6);">Admin login required to correct location.</div>`}
      `;
      const locationNote = `${flaggedNote}${estimatedNote}${actionButtons}`;
      return `
        <div style="min-width:220px;font-family:'Space Grotesk',system-ui,sans-serif;">
          <div style="font-weight:700;margin-bottom:6px;">${r.name}${code}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);">Score: <strong>${r.score}</strong> | ${r.stale ? "stale" : "active"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Zero-hop neighbours (24hrs): ${r.zeroHopNeighbors24h ?? 0}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
          ${locationNote}
          <div style="margin-top:8px;font-size:12px;color:rgba(60,60,67,0.6);">Network impact</div>
          <div style="height:8px;border-radius:999px;background:rgba(0,122,255,0.12);overflow:hidden;">
            <div style="height:100%;width:${impact}%;background:linear-gradient(90deg,#34c759,#007aff);"></div>
          </div>
        </div>
      `;
    }

    function openRankPopup(r, skipPan) {
      if (!r) return;
      const list = document.getElementById("rankList");
      const listItem = document.querySelector(`.rank-item[data-pub="${(r.pub || "").toUpperCase()}"]`);
      document.querySelectorAll(".rank-item.focused").forEach((el) => el.classList.remove("focused"));
      if (listItem) {
        listItem.classList.add("focused");
        if (list && list.firstChild !== listItem) {
          list.prepend(listItem);
        }
        listItem.scrollIntoView({ block: "start", behavior: "smooth" });
      }
      const lat = r.gps?.lat;
      const lon = r.gps?.lon;
      const hasGps = Number.isFinite(lat) && Number.isFinite(lon);
      const marker = r.pub ? rankMarkers.get(r.pub) : null;
      const html = buildRankPopupHtml(r);

      if (marker) {
        marker.setPopupContent(html);
        marker.openPopup();
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView(marker.getLatLng(), targetZoom, { animate: true });
        }
        return;
      }

      if (hasGps) {
        const popup = L.popup({ closeButton: true, autoClose: true })
          .setLatLng([lat, lon])
          .setContent(html)
          .openOn(rankMap);
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView([lat, lon], targetZoom, { animate: true });
        }
      }
      showRankDetail(r);
    }


    const navLinks = document.querySelectorAll(".nav a, .mobile-nav a, .mobile-menu a");
    const menuToggle = document.getElementById("menuToggle");
    const menuBackdrop = document.getElementById("menuBackdrop");
    const channelToggles = document.querySelectorAll("[data-channels-toggle]");
    const closeMenu = () => {
      document.body.classList.remove("menu-open-left", "menu-open-right");
    };
    menuToggle?.addEventListener("click", () => {
      document.body.classList.toggle("menu-open-right");
      document.body.classList.remove("menu-open-left");
    });
    menuBackdrop?.addEventListener("click", closeMenu);
    channelToggles.forEach((toggle) => {
      toggle.addEventListener("click", () => {
        document.body.classList.toggle("menu-open-left");
        document.body.classList.remove("menu-open-right");
      });
    });
    navLinks.forEach((link) => {
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          document.body.classList.remove("route-open");
          navLinks.forEach((l) => l.classList.remove("active"));
          let view = link.dataset.view;
          if (view === "rotm" && !appData.authUser?.isAdmin) {
            view = "channels";
          }
          navLinks.forEach((l) => {
            if (l.dataset.view === view) l.classList.add("active");
          });
          closeMenu();
          document.body.classList.toggle("view-channels", view === "channels");
          document.body.classList.toggle("view-rotm", view === "rotm");
          document.body.classList.toggle("view-rank", view === "rank");
          document.body.classList.toggle("view-node-rank", view === "node-rank");
          document.body.classList.toggle("view-meshscore", view === "meshscore");
          document.body.classList.toggle("view-rf", view === "rf");
          document.body.classList.toggle("view-observer", view === "observer");
          document.body.classList.toggle("view-observer-rank", view === "observer-rank");
          document.body.classList.toggle("view-why", view === "why");
          if (view !== "channels") {
            updateChannelParam(null);
          }

        if (view === "rank") {
          if (!rankMap) initRankMap();
          try {
            await refreshRankSummary();
            await loadRankDefault();
            setTimeout(async () => {
              try {
                const mesh = await fetchMeshScore();
                renderMeshScore(mesh, meshRangeDays);
              } catch {}
            }, 0);
          } catch (err) {
            const list = document.getElementById("rankList");
            list.innerHTML = "<div class='rank-item'>No repeaters yet.</div>";
          }
        }

        if (view === "node-rank") {
          if (!appData.authUser) {
            document.body.classList.remove("view-node-rank");
            document.body.classList.add("view-channels");
            navLinks.forEach((l) => l.classList.remove("active"));
            navLinks.forEach((l) => {
              if (l.dataset.view === "channels") l.classList.add("active");
            });
            return;
          }
          if (!isMobile() && !nodeRankMap) initNodeRankMap();
          try {
            await refreshNodeRankSummary();
            const data = await fetchNodeRank();
            renderNodeRank(data);
            if (nodeRankMap) {
              setTimeout(() => nodeRankMap.invalidateSize(), 80);
            }
          } catch (err) {
            const list = document.getElementById("nodeRankList");
            list.innerHTML = "<div class='rank-item'>No nodes yet.</div>";
          }
        }

        if (view === "meshscore") {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        }

        if (view === "rf") {
          try {
            const payload = await fetchRfLatest();
            const items = payload.items || [];
            const last = items[items.length - 1];
            const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
            if (sig !== appData.rfLastSig) {
              appData.rfLastSig = sig;
              appData.rfPackets = items;
              document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
              renderRfList();
            }
          } catch {}
        }

        if (view === "observer") {
          if (!observerMap) initObserverMap();
          if (observerMap) {
            setTimeout(() => observerMap.invalidateSize(), 80);
          }
        }
        if (view === "rotm") {
          if (!appData.authUser?.isAdmin) return;
          if (!rotmMap) initRotmMap();
          await loadRotm();
          startRotmRefresh();
          startRotmTimers();
        } else {
          stopRotmRefresh();
          stopRotmTimers();
        }

        if (view === "observer-rank") {
          if (!observerRankMap) initObserverRankMap();
          if (observerRankMap) {
            setTimeout(() => observerRankMap.invalidateSize(), 80);
          }
          try {
            setObserverRankLoading(true);
            await refreshObserverRankSummary();
            const data = await fetchObserverRank();
            appData.observerRank = data;
            renderObserverRank(data);
            renderObserverRankMap(data);
          } catch {}
          finally {
            setObserverRankLoading(false);
          }
        }
        if (view === "why") {
          // static content
        }
      });
    });

    const authModal = document.getElementById("authModal");
    const loginBtn = document.getElementById("loginBtn");
    const authClose = document.getElementById("authClose");
    const authLogin = document.getElementById("authLogin");
    const authBootstrap = document.getElementById("authBootstrap");
    const authLogout = document.getElementById("authLogout");
    const authUserInput = document.getElementById("authUsername");
    const authPassInput = document.getElementById("authPassword");

    loginBtn?.addEventListener("click", async () => {
      authModal?.classList.add("open");
      setAuthUser(appData.authUser);
      try {
        const res = await fetch("/api/admin/status", { cache: "no-store" });
        const data = await res.json();
        setBootstrapVisibility(!!data.hasAdmin);
      } catch {}
    });
    authClose?.addEventListener("click", () => authModal?.classList.remove("open"));
    authModal?.addEventListener("click", (e) => {
      if (e.target === authModal) authModal.classList.remove("open");
    });

    authLogin?.addEventListener("click", async () => {
      const username = authUserInput?.value?.trim() || "";
      const password = authPassInput?.value || "";
      if (!username || !password) return;
      const res = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.ok) {
        document.getElementById("authStatus").textContent = data.error || "Login failed.";
        return;
      }
      appData.authToken = data.token || null;
      saveAuthToken(appData.authToken);
      setAuthUser(data.user || null);
    });

    authBootstrap?.addEventListener("click", async () => {
      const username = authUserInput?.value?.trim() || "";
      const password = authPassInput?.value || "";
      if (!username || password.length < 8) {
        document.getElementById("authStatus").textContent = "Use a strong password (min 8 chars).";
        return;
      }
      const res = await fetch("/api/admin/bootstrap", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password })
      });
      const data = await res.json().catch(() => ({}));
      document.getElementById("authStatus").textContent = data.ok
        ? "Admin created. You can now log in."
        : (data.error || "Admin setup failed.");
    });

    authLogout?.addEventListener("click", async () => {
      await fetch("/api/auth/logout", { method: "POST", headers: authHeaders() }).catch(() => {});
      appData.authToken = null;
      saveAuthToken(null);
      setAuthUser(null);
    });

    document.getElementById("observerRankSearch")?.addEventListener("input", () => {
      if (!appData.observerRank) return;
      renderObserverRank(appData.observerRank);
      renderObserverRankMap(appData.observerRank);
    });

    document.getElementById("nodeRankSearch")?.addEventListener("input", () => {
      if (!appData.nodeRank) return;
      renderNodeRank(appData.nodeRank);
    });

    function buildObserverEnvSnippet() {
      const ssid = (document.getElementById("observerWifi")?.value || "").trim();
      const pass = (document.getElementById("observerPass")?.value || "").trim();
      const name = (document.getElementById("observerName")?.value || "").trim();
      const lines = [
        `wifi.ssid ${ssid || "YOUR_WIFI_SSID"}`,
        `wifi.pass ${pass || "YOUR_WIFI_PASSWORD"}`,
        `observer.name ${name || "Observer"}`,
        "status"
      ];
      return lines.join("\n");
    }

    function copyText(text) {
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          alert("Config copied to clipboard.");
        }).catch(() => {
          alert(text);
        });
        return;
      }
      alert(text);
    }

    function setObserverStatus(text, isError) {
      const el = document.getElementById("observerStatus");
      if (!el) return;
      el.textContent = text;
      el.style.color = isError ? "#ff3b30" : "var(--muted)";
    }

    let observerAutoConfig = false;

    function concatUint8(chunks) {
      const total = chunks.reduce((sum, c) => sum + c.length, 0);
      const out = new Uint8Array(total);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.length;
      }
      return out;
    }

    async function readSerialOnce(port, timeoutMs) {
      if (!port.readable) return "";
      const reader = port.readable.getReader();
      const chunks = [];
      let timedOut = false;
      const timer = setTimeout(() => {
        timedOut = true;
        reader.cancel().catch(() => {});
      }, timeoutMs);
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) chunks.push(value);
        }
      } catch {
      } finally {
        clearTimeout(timer);
        reader.releaseLock();
      }
      if (!chunks.length) return timedOut ? "" : "";
      const bytes = concatUint8(chunks);
      return new TextDecoder().decode(bytes);
    }

      async function sendObserverConfig() {
        if (!navigator.serial) {
          setObserverStatus("WebSerial not available in this browser.", true);
          alert("WebSerial not available. Use Chrome/Edge over HTTPS.");
          return;
        }
        const ssidValue = (document.getElementById("observerWifi")?.value || "").trim();
        if (!ssidValue) {
          const msg = "Wi-Fi SSID is required before sending config.";
          setObserverStatus(msg, true);
          alert(msg);
          return;
        }
        const payloadLines = buildObserverEnvSnippet().split("\n").filter(Boolean);
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Select the observer serial port to send Wi-Fi config...";
          logEl.classList.add("active");
        }
        setObserverStatus("Waiting for serial port selection...", false);
        let port;
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          const writer = port.writable.getWriter();
          for (const line of payloadLines) {
            await writer.write(new TextEncoder().encode(line + "\r\n"));
            await new Promise((r) => setTimeout(r, 40));
          }
          writer.releaseLock();
          const reply = await readSerialOnce(port, 2000);
          if (reply && logEl) {
            logEl.textContent += "\nDevice replied:\n" + reply.trim();
          } else if (logEl) {
            logEl.textContent += "\nNo device reply detected. Check the serial port and power.";
          }
          await port.close();
          if (logEl) {
            logEl.textContent += "\nWi-Fi config sent. Device will reconnect using new settings.";
          }
        setObserverStatus("Wi-Fi config sent. Device will reconnect using new settings.", false);
        alert("Wi-Fi config sent.");
      } catch (err) {
        if (port && port.readable) {
          try { await port.close(); } catch {}
        }
        const msg = "Failed to send config: " + (err?.message || err);
        if (logEl) {
          logEl.textContent += "\n" + msg;
          logEl.classList.add("active");
        }
        setObserverStatus(msg, true);
        alert(msg);
      }
    }

    const observerSendBtn = document.getElementById("observerSendConfig");
    if (observerSendBtn) {
      observerSendBtn.addEventListener("click", () => {
        sendObserverConfig();
      });
    }

    function wireInstallLogging(button, verbose) {
      if (!button) return;
      const logEl = document.getElementById("installLog");
      const append = (msg) => {
        if (!logEl) return;
        logEl.classList.toggle("active", !!verbose);
        if (!verbose) return;
        const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logEl.textContent = (logEl.textContent || "").trim();
        logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + line;
        logEl.scrollTop = logEl.scrollHeight;
      };

      button.addEventListener("state-changed", (ev) => {
        const rawState = ev.detail?.state || "unknown";
        append(`state ${rawState}`);
        const state = String(rawState).toLowerCase();
        const isDone = ["finished", "installed", "done"].includes(state);
        if (observerAutoConfig && isDone) {
          observerAutoConfig = false;
          sendObserverConfig();
        }
      });
      button.addEventListener("log", (ev) => {
        append(ev.detail?.message || "log event");
      });
      button.addEventListener("error", (ev) => {
        append(`error ${ev.detail?.message || "unknown"}`);
      });
      button.addEventListener("click", () => {
        observerAutoConfig = true;
        if (logEl) {
          logEl.textContent = verbose ? "Verbose install log started..." : "Verbose install log ready.";
          logEl.classList.toggle("active", !!verbose);
        }
      });
    }

    wireInstallLogging(document.getElementById("observerFlash"), false);
    wireInstallLogging(document.getElementById("observerFlashVerbose"), true);

    const FLASH_BIN_URL = "/observer-merged-1.1.8.bin";
    const flashOpen = document.getElementById("observerFlashLink");
    const flashHide = document.getElementById("flashHide");
    const flashStart = document.getElementById("flashStart");
    const flashLog = document.getElementById("flashLog");
    const flashPanel = document.getElementById("flashPanel");

    function setFlashLog(msg) {
      flashLog.textContent = msg;
    }

    function appendFlashLog(line) {
      flashLog.textContent += `\n${line}`;
      flashLog.scrollTop = flashLog.scrollHeight;
    }

    function openFlashPanel() {
      flashPanel.classList.add("open");
      setFlashLog("Ready to flash.");
    }

    function closeFlashPanel() {
      flashPanel.classList.remove("open");
    }

    flashOpen?.addEventListener("click", openFlashPanel);
    flashHide?.addEventListener("click", closeFlashPanel);

    flashStart?.addEventListener("click", async () => {
      if (!navigator.serial) {
        setFlashLog("WebSerial is not supported in this browser. Use Chrome or Edge.");
        return;
      }

      flashStart.disabled = true;
      flashHide.disabled = true;
      setFlashLog("Downloading firmware...");

      try {
        const res = await fetch(FLASH_BIN_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`download failed (${res.status})`);
        const bin = new Uint8Array(await res.arrayBuffer());
        appendFlashLog(`Downloaded ${bin.byteLength} bytes.`);
        appendFlashLog("Preparing firmware...");
        appendFlashLog(`Firmware header: 0x${bin[0]?.toString(16).padStart(2, "0")}`);
        if (bin[0] === 0xe9) {
          const oldMode = bin[2];
          const oldFreqSize = bin[3];
          const newMode = 0x02; // DIO
          const newFreqSize = (oldFreqSize & 0xf0) | 0x00; // 40MHz
          if (oldMode !== newMode || oldFreqSize !== newFreqSize) {
            bin[2] = newMode;
            bin[3] = newFreqSize;
            appendFlashLog(`Patched header: mode 0x${oldMode.toString(16)}->0x${newMode.toString(16)}, freq 0x${oldFreqSize.toString(16)}->0x${newFreqSize.toString(16)}`);
          } else {
            appendFlashLog("Header already set for DIO/40MHz.");
          }
        }
        let binStr = "";
        for (let i = 0; i < bin.length; i++) {
          binStr += String.fromCharCode(bin[i]);
        }

        appendFlashLog("Requesting serial port...");
        const port = await navigator.serial.requestPort();
        appendFlashLog("Connecting to device...");

        let esptool;
        try {
          esptool = await import("/esp32.js");
        } catch (err) {
          try {
            esptool = await import("https://unpkg.com/esptool-js@0.5.4/bundle.js");
          } catch (err2) {
            esptool = await import("https://cdn.jsdelivr.net/npm/esptool-js@0.5.4/bundle.js");
          }
        }
        const transport = new esptool.Transport(port, true);
        const flashOptions = {
          transport,
          baudrate: 115200,
          romBaudrate: 115200,
          terminal: {
            clean: () => {},
            writeLine: appendFlashLog,
            write: (data) => appendFlashLog(String(data || "").trimEnd())
          },
          fileArray: [{ data: binStr, address: 0x0 }],
          flashSize: "keep",
          flashMode: "keep",
          flashFreq: "keep",
          compress: true
        };
        const loader = new esptool.ESPLoader(flashOptions);
        try {
          loader.hr = new esptool.HardReset(transport);
        } catch {}

        await loader.main();
        try {
          await loader.flashId?.();
        } catch {}
        try {
          if (typeof loader.chipName === "function") {
            appendFlashLog(`Chip: ${loader.chipName()}`);
          }
        } catch {}
        appendFlashLog("Erasing flash...");
        await loader.eraseFlash();
        appendFlashLog("Writing firmware...");

        await loader.writeFlash(flashOptions);

        appendFlashLog("Verifying header...");
        try {
          const verify = await loader.readFlash(0x0, 16);
          let ok = verify.length === 16;
          let mismatchAt = -1;
          for (let i = 0; i < 16 && ok; i++) {
            if (verify[i] !== bin[i]) {
              ok = false;
              mismatchAt = i;
            }
          }
          if (ok) {
            appendFlashLog("Header verify OK.");
          } else {
            const got = Array.from(verify).map((b) => b.toString(16).padStart(2, "0")).join("");
            const want = Array.from(bin.slice(0, 16)).map((b) => b.toString(16).padStart(2, "0")).join("");
            appendFlashLog(`Header verify mismatch at byte ${mismatchAt}: got 0x${got}, expected 0x${want}`);
          }
        } catch (err) {
          appendFlashLog(`Header verify failed: ${err?.message || err}`);
        }

        appendFlashLog("Flash complete. Rebooting...");
        try {
          await loader.after?.("hard_reset");
        } catch {}
        try {
          await transport.setRTS(true);
          await new Promise((resolve) => setTimeout(resolve, 100));
          await transport.setRTS(false);
        } catch {}
        await transport.disconnect();
        appendFlashLog("Done. You can now send Wi-Fi config.");
      } catch (err) {
        appendFlashLog(`Error: ${err?.message || err}`);
      } finally {
        flashStart.disabled = false;
        flashHide.disabled = false;
      }
    });

    const observerFlashBtn = document.getElementById("observerFlashBtn");
    const observerFlashVerboseBtn = document.getElementById("observerFlashVerboseBtn");
    const observerFlash = document.getElementById("observerFlash");
    const observerFlashVerbose = document.getElementById("observerFlashVerbose");

    if (observerFlashBtn && observerFlash) {
      observerFlashBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) logEl.classList.remove("active");
        observerFlash.click();
      });
    }

    if (observerFlashVerboseBtn && observerFlashVerbose) {
      observerFlashVerboseBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Verbose install log started...";
          logEl.classList.add("active");
        }
        observerFlashVerbose.click();
      });
    }

    const rangeTabs = document.getElementById("meshRangeTabs");
    if (rangeTabs) {
      rangeTabs.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-range]");
        if (!btn) return;
        rangeTabs.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        meshRangeDays = Number(btn.dataset.range || 7);
        if (!appData.meshScore) {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        } else {
          renderMeshScore(appData.meshScore, meshRangeDays);
        }
      });
    }

    function setServerStatus(ok) {
      const dot = document.getElementById("serverStatus");
      if (!dot) return;
      dot.classList.toggle("ok", !!ok);
    }

    const themeToggle = document.getElementById("themeToggle");
    const themeKey = "meshrank.theme";
    function applyTheme(theme) {
      const isDark = theme === "dark";
      document.body.classList.toggle("theme-dark", isDark);
      if (themeToggle) {
        themeToggle.setAttribute("aria-pressed", String(isDark));
        themeToggle.textContent = isDark ? "Light mode" : "Dark mode";
      }
    }
    const storedTheme = localStorage.getItem(themeKey);
    const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;
    applyTheme(storedTheme || (prefersDark ? "dark" : "light"));
    themeToggle?.addEventListener("click", () => {
      const nextTheme = document.body.classList.contains("theme-dark") ? "light" : "dark";
      localStorage.setItem(themeKey, nextTheme);
      applyTheme(nextTheme);
    });

    loadReadState();
    appData.channelHistoryLimit = loadChannelHistoryLimit();
    initChannelHistoryControl();
    const rankSearch = document.getElementById("rankSearch");
    if (rankSearch) {
      rankSearch.addEventListener("input", () => {
        appData.rankFilter = rankSearch.value.trim();
        if (appData.rankData) {
          const payload = appData.rankPayload || { items: appData.rankData };
          renderRankWithOptions({ ...payload, items: appData.rankData }, { preserveView: true });
        }
      });
    }

    const rankList = document.getElementById("rankList");
    if (rankList) {
      rankList.addEventListener("click", async (event) => {
        const btn = event.target.closest("[data-repeater-locate]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-locate") || "").trim().toUpperCase();
        if (!pub) return;
        const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
        if (!entry) return;
        openRepeaterLocationModal(entry);
      });
    }

    if (rankList) {
      rankList.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-repeater-neighbors]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-neighbors") || "").trim().toUpperCase();
        if (!pub) return;
        const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
        if (!entry) return;
        openNeighborMapModal(entry);
      });
    }

    if (rankList) {
      rankList.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-repeater-pub]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-pub") || "").trim().toUpperCase();
        if (!pub) return;
        window.prompt("Public key", pub);
      });
    }

    const rotmLeaderboard = document.getElementById("rotmLeaderboard");
    if (rotmLeaderboard) {
      rotmLeaderboard.addEventListener("click", (event) => {
        const row = event.target.closest("[data-rotm-node]");
        if (!row) return;
        event.preventDefault();
        event.stopPropagation();
        const nodeKey = row.getAttribute("data-rotm-node");
        if (!nodeKey) return;
        selectRotmNode(nodeKey);
      });
    }
    const rotmChannelSave = document.getElementById("rotmChannelSave");
    if (rotmChannelSave) {
      rotmChannelSave.addEventListener("click", async () => {
        const channelInput = document.getElementById("rotmChannelName");
        const secretInput = document.getElementById("rotmChannelSecret");
        const status = document.getElementById("rotmChannelStatus");
        const channel = channelInput?.value?.trim() || "";
        const secretHex = secretInput?.value?.trim() || "";
        if (!channel) {
          if (status) status.textContent = "Channel name is required.";
          return;
        }
        if (status) status.textContent = "Saving...";
        try {
          const res = await fetch("/api/rotm-config", {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ channel, secretHex })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) throw new Error(data.error || `HTTP ${res.status}`);
          if (status) status.textContent = `Saved: ${data.channel || channel}. Secret is stored until you update it.`;
          if (secretInput) secretInput.value = "";
          appData.rotmConfigLoaded = true;
          if (data.channel) appData.rotmChannelName = data.channel;
          await loadRotm();
        } catch (err) {
          if (status) status.textContent = `Save failed: ${err?.message || err}`;
        }
      });
    }

    document.addEventListener("click", async (event) => {
      const flagBtn = event.target.closest("[data-repeater-flag]");
      if (flagBtn) {
        event.preventDefault();
        event.stopPropagation();
        const pub = String(flagBtn.getAttribute("data-repeater-flag") || "").trim().toUpperCase();
        if (!pub) return;
        const confirmed = window.confirm("Flag this repeater as wrong location?\n\nIt will be removed from the map and reviewed over the next 24 hours.");
        if (!confirmed) return;
        try {
          const res = await fetch("/api/repeater-flag", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ pub, flagged: true })
          });
          if (!res.ok) throw new Error("HTTP " + res.status);
          if (rankMap) rankMap.closePopup();
          await loadRankDefault();
          fetchRankSummary().then(renderRankSummary).catch(() => {});
        } catch (err) {
          alert("Unable to flag location: " + (err?.message || err));
        }
        return;
      }
      const correctBtn = event.target.closest("[data-repeater-correct]");
      if (!correctBtn) return;
      event.preventDefault();
      event.stopPropagation();
      const pub = String(correctBtn.getAttribute("data-repeater-correct") || "").trim().toUpperCase();
      if (!pub) return;
      const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
      if (!entry) return;
      try {
        await fetch("/api/repeater-flag", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pub, flagged: true })
        });
        await loadRankDefault();
        fetchRankSummary().then(renderRankSummary).catch(() => {});
      } catch {}
      openRepeaterLocationModal(entry);
    });

    const rfSearch = document.getElementById("rfSearch");
    const rfTypeFilter = document.getElementById("rfTypeFilter");
    if (rfSearch) rfSearch.addEventListener("input", renderRfList);
    if (rfTypeFilter) rfTypeFilter.addEventListener("change", renderRfList);
    if (document.getElementById("rfList")) {
      document.getElementById("rfList").addEventListener("click", (event) => {
        const toggle = event.target.closest("[data-rf-toggle]");
        if (!toggle) return;
        event.preventDefault();
        event.stopPropagation();
        const key = toggle.getAttribute("data-rf-toggle");
        if (!key) return;
        const children = document.querySelectorAll(`.rf-row.rf-child[data-parent-key="${CSS.escape(key)}"]`);
        if (!children.length) return;
        const isHidden = children[0].classList.contains("is-hidden");
        children.forEach((child) => child.classList.toggle("is-hidden", !isHidden));
        toggle.textContent = isHidden ? "" : "+";
      });
    }

    window.addEventListener("resize", () => {
      if (observerMap) observerMap.invalidateSize();
      if (rankMap) rankMap.invalidateSize();
    });
  </script>
  <div id="messageRouteOverlay" class="rank-detail-overlay" onclick="closeMessageRouteOverlay()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="messageRouteContent"></div>
    </div>
  </div>
  <div id="rankDetailOverlay" class="rank-detail-overlay" onclick="closeRankDetail()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="rankDetailContent"></div>
    </div>
  </div>
</body>
</html>
