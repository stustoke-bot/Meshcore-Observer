<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta http-equiv="cache-control" content="no-store, no-cache, must-revalidate, max-age=0"/>
  <meta http-equiv="pragma" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <title>MeshRank</title>
  <script>
    window.meshConfig = {
      googleClientId: "__GOOGLE_CLIENT_ID__"
    };
  </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7XB43YJ3QW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-7XB43YJ3QW');
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --ink: #0a0b0e;
      --paper: #f2f2f7;
      --panel: #ffffff;
      --line: rgba(60, 60, 67, 0.12);
      --blue: #007aff;
      --blue-dark: #0a60d1;
      --green: #34c759;
      --green-dark: #248a3d;
      --muted: rgba(60, 60, 67, 0.6);
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }

    body.theme-dark {
      --ink: #e8eef9;
      --paper: #0b0f15;
      --panel: #131a24;
      --line: rgba(231, 238, 251, 0.08);
      --blue: #63a2ff;
      --blue-dark: #2f6bd6;
      --green: #48d06a;
      --green-dark: #2aa24a;
      --muted: rgba(231, 238, 251, 0.62);
      --shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", system-ui, sans-serif;
      background:
        radial-gradient(1000px 520px at 85% -10%, rgba(0, 122, 255, 0.14) 0%, rgba(0, 122, 255, 0) 60%),
        radial-gradient(900px 520px at -10% 15%, rgba(52, 199, 89, 0.12) 0%, rgba(52, 199, 89, 0) 60%),
        var(--paper);
      color: var(--ink);
      height: 100vh;
      overflow: hidden;
    }
    body.theme-dark {
      background:
        radial-gradient(900px 520px at 85% -10%, rgba(99, 162, 255, 0.18) 0%, rgba(11, 15, 21, 0) 60%),
        radial-gradient(800px 520px at -10% 20%, rgba(72, 208, 106, 0.16) 0%, rgba(11, 15, 21, 0) 60%),
        var(--paper);
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 420px 1fr;
      gap: 16px;
      padding: 16px;
      height: 100vh;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .node-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      transition: opacity 0.15s ease;
    }
    .node-controls.hidden {
      display: none;
    }
    .node-connection-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff3b30;
      display: inline-flex;
      margin-right: 6px;
    }
    .node-connection-dot.connected {
      background: var(--green);
    }
    .node-status-text {
      font-size: 12px;
      color: var(--muted);
      margin-left: 8px;
    }
    .node-composer {
      border-top: 1px solid var(--line);
      padding: 12px;
      background: var(--panel);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .node-composer textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--line);
      padding: 10px;
      font-family: "Space Grotesk", system-ui, sans-serif;
      min-height: 70px;
      resize: vertical;
      background: var(--paper);
      color: var(--ink);
    }
    .node-composer textarea:disabled {
      opacity: 0.6;
      background: rgba(0, 0, 0, 0.04);
    }
    .node-composer-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .node-composer .composer-status {
      font-size: 12px;
      color: var(--muted);
    }
    .message-mesh .bubble {
      border-color: var(--green);
      background: rgba(52, 199, 89, 0.08);
    }
    .message-internet .bubble {
      border-color: var(--blue);
      background: rgba(0, 122, 255, 0.08);
    }
    .message-mesh .meta .badge.mesh-badge,
    .message-internet .meta .badge.internet-badge {
      font-size: 10px;
      letter-spacing: 0.05em;
    }
    .badge.mesh-badge {
      background: var(--green);
      color: #fff;
    }
    .badge.internet-badge {
      background: var(--blue);
      color: #fff;
    }
    .msg-failed {
      font-size: 12px;
      color: #ff3b30;
    }

    .mesh-live-panel {
      display: none;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
      border-radius: 18px;
    }
    .mesh-live-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .mesh-live-title {
      font-size: 20px;
      font-weight: 600;
    }
    .mesh-live-header .muted {
      margin: 4px 0 0;
    }
    .mesh-live-daily {
      min-width: 220px;
      font-size: 14px;
      color: var(--muted);
      background: rgba(0, 122, 255, 0.08);
      border-radius: 12px;
      padding: 12px;
    }
    .mesh-live-grid {
      display: grid;
      grid-template-columns: minmax(280px, 1fr) minmax(220px, 320px);
      gap: 16px;
    }
    .mesh-live-stats {
      display: grid;
      gap: 12px;
    }
    .mesh-live-card {
      background: rgba(0, 0, 0, 0.03);
      border-radius: 14px;
      padding: 14px 16px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .accordion .mesh-live-card {
      border-color: var(--line);
    }
    .mesh-live-card strong {
      font-size: 28px;
      line-height: 1.2;
    }
    .mesh-live-card-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    /* Map removed: stats-only view */
    .mesh-live-right-pane {
      display: grid;
      gap: 16px;
    }
    .mesh-live-visitor-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    .visitor-card {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(0, 0, 0, 0.02);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .visitor-card strong {
      font-size: 26px;
      line-height: 1.1;
    }
    .visitor-label {
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .visitor-note {
      font-size: 13px;
      color: var(--muted);
    }
    .mesh-live-list-wrapper {
      background: rgba(0, 122, 255, 0.03);
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(0, 122, 255, 0.12);
    }
    .mesh-live-list-title {
      font-weight: 600;
      margin-bottom: 8px;
    }
    .mesh-live-list {
      display: grid;
      gap: 8px;
      max-height: 220px;
      overflow-y: auto;
    }
    .mesh-live-list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
      gap: 10px;
    }
    .mesh-live-list-item strong {
      font-size: 14px;
      line-height: 1.2;
    }
    .mesh-live-list-item .mesh-live-badge {
      background: rgba(0, 122, 255, 0.12);
      color: var(--blue);
      font-size: 11px;
      border-radius: 999px;
      padding: 2px 8px;
    }
    @media (max-width: 960px) {
      .mesh-live-grid {
        grid-template-columns: 1fr;
      }
    }
    .sidebar-panel {
      min-height: 0;
    }

    .topbar {
      grid-column: 1 / -1;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      padding: 2px 12px;
      gap: 12px;
      min-height: 48px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      flex: 0 0 auto;
    }

    .brand-logo {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: block;
      overflow: hidden;
      border: none;
    }

    .brand-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display: block;
      min-width: 0;
    }

    .brand-text {
      display: grid;
      gap: 2px;
      line-height: 1.1;
    }

    .brand-text strong {
      font-size: 16px;
    }

    .brand-text span {
      font-size: 12px;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      background: #ff3b30;
      box-shadow: 0 0 0 4px rgba(255, 59, 48, 0.15);
    }

    .status-dot.ok {
      background: #34c759;
      box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.15);
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-weight: 600;
      color: var(--muted);
      margin-left: auto;
    }

    .nav a {
      color: inherit;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .nav a.active {
      color: var(--ink);
      background: rgba(0, 122, 255, 0.12);
    }
    .nav [data-view="node-rank"],
    .mobile-menu [data-view="node-rank"] {
      display: none;
    }
    .menu-toggle {
      display: none;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 10px;
      padding: 0;
      width: 38px;
      height: 34px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }
    .menu-toggle .burger {
      width: 18px;
      height: 12px;
      display: inline-flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .menu-toggle .burger span {
      display: block;
      height: 2px;
      border-radius: 999px;
      background: var(--ink);
    }
    .menu-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 900;
    }
    .mobile-menu {
      display: none;
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 12px;
      width: min(86vw, 320px);
      z-index: 950;
      border: 1px solid var(--line);
      border-radius: 12px 0 0 12px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 10px;
      gap: 6px;
      flex-direction: column;
      align-items: stretch;
      transform: translateX(110%);
      transition: transform 0.2s ease;
      overflow: auto;
    }
    .mobile-menu a {
      display: block;
      padding: 8px 10px;
      border-radius: 10px;
      text-decoration: none;
      color: var(--ink);
      font-weight: 600;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-menu a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .mobile-nav {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
    }
    .mobile-nav a {
      color: var(--ink);
      text-decoration: none;
      font-weight: 600;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-nav a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .theme-toggle {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .theme-toggle:hover { color: var(--blue); border-color: var(--blue); }
    .theme-toggle:focus-visible { outline: 2px solid var(--blue); outline-offset: 2px; }

    .sidebar {
      padding: 14px 12px;
      gap: 10px;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
      flex: 1 1 auto;
      max-height: 100%;
    }

    .sidebar-helper {
      display: none;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(0, 122, 255, 0.3);
      background: rgba(0, 122, 255, 0.08);
      color: var(--ink);
      font-size: 13px;
      line-height: 1.4;
    }
    .sidebar-helper p {
      margin: 6px 0 0;
      font-weight: 400;
    }
    body.theme-dark .sidebar-helper {
      border-color: rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.05);
    }

    #channels {
      display: grid;
      gap: 10px;
      overflow-x: hidden;
    }

    .title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .content .title {
      position: sticky;
      top: 0;
      z-index: 4;
      background: var(--panel);
    }
    .channel-title {
      justify-content: space-between;
      gap: 8px;
    }
    .channel-title-label {
      font-weight: 700;
    }

    .title.column {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }

    .chip {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      font-weight: 600;
    }
    .chip-strong {
      color: var(--ink);
      font-weight: 700;
      border-color: rgba(60, 60, 67, 0.35);
      background: rgba(0, 0, 0, 0.06);
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(0, 122, 255, 0.18);
    }

    .btn.primary {
      background: var(--blue);
      color: #fff;
    }

    .btn.primary:hover {
      background: var(--blue-dark);
    }

    .channel {
      display: grid;
      grid-template-columns: 44px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
      overflow: hidden;
    }
    .channel > div { min-width: 0; }

    .channel.active {
      background: #e8f0ff;
      border-color: rgba(11, 95, 255, 0.2);
    }
    body.theme-dark .channel.active {
      background: rgba(99, 162, 255, 0.16);
      border-color: rgba(99, 162, 255, 0.4);
    }

    .channel.unread .name {
      font-weight: 800;
    }

    .badge-bubble {
      min-width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #007aff;
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
    }

    .channel .name {
      font-weight: 700;
      overflow: visible;
      text-overflow: unset;
      white-space: normal;
      overflow-wrap: anywhere;
    }

    .channel .snippet {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .channel .muted {
      color: var(--muted);
      font-size: 10px;
      line-height: 1.2;
      white-space: nowrap;
    }

    .channel-meta {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-top: 4px;
      min-width: 0;
    }
    .channel-meta .snippet {
      flex: 1 1 auto;
      min-width: 0;
    }
    .channel-time {
      font-size: 10px;
      color: var(--muted);
      white-space: nowrap;
    }

    .content {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .channel-selector {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }
    @media (min-width: 861px) {
      .channel-selector { display: none; }
    }
    @media (max-width: 860px) {
      .channel-title-label { display: none; }
    }
    .channel-selector .badge-bubble {
      min-width: 18px;
      height: 18px;
      border-radius: 999px;
      background: var(--blue);
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
    }
    .channels-rail {
      display: none;
      position: fixed;
      left: 6px;
      top: 120px;
      z-index: 9;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      gap: 6px;
      align-items: center;
      font-weight: 700;
      cursor: pointer;
    }
    .channels-rail .badge-bubble { display: inline-flex; }

    .messages {
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow: auto;
    }

    .message {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      animation: slideIn 400ms ease-out;
      min-width: 0;
    }

    .message .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .bubble {
      padding: 10px 14px;
      border-radius: 14px;
      max-width: 520px;
      color: #fff;
      font-weight: 500;
      line-height: 1.35;
      box-shadow: 0 10px 24px rgba(10, 11, 14, 0.16);
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .bubble.mesh {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
    }

    .bubble.observer {
      background: linear-gradient(135deg, var(--green), var(--green-dark));
    }

    .bubble.mixed {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
      outline: 2px solid var(--green);
    }

    .msg-footer {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .msg-footer a {
      text-decoration: underline;
    }
    .observer-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 200, 83, 0.35);
      background: rgba(0, 200, 83, 0.12);
      color: #00a849;
      font-size: 11px;
      font-weight: 700;
    }
    .repeater-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 122, 255, 0.35);
      background: rgba(0, 122, 255, 0.12);
      color: #007aff;
      font-size: 11px;
      font-weight: 700;
    }

    .msg-hops {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-hops:hover { text-decoration: underline; }

    .msg-observers {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-observers:hover { text-decoration: underline; }
    .msg-confidence {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
      cursor: pointer;
    }
    .msg-confidence:hover { text-decoration: underline; }

    .analysis {
      display: grid;
      grid-template-rows: 240px 1fr;
      min-height: 0;
    }
    .route-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      z-index: 9;
    }
    .rank-detail-overlay {
      position: fixed;
      inset: 0;
      display: none;
      background: rgba(0, 0, 0, 0.4);
      align-items: center;
      justify-content: center;
      z-index: 900;
    }
    .rank-detail-overlay.open {
      display: flex;
    }
    .rank-detail-card {
      background: var(--panel);
      border-radius: 18px;
      padding: 20px;
      width: min(95vw, 820px);
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
    }
    .implausible-list {
      display: grid;
      gap: 10px;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 4px;
    }
    .implausible-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.02);
      font-size: 13px;
    }
    body.theme-dark .implausible-row {
      background: rgba(255, 255, 255, 0.04);
    }
    .implausible-title {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .implausible-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      font-size: 12px;
      color: var(--muted);
    }
    .implausible-reason {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .implausible-placeholder {
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 14px;
    }
    .rank-detail-close {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 12px;
    }
    .rank-detail-close button {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
    }
    .confidence-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .confidence-meta {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 10px;
    }
    .confidence-map {
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      height: 320px;
      margin-bottom: 12px;
    }
    #confidenceMap {
      width: 100%;
      height: 100%;
    }
    .confidence-deadends {
      display: grid;
      gap: 8px;
    }
    .confidence-deadend {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
    }
    .confidence-deadend strong {
      color: var(--ink);
      font-weight: 600;
    }
    .route-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 0;
      font-size: 12px;
      color: var(--muted);
    }
    .route-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.04);
    }
    .route-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    .neighbor-map-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .neighbor-map-modal.open { display: flex; }
    .neighbor-map-card {
      width: min(92vw, 720px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      padding: 14px;
      max-height: 90vh;
      overflow: hidden;
    }
    .neighbor-map {
      height: 320px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--line);
    }

    .neighbor-map-list {
      margin-top: 12px;
      display: grid;
      gap: 8px;
      max-height: 32vh;
      overflow: auto;
      padding-right: 4px;
    }

    .neighbor-map-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.02);
      font-size: 12px;
    }

    body.theme-dark .neighbor-map-item {
      background: rgba(255, 255, 255, 0.04);
    }

    .neighbor-map-item .neighbor-meta {
      color: var(--muted);
      font-size: 11px;
    }
    .neighbor-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .neighbor-badge-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .neighbor-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
    }
    .neighbor-badge {
      margin-left: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 600;
      color: #fff;
    }
    .neighbor-badge.reciprocal {
      background: #34c759;
    }
    .neighbor-badge.incoming {
      background: rgba(0, 122, 255, 0.9);
    }
    .neighbor-badge.outgoing {
      background: rgba(255, 149, 0, 0.95);
    }
    .neighbor-map-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .neighbor-map-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.04);
    }
    .neighbor-map-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .node-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rotm-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .rotm-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      overflow: auto;
    }

    .rotm-info-link {
      font-size: inherit;
      font-weight: 700;
      color: var(--blue-dark);
      cursor: pointer;
      border: 0;
      background: transparent;
      padding: 0;
    }

    .rotm-grid {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      min-height: 70vh;
    }

    .rotm-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 520px;
      background: var(--panel);
    }

    .rotm-card-title {
      font-weight: 700;
      font-size: 14px;
    }

    .rotm-settings {
      display: grid;
      gap: 10px;
    }

    .rotm-settings-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .rotm-settings-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .rotm-settings-note {
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-feed {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
      padding-right: 6px;
      min-height: 420px;
    }

    .rotm-feed-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) auto;
      gap: 12px;
      align-items: start;
      background: rgba(0, 0, 0, 0.02);
    }

    body.theme-dark .rotm-feed-row {
      background: rgba(255, 255, 255, 0.03);
    }

    .rotm-feed-row-compact {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 12px;
      display: flex;
      gap: 12px;
      align-items: flex-start;
      background: rgba(0, 0, 0, 0.02);
      font-family: 'Courier New', 'Monaco', monospace;
      font-size: 13px;
      line-height: 1.6;
    }

    body.theme-dark .rotm-feed-row-compact {
      background: rgba(255, 255, 255, 0.03);
    }

    .rotm-feed-time {
      color: var(--muted);
      font-weight: 600;
      min-width: 60px;
      flex-shrink: 0;
    }

    .rotm-feed-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .rotm-feed-line {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .rotm-feed-cq,
    .rotm-feed-repeater,
    .rotm-feed-response {
      color: var(--ink);
      font-weight: 500;
    }

    .rotm-feed-stats-compact {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }

    .rotm-feed-timer-compact {
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
    }

    .rotm-feed-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-feed-sender {
      font-weight: 700;
      color: var(--ink);
    }

    .rotm-feed-body {
      font-size: 12px;
      line-height: 1.45;
    }

    .rotm-feed-col {
      display: grid;
      gap: 6px;
    }

    .rotm-feed-col-title {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .rotm-feed-timer {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      text-align: right;
    }

    .rotm-badge {
      align-self: flex-start;
      font-size: 11px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(60, 60, 67, 0.12);
      color: var(--muted);
    }

    .rotm-badge.ok {
      background: #d7f3e2;
      color: #1f6d39;
    }

    .rotm-badge.cq {
      background: #e0ecff;
      color: #0a60d1;
    }

    .rotm-badge.response {
      background: #fff1da;
      color: #a86400;
    }

    .rotm-repeater-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 999px;
      background: #fff1da;
      color: #a86400;
    }

    .rotm-repeater-badge.ok {
      background: #d7f3e2;
      color: #1f6d39;
    }

    body.theme-dark .rotm-repeater-badge {
      background: rgba(255, 149, 0, 0.2);
      color: #ffd08a;
    }

    body.theme-dark .rotm-repeater-badge.ok {
      background: rgba(52, 199, 89, 0.2);
      color: #7ae6a1;
    }

    .rotm-feed-stats {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px;
    }

    body.theme-dark .rotm-badge.ok { background: rgba(52, 199, 89, 0.2); color: #7ae6a1; }
    body.theme-dark .rotm-badge.cq { background: rgba(0, 122, 255, 0.2); color: #9dc1ff; }
    body.theme-dark .rotm-badge.response { background: rgba(255, 149, 0, 0.2); color: #ffd08a; }

    .rotm-leaderboard {
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: auto;
      min-height: 420px;
    }

    .rotm-leader-row {
      display: grid;
      grid-template-columns: 36px 1fr 120px 70px 110px;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      cursor: pointer;
    }

    .rotm-leader-header {
      cursor: default;
      background: rgba(0, 0, 0, 0.02);
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
    }

    body.theme-dark .rotm-leader-header {
      background: rgba(255, 255, 255, 0.04);
    }

    .rotm-leader-row.active {
      border-color: var(--blue);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.15);
    }

    .rotm-leader-rank {
      font-weight: 700;
      color: var(--muted);
    }

    .rotm-leader-node {
      font-weight: 700;
    }

    .rotm-leader-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-map-title {
      font-weight: 700;
      font-size: 13px;
    }

    #rotmQsoMap {
      width: 100%;
      height: 320px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--line);
    }

    .rotm-claim-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .rotm-claim-chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.02);
    }

    body.theme-dark .rotm-claim-chip {
      background: rgba(255, 255, 255, 0.05);
    }

    .rotm-qso-log {
      max-height: 360px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
    }

    .rotm-qso-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      background: transparent;
    }

    .rotm-qso-table th,
    .rotm-qso-table td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--line);
      text-align: left;
      vertical-align: top;
    }

    .rotm-qso-table th {
      position: sticky;
      top: 0;
      background: var(--panel);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    body.theme-dark .rotm-qso-table th {
      background: var(--panel);
    }

    .rotm-qso-table tr:last-child td {
      border-bottom: 0;
    }

    .rotm-qso-msg {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .rotm-qso-override {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .rotm-qso-select {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 12px;
      background: var(--panel);
      color: inherit;
    }

    .rotm-qso-note {
      font-size: 11px;
      color: var(--muted);
    }

    .rank-body {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rank-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
    }

    .rank-helper-row {
      padding: 8px 14px;
      border-bottom: 1px solid var(--line);
      background: #f8f8f8;
      text-align: right;
    }

    body.theme-dark .rank-helper-row {
      background: var(--panel);
    }

    .rank-helper-row .link-btn {
      font-size: 13px;
      padding: 4px 10px;
    }

      .summary-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        background: #ffffff;
        display: grid;
        gap: 4px;
        font-size: 12px;
        color: var(--muted);
      }

    .summary-card strong {
      font-size: 16px;
      color: var(--ink);
    }

    .rank-map {
      border-radius: 16px;
      border: 1px solid var(--line);
      overflow: hidden;
      min-height: 360px;
      display: flex;
      flex-direction: column;
    }

    .rank-map-note {
      font-size: 13px;
      color: var(--muted);
      padding: 12px 16px 0;
      line-height: 1.4;
      text-align: center;
    }

    #rankMap {
      width: 100%;
      flex: 1;
      min-height: 320px;
      height: auto;
    }

    #observerRankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    .rank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      height: 100%;
    }

    .rank-search {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
      outline: none;
      box-shadow: 0 6px 16px rgba(10, 11, 14, 0.06);
      margin-bottom: 6px;
    }

    .share-landing {
      position: fixed;
      inset: 0;
      background: rgba(5, 7, 12, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 32px 16px;
      z-index: 2000;
    }
    body.share-active .share-landing {
      display: flex;
    }
    body.share-active {
      height: auto;
      overflow: auto;
    }
    body.share-active .app,
    body.share-active .menu-backdrop,
    body.share-active .route-backdrop {
      display: none;
    }
    .share-card {
      width: min(760px, 100%);
      background: var(--panel);
      border-radius: 18px;
      padding: 28px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .share-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
    }
    .share-title {
      font-size: 22px;
      font-weight: 600;
    }
    .share-subtitle {
      font-size: 13px;
      color: var(--muted);
    }
    .share-status {
      font-size: 13px;
      color: var(--muted);
    }
    .share-error {
      color: #ff2d55;
      font-size: 13px;
      min-height: 20px;
    }
    .share-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .share-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }
    .share-row strong {
      font-size: 14px;
      color: var(--ink);
    }
    .share-path {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 240px;
      overflow-y: auto;
    }
    .share-path-item {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.02);
    }
    .share-observers {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      max-height: 160px;
      overflow-y: auto;
    }
    .share-observer {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.03);
    }
    .share-actions {
      display: flex;
      justify-content: flex-end;
    }
    .share-close {
      border: none;
      background: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
    }

    .rank-loading {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #ffffff;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .rank-loading.active {
      display: flex;
    }

    .rank-loading .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, 0.15);
      border-top-color: var(--blue);
      animation: rankSpin 1s linear infinite;
    }

    @keyframes rankSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }

    .rank-status {
      display: none;
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.04);
      margin-top: 8px;
    }

    .rank-status.active {
      display: block;
    }

    .rank-skeleton {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      animation: pulse 1.2s ease-in-out infinite;
    }

    .rank-skeleton-dot {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.08);
    }

    .rank-skeleton-lines {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .rank-skeleton-lines span {
      height: 10px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.08);
    }

    .rank-skeleton-lines span:nth-child(2) {
      width: 60%;
    }

    .rank-skeleton-lines span:nth-child(3) {
      width: 40%;
    }

    .rank-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-top: 8px;
    }

    .rank-marker-toggle label {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }


    .rank-debug {
      display: none;
      position: fixed;
      bottom: 16px;
      right: 16px;
      z-index: 1000;
      padding: 10px 12px;
      background: rgba(32, 32, 32, 0.9);
      color: #fff;
      font-size: 11px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      line-height: 1.4;
      min-width: 150px;
    }

    .rank-scroll {
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      flex: 1;
    }

    .rank-search::placeholder {
      color: rgba(60, 60, 67, 0.45);
    }
    .rank-search-hint {
      font-size: 11px;
      color: var(--muted);
      min-height: 18px;
      line-height: 1.3;
    }

    .rank-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
      background: #fafafa;
    }


    .rank-item.hidden {
      opacity: 0.45;
      filter: grayscale(0.4);
    }

    .rank-item.focused {
      border-color: rgba(0, 122, 255, 0.4);
      background: rgba(0, 122, 255, 0.1);
      box-shadow: 0 10px 24px rgba(0, 122, 255, 0.18);
    }

    .rank-item .row {
      font-size: 12px;
      color: var(--muted);
    }

    .rank-item .score {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .rank-dot {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: #fff;
    }

    .meshscore-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-body {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rf-table {
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .rf-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #ffffff;
    }

    .rf-input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      font-family: "IBM Plex Mono", monospace;
      background: var(--panel);
      color: var(--ink);
    }

    .rf-list {
      overflow: auto;
      min-height: 0;
    }

    .rf-row {
      display: grid;
      grid-template-columns: 90px 110px 90px 140px minmax(160px, 2fr) 140px 60px 60px 60px 60px 70px;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 12px;
      cursor: pointer;
      align-items: center;
    }
    .rf-row.rf-child {
      font-size: 11px;
      opacity: 0.85;
      padding-left: 28px;
      cursor: default;
    }
    .rf-row.rf-child:hover { background: transparent; }
    .rf-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--ink);
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
    }
    .rf-row.rf-child.is-hidden { display: none; }

    .rf-row:hover {
      background: #f7f7f7;
    }

    .rf-row.rf-header {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f4f6fb;
      font-weight: 700;
      color: #5b6b84;
      cursor: default;
    }

    .rf-type {
      font-weight: 700;
      color: #fff;
      border-radius: 8px;
      padding: 2px 6px;
      display: inline-flex;
      justify-content: center;
      background: #007aff;
      font-size: 11px;
    }

    .rf-detail {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      overflow: auto;
      min-height: 0;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .rf-summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
      font-size: 12px;
      color: var(--muted);
    }

    .rf-summary strong {
      display: block;
      color: var(--ink);
      font-size: 14px;
      margin-top: 2px;
    }

    .rf-hex {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      background: #f7f7f7;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      word-break: break-all;
    }

    .rf-kv {
      font-size: 12px;
      color: var(--muted);
      display: grid;
      gap: 4px;
    }

    .meshscore-body {
      padding: 16px;
      display: grid;
      gap: 16px;
      overflow: auto;
    }

    .meshscore-hero {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px 16px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .meshscore-cards {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .meshscore-chart {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .range-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .range-tabs button {
      border: 1px solid var(--line);
      background: #f7f7f7;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .range-tabs button.active {
      background: rgba(0, 122, 255, 0.12);
      color: var(--blue);
    }

    .meshscore-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    #routeMap {
      height: 100%;
      width: 100%;
      background: repeating-linear-gradient(
        135deg,
        rgba(10, 11, 14, 0.04),
        rgba(10, 11, 14, 0.04) 14px,
        transparent 14px,
        transparent 28px
      );
    }

    .analysis-body {
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }

    .modal.open {
      display: flex;
    }

    .modal-card {
      width: min(420px, 100%);
      max-height: 75vh;
      overflow: auto;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 18px;
      display: grid;
      gap: 12px;
    }

    .route-modal-card {
      width: min(760px, 100%);
    }

    .flash-panel {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .flash-panel.open {
      display: flex;
    }

    .flash-log {
      background: #0c111b;
      color: #d2d9e6;
      border-radius: 12px;
      padding: 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      min-height: 180px;
      max-height: 280px;
      overflow: auto;
      white-space: pre-wrap;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .flash-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .flash-row strong {
      color: var(--ink);
    }

    .route-override-list {
      display: grid;
      gap: 10px;
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
    }

    .route-override-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 8px;
    }

    .route-override-label {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .route-override-label strong {
      font-size: 13px;
      color: var(--ink);
    }

    .route-override-select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
    }

    .route-override-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .route-override-empty {
      font-size: 13px;
      color: var(--muted);
      padding: 12px 0;
    }

    .field {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .field input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 13px;
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel {
      background: var(--panel);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .route-override-row {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .range-tabs button {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
    }
    body.theme-dark .route-override-select,
    body.theme-dark .rf-input {
      background: var(--panel);
      color: var(--ink);
    }

    body.view-rotm {
      overflow: auto;
      height: auto;
    }

    body.view-rotm .app {
      height: auto;
      min-height: 100vh;
    }

    body.view-rotm .rotm-panel,
    body.view-rotm .rotm-body {
      overflow: visible;
      height: auto;
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel,
    body.theme-dark .route-override-row,
    body.theme-dark .route-override-select,
    body.theme-dark .field input,
    body.theme-dark .observer-grid input,
    body.theme-dark .observer-grid select,
    body.theme-dark .rank-body,
    body.theme-dark .rank-map,
    body.theme-dark .observer-rank-body,
    body.theme-dark .observer-rank-map,
    body.theme-dark .observer-map,
    body.theme-dark .analysis-body,
    body.theme-dark .meshscore-body,
    body.theme-dark .rank-body,
    body.theme-dark .rf-body,
    body.theme-dark .rf-table,
    body.theme-dark .rf-row,
    body.theme-dark .route-override-list,
    body.theme-dark .modal-card {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .range-tabs button.active {
      background: rgba(99, 162, 255, 0.16);
      color: var(--blue);
    }
    body.theme-dark .modal {
      background: rgba(0, 0, 0, 0.6);
    }
    body.theme-dark #meshChart {
      background: rgba(255, 255, 255, 0.04) !important;
    }
    body.theme-dark .rank-summary {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .summary-card {
      background: var(--panel);
      color: var(--muted);
    }
    body.theme-dark .rank-search {
      background: var(--panel);
      color: var(--ink);
      box-shadow: none;
    }
    body.theme-dark .rank-item {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rank-summary,
    body.theme-dark .summary-card,
    body.theme-dark .rank-search,
    body.theme-dark .rank-item {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rank-item .row,
    body.theme-dark .rank-search::placeholder {
      color: var(--muted);
    }
      body.theme-dark .summary-card,
      body.theme-dark .observer-card,
      body.theme-dark .why-card {
        background: var(--panel) !important;
        color: var(--ink);
        border-color: var(--line);
      }
      body.theme-dark .summary-card strong,
      body.theme-dark .observer-card strong,
      body.theme-dark .why-card h3 {
        color: var(--ink);
      }
      body.theme-dark .rank-history .history-item {
        background: var(--panel);
        border-color: var(--line);
        color: var(--muted);
      }
      body.theme-dark .rank-history .history-item .history-time {
        color: var(--ink);
      }
    body.theme-dark .badge,
    body.theme-dark .chip,
    body.theme-dark .list-item {
      background: rgba(255, 255, 255, 0.04) !important;
      color: var(--ink);
      border-color: var(--line);
    }
    body.theme-dark .chip-strong {
      background: rgba(255, 255, 255, 0.1) !important;
      border-color: rgba(231, 238, 251, 0.2);
      color: var(--ink);
    }
    body.theme-dark .badge.badge-green { color: #7bdc98; }
    body.theme-dark .badge.badge-blue { color: #8bb6ff; }
    body.theme-dark .badge.badge-amber { color: #f2c88b; }
    body.theme-dark .badge.badge-purple { color: #b5a9ff; }
    body.theme-dark .badge.badge-gray { color: #c7c7cc; }
    body.theme-dark .observer-step {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
      border-color: var(--line);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    body.view-channels .rank-panel,
    body.view-channels .meshscore-panel { display: none; }
    body.view-channels .sidebar-panel,
    body.view-channels .content { display: flex; }
    body.view-channel-directory .sidebar-panel,
    body.view-channel-directory .content,
    body.view-channel-directory .analysis-panel,
    body.view-channel-directory .rank-panel,
    body.view-channel-directory .meshscore-panel,
    body.view-channel-directory .rf-panel,
    body.view-channel-directory .observer-panel,
    body.view-channel-directory .observer-rank-panel,
    body.view-channel-directory .node-rank-panel,
    body.view-channel-directory .rotm-panel,
    body.view-channel-directory .why-panel { display: none; }
    body.view-channel-directory .directory-panel {
      display: flex;
      grid-column: 1 / -1;
    }

    body.view-rank .sidebar-panel,
    body.view-rank .content,
    body.view-rank .analysis-panel,
    body.view-rank .meshscore-panel { display: none; }
    body.view-rank .rank-panel { display: flex; }

    body.view-meshscore .sidebar-panel,
    body.view-meshscore .content,
    body.view-meshscore .analysis-panel,
    body.view-meshscore .rank-panel { display: none; }
    body.view-meshscore .meshscore-panel { display: flex; }

    body.view-rf .sidebar-panel,
    body.view-rf .content,
    body.view-rf .analysis-panel,
    body.view-rf .rank-panel,
    body.view-rf .meshscore-panel { display: none; }
    body.view-rf .rf-panel { display: flex; }

    body.view-observer .sidebar-panel,
    body.view-observer .content,
    body.view-observer .analysis-panel,
    body.view-observer .rank-panel,
    body.view-observer .meshscore-panel,
    body.view-observer .rf-panel,
    body.view-observer .observer-rank-panel,
    body.view-observer .repeater-panel { display: none; }
    body.view-observer .observer-panel { display: flex; }
    body.view-why .sidebar-panel,
    body.view-why .content,
    body.view-why .analysis-panel,
    body.view-why .rank-panel,
    body.view-why .meshscore-panel,
    body.view-why .rf-panel,
    body.view-why .observer-panel,
    body.view-why .observer-rank-panel,
    body.view-why .repeater-panel { display: none; }
    body.view-why .why-panel { display: flex; }
    body.view-terms .sidebar-panel,
    body.view-terms .content,
    body.view-terms .analysis-panel,
    body.view-terms .rank-panel,
    body.view-terms .meshscore-panel,
    body.view-terms .rf-panel,
    body.view-terms .observer-panel,
    body.view-terms .observer-rank-panel,
    body.view-terms .repeater-panel,
    body.view-terms .why-panel,
    body.view-terms .privacy-panel { display: none; }
    body.view-terms .terms-panel { display: flex; }
    body.view-privacy .sidebar-panel,
    body.view-privacy .content,
    body.view-privacy .analysis-panel,
    body.view-privacy .rank-panel,
    body.view-privacy .meshscore-panel,
    body.view-privacy .rf-panel,
    body.view-privacy .observer-panel,
    body.view-privacy .observer-rank-panel,
    body.view-privacy .repeater-panel,
    body.view-privacy .why-panel,
    body.view-privacy .terms-panel { display: none; }
    body.view-privacy .privacy-panel { display: flex; }

    body.view-observer-rank .sidebar-panel,
    body.view-observer-rank .content,
    body.view-observer-rank .analysis-panel,
    body.view-observer-rank .rank-panel,
    body.view-observer-rank .meshscore-panel,
    body.view-observer-rank .rf-panel,
    body.view-observer-rank .observer-panel,
    body.view-observer-rank .repeater-panel { display: none; }
    body.view-observer-rank .observer-rank-panel { display: flex; }

    body.view-node-rank .sidebar-panel,
    body.view-node-rank .content,
    body.view-node-rank .analysis-panel,
    body.view-node-rank .rank-panel,
    body.view-node-rank .meshscore-panel,
    body.view-node-rank .rf-panel,
    body.view-node-rank .observer-panel,
    body.view-node-rank .observer-rank-panel,
    body.view-node-rank .repeater-panel,
    body.view-node-rank .why-panel { display: none; }
    body.view-node-rank .node-rank-panel { display: flex; }

    body.route-open {
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
    }
    .analysis-panel {
      display: none;
      position: fixed;
      top: clamp(90px, 12vh, 140px);
      left: 50%;
      transform: translate(-50%, 0);
      width: min(640px, calc(100vw - 32px));
      max-width: min(640px, calc(100vw - 32px));
      max-height: calc(100vh - 180px);
      z-index: 30;
      border-radius: 32px;
      margin: 0;
      padding: 0;
      overflow: hidden;
      box-shadow: var(--shadow);
      background: var(--panel);
      flex-direction: column;
      touch-action: none;
      box-sizing: border-box;
    }
    .analysis-panel .analysis {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0 20px 20px;
      overscroll-behavior: contain;
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
      width: 100%;
    }
    .route-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: nowrap;
      width: 100%;
    }
    .route-share {
      font-size: 13px;
      padding: 4px 10px;
      flex-shrink: 0;
    }
    .route-close {
      border: 1px solid var(--line);
      background: transparent;
      border-radius: 999px;
      width: 34px;
      height: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      padding: 0;
      color: var(--ink);
    }
    body.route-open .analysis-panel {
      display: flex;
    }

    body.view-rotm .sidebar-panel,
    body.view-rotm .content,
    body.view-rotm .analysis-panel,
    body.view-rotm .rank-panel,
    body.view-rotm .meshscore-panel,
    body.view-rotm .rf-panel,
    body.view-rotm .observer-panel,
    body.view-rotm .observer-rank-panel,
    body.view-rotm .repeater-panel,
    body.view-rotm .why-panel,
    body.view-rotm .node-rank-panel { display: none; }
    body.view-rotm .rotm-panel { display: flex; }

    .helper-banner {
      margin: 0 18px 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 149, 0, 0.15);
      color: #ff9500;
      font-weight: 600;
      font-size: 13px;
    }
    body.theme-dark .helper-banner {
      background: rgba(255, 149, 0, 0.2);
      color: #ffd08a;
    }
    .toast {
      position: fixed;
      right: 24px;
      bottom: 24px;
      padding: 12px 16px;
      border-radius: 12px;
      background: rgba(16, 24, 40, 0.9);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 50;
    }
    body.theme-dark .toast {
      background: rgba(255, 255, 255, 0.12);
      color: var(--ink);
    }
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .directory-panel { display: none; flex-direction: column; gap: 20px; }
    .directory-content { padding: 0 18px 18px; overflow: auto; }
    .channel-page {
      display: grid;
      gap: 18px;
    }
    .channel-box {
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background:
        linear-gradient(160deg, rgba(0, 122, 255, 0.08), rgba(255, 255, 255, 0.92) 42%),
        rgba(255, 255, 255, 0.92);
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    body.theme-dark .channel-box {
      background:
        linear-gradient(160deg, rgba(0, 122, 255, 0.22), rgba(11, 15, 21, 0.85) 40%),
        rgba(12, 18, 28, 0.9);
      border-color: rgba(120, 160, 255, 0.35);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.45);
    }
    .channel-box h3 { margin: 0; }
    .channel-box-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }
    .channel-box-head h3 {
      color: #0a60d1;
      letter-spacing: 0.2px;
    }
    body.theme-dark .channel-box-head h3 {
      color: #8bb6ff;
    }
    body.theme-dark .directory-group-header {
      border-color: rgba(120, 160, 255, 0.35);
      background: rgba(12, 18, 28, 0.75);
    }
    body.theme-dark .directory-row {
      border-color: rgba(120, 160, 255, 0.22);
      background: rgba(12, 18, 28, 0.6);
    }
    .directory-strip {
      display: block;
      overflow: hidden;
    }
    .directory-strip-row {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      padding-bottom: 8px;
      scroll-snap-type: x proximity;
    }
    .directory-strip-row > .directory-card {
      scroll-snap-align: start;
    }
    .directory-strip-row::-webkit-scrollbar {
      height: 6px;
    }
    .directory-strip-row::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 999px;
    }
    .directory-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .directory-card {
      padding: 14px;
      border-radius: 14px;
      background:
        linear-gradient(120deg, rgba(0, 122, 255, 0.08), rgba(255, 255, 255, 0.95)),
        rgba(16, 24, 40, 0.04);
      border: 1px solid rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    body.theme-dark .directory-card {
      background:
        linear-gradient(120deg, rgba(0, 122, 255, 0.16), rgba(15, 23, 42, 0.75)),
        rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.08);
    }
    .directory-card h4 { margin: 0; font-size: 15px; }
    .directory-card .muted { font-size: 12px; }
    .directory-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .directory-groups { display: grid; gap: 18px; }
    .directory-group { display: grid; gap: 10px; }
    .directory-group-header {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(0, 122, 255, 0.35);
      background: linear-gradient(135deg, rgba(0, 122, 255, 0.15), rgba(255, 255, 255, 0.85));
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
      font-weight: 700;
    }
    .checkbox {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }
    .checkbox input {
      width: 16px;
      height: 16px;
      accent-color: #007aff;
    }
    body.theme-dark .directory-group-header {
      border-color: rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
    }
    .directory-group-header h4 { margin: 0; display: flex; gap: 10px; align-items: center; cursor: pointer; }
    .directory-group-toggle {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      border: 1px solid var(--line);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 800;
      color: var(--ink);
      background: #fff;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
    }
    body.theme-dark .directory-group-toggle {
      background: rgba(255, 255, 255, 0.08);
      color: var(--ink);
    }
    .directory-group-actions { display: flex; gap: 8px; align-items: center; margin-left: auto; }
    .directory-group-body {
      display: grid;
      gap: 10px;
      padding-left: 12px;
    }
    .directory-group-title { flex: 1; display: inline-flex; align-items: center; gap: 6px; }
    .directory-group-badge {
      font-size: 11px;
      background: var(--blue);
      color: white;
      border-radius: 999px;
      padding: 2px 8px;
      align-self: center;
    }
    .directory-group.collapsed .directory-group-body { display: none; }
    .directory-row.dragging { opacity: 0.5; }
    .directory-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: rgba(255, 255, 255, 0.6);
    }
    .directory-group-body .directory-row {
      margin-left: 6px;
      padding-left: 18px;
      background: rgba(0, 122, 255, 0.05);
      border-left: 3px solid rgba(0, 122, 255, 0.4);
    }
    .directory-row.joined {
      opacity: 0.6;
      background: rgba(0, 122, 255, 0.08);
    }
    .directory-row.blocked {
      opacity: 0.5;
      background: rgba(142, 142, 147, 0.12);
    }
    body.theme-dark .directory-row {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.1);
    }
    body.theme-dark .directory-group-body .directory-row {
      background: rgba(0, 122, 255, 0.1);
      border-color: rgba(0, 122, 255, 0.6);
    }
    .directory-row .row-main { display: grid; gap: 4px; }
    .directory-row .row-title { font-weight: 600; }
    .directory-row .row-meta { font-size: 12px; color: var(--muted); }
    .directory-row .row-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      align-items: center;
      flex-wrap: wrap;
    }
    .row-title .badge-bubble {
      margin-left: 8px;
      font-size: 10px;
      padding: 2px 6px;
    }
    .directory-preview { display: none; }
    .channel-muted .name { opacity: 0.7; }
    .channel-muted .muted-label { font-size: 11px; color: var(--muted); margin-top: 2px; }
    .channel-mute {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      padding: 0;
      cursor: pointer;
    }
    .channel-mute:hover { color: var(--ink); }
    body.theme-dark ::-webkit-scrollbar { width: 10px; height: 10px; }
    body.theme-dark ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.04); }
    body.theme-dark ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.18); border-radius: 999px; }
    body.theme-dark ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.28); }
    .modal-body { display: grid; gap: 12px; margin-top: 12px; }
    .modal-row { display: flex; gap: 12px; flex-wrap: wrap; }
    .modal-row .field { flex: 1 1 160px; }
    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(36px, 1fr));
      gap: 8px;
    }
    .emoji-picker-trigger {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .emoji-preview {
      font-size: 20px;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--line);
      background: #fff;
    }
    body.theme-dark .emoji-preview {
      background: rgba(255, 255, 255, 0.08);
    }
    .emoji-btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px;
      font-size: 18px;
      background: #fff;
      cursor: pointer;
    }
    body.theme-dark .emoji-btn {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
    }
    .emoji-btn.active { outline: 2px solid var(--accent); }
    .auth-panel, .account-panel { display: none; }
    body.view-auth .auth-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.28);
      z-index: 40;
    }
    body.view-account .account-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.28);
      z-index: 40;
    }
    body.view-auth .sidebar-panel,
    body.view-auth .content,
    body.view-auth .analysis-panel,
    body.view-auth .rank-panel,
    body.view-auth .meshscore-panel,
    body.view-auth .rf-panel,
    body.view-auth .observer-panel,
    body.view-auth .observer-rank-panel,
    body.view-auth .node-rank-panel,
    body.view-auth .rotm-panel,
    body.view-auth .directory-panel,
    body.view-auth .why-panel,
    body.view-auth .terms-panel,
    body.view-auth .privacy-panel { display: none; }
    body.view-account .sidebar-panel,
    body.view-account .content,
    body.view-account .analysis-panel,
    body.view-account .rank-panel,
    body.view-account .meshscore-panel,
    body.view-account .rf-panel,
    body.view-account .observer-panel,
    body.view-account .observer-rank-panel,
    body.view-account .node-rank-panel,
    body.view-account .rotm-panel,
    body.view-account .directory-panel,
    body.view-account .why-panel,
    body.view-account .terms-panel,
    body.view-account .privacy-panel { display: none; }
    .auth-card {
      max-width: 520px;
      width: 100%;
      padding: 28px;
      border-radius: 18px;
      background: rgba(16, 24, 40, 0.04);
      border: 1px solid rgba(15, 23, 42, 0.08);
      display: grid;
      gap: 16px;
      position: relative;
    }
    .account-modal {
      max-width: 860px;
      width: min(92vw, 860px);
      max-height: 86vh;
      overflow: hidden;
    }
    .auth-close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--muted);
      font-weight: 700;
      cursor: pointer;
    }
    body.theme-dark .auth-close {
      background: rgba(255, 255, 255, 0.08);
      color: var(--ink);
      border-color: rgba(255, 255, 255, 0.12);
    }
    body.theme-dark .auth-card {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.08);
    }
    .auth-header h2 { margin: 0; }
    .auth-tabs { display: flex; gap: 8px; }
    .auth-tabs .tab-btn { flex: 1; }
    .auth-tabs .tab-btn.active { background: var(--accent); color: #fff; }
    .auth-providers { display: grid; gap: 8px; }
    .auth-providers #gsiButton { display: flex; justify-content: center; }
    .google-config-hint {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 4px;
      display: none;
    }
    .auth-form { display: grid; gap: 12px; }
    .password-row { display: flex; gap: 8px; align-items: center; }
    .password-row input { flex: 1; }
    .auth-hint { font-size: 12px; color: var(--muted); }
    .auth-links { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; }
    .auth-links a {
      color: #0b0f1a;
      font-weight: 600;
    }
    .auth-links a:hover { text-decoration: underline; }
    body.theme-dark .auth-links a {
      color: #ffffff;
    }
    .account-content {
      padding: 0 12px 12px;
      display: grid;
      gap: 12px;
      max-height: 62vh;
      overflow-y: auto;
    }
    .account-card {
      background: rgba(16, 24, 40, 0.04);
      border: 1px solid rgba(15, 23, 42, 0.08);
      padding: 12px;
      border-radius: 16px;
      display: grid;
      gap: 8px;
    }
    .account-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 4px;
    }
    .account-actions .btn {
      min-width: 160px;
    }
    body.theme-dark .account-card {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.08);
    }
    .account-list { display: grid; gap: 8px; }
    .account-item {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(15, 23, 42, 0.06);
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }
    body.theme-dark .account-item {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.1);
    }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .badge {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-weight: 600;
      color: var(--ink);
      background: #f7f7f7;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .badge.badge-coverage {
      cursor: pointer;
    }
    .badge.badge-coverage:hover {
      filter: brightness(0.92);
    }

    .badge.badge-green { background: rgba(52, 199, 89, 0.16); border-color: rgba(52, 199, 89, 0.28); color: #1b6b35; }
    .badge.badge-blue { background: rgba(0, 122, 255, 0.16); border-color: rgba(0, 122, 255, 0.28); color: #0a60d1; }
    .badge.badge-amber { background: rgba(255, 149, 0, 0.18); border-color: rgba(255, 149, 0, 0.28); color: #9a5b00; }
    .badge.badge-purple { background: rgba(88, 86, 214, 0.18); border-color: rgba(88, 86, 214, 0.28); color: #3b39a5; }
    .badge.badge-gray { background: rgba(142, 142, 147, 0.18); border-color: rgba(142, 142, 147, 0.28); color: #4a4a4f; }
    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .list-item {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #fafafa;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .channel-remove {
      border: 0;
      background: transparent;
      color: #ff3b30;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
      display: none;
    }
    .channel-leave-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      color: var(--ink);
      cursor: pointer;
    }
    .channel-leave-toggle input {
      width: 14px;
      height: 14px;
      accent-color: #007aff;
    }
    .channel-fixed {
      opacity: 0.6;
    }
    body.leave-mode .channel-remove {
      display: none !important;
    }
    .admin-only {
      display: none;
    }
    body:not(.is-admin) .admin-only {
      display: none !important;
    }
    .auto-responder-panel {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-left: 12px;
    }
    .auto-responder-panel span,
    .auto-responder-panel label {
      font-size: 12px;
      color: var(--ink);
    }
    .auto-responder-panel input[type="range"] {
      width: 160px;
    }
    .auto-responder-status {
      font-size: 12px;
      color: var(--ink);
      margin-left: auto;
    }
    .repeater-location-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .repeater-location-controls input {
      width: 92px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
    }
    .repeater-location-controls .btn {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
    }
    .channel-history-control {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .channel-history-control select {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 2px 8px;
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
    }

    .slider {
      width: 100%;
    }

    .observer-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }
    .observer-location-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .observer-location-modal.open { display: flex; }
    .observer-location-card {
      width: min(92vw, 560px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      padding: 14px;
    }
    .observer-location-map {
      height: 260px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--line);
    }
    .observer-location-meta {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .observer-location-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .observer-location-button {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 11px;
    }

    .observer-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .why-panel,
    .terms-panel,
    .privacy-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .why-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }
    .legal-body {
      display: grid;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }
    .legal-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 18px;
      background: #ffffff;
      display: grid;
      gap: 10px;
      align-content: start;
    }
    .legal-card h3 { margin: 0; font-size: 16px; }
    .legal-card p { margin: 0; font-size: 13px; line-height: 1.6; color: var(--ink); }
    .legal-card ul { margin: 0; padding-left: 18px; font-size: 13px; color: var(--muted); }

    .why-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 18px;
      background: #ffffff;
      display: grid;
      gap: 14px;
      align-content: start;
    }

    .why-card h3 {
      margin: 0;
      font-size: 16px;
    }

    .why-card p {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--ink);
    }

    .faq-item strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .faq-item p {
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }

    .observer-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .observer-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px 14px;
      background: #ffffff;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .observer-right {
      display: grid;
      gap: 16px;
      align-content: start;
    }

    .observer-log {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .observer-steps {
      display: grid;
      gap: 8px;
    }

    .observer-step {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 4px;
    }

    .observer-step strong {
      font-size: 13px;
    }

    .observer-grid {
      display: grid;
      gap: 8px;
    }

    .observer-grid label {
      font-size: 12px;
      color: var(--muted);
    }

    .observer-grid input,
    .observer-grid select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
    }

    .observer-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .observer-map {
      width: 100%;
      height: 360px;
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }

    .observer-map .leaflet-container {
      width: 100%;
      height: 100%;
    }

    .observer-legend {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .observer-legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .observer-legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #34c759;
    }

    .observer-legend i.warn { background: #ff9500; }
    .observer-legend i.bad { background: #ff3b30; }

    .observer-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .link-btn {
      border: 0;
      background: transparent;
      color: var(--blue-dark);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .install-log {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #0b1120;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .install-log.active {
      display: block;
    }

    @keyframes slideIn {
      from { transform: translateY(8px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @media (max-width: 1200px) {
      .app { grid-template-columns: 240px 1fr; }
      .analysis-panel { display: none; }
    }

    @media (max-width: 860px) {
      body { height: 100vh; overflow: hidden; }
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height: 100vh;
        padding: 8px;
      }
      .topbar {
        gap: 6px;
        padding: 6px 8px;
        min-height: 40px;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      .brand-logo { width: 32px; height: 32px; }
      .brand-text span { display: none; }
      .nav { display: none; }
      .menu-toggle { display: inline-flex; }
      .theme-toggle { margin-left: auto; }
      .menu-toggle { margin-left: 6px; }
      .nav a[data-view="observer"] { display: none; }
      .sidebar-panel {
        display: flex;
        position: fixed;
        top: 52px;
        left: 8px;
        bottom: 8px;
        width: min(86vw, 360px);
        z-index: 960;
        transform: translateX(-110%);
        transition: transform 0.2s ease;
      }
      body.view-channels.menu-open-left .sidebar-panel { transform: translateX(0); }
      body.menu-open-left .menu-backdrop,
      body.menu-open-right .menu-backdrop { display: block; }
      body.menu-open-right .mobile-menu { display: flex; transform: translateX(0); }
      .mobile-nav { display: flex; }
      .sidebar { padding: 8px; gap: 8px; }
      .channel { padding: 8px; grid-template-columns: 36px 1fr auto; gap: 8px; }
      .channel .snippet { font-size: 11px; }
      .panel { min-height: 0; }
      .content { min-height: 0; height: 100%; padding-bottom: env(safe-area-inset-bottom); }
      .channel-selector { display: inline-flex; }
      body.view-channels .channels-rail { display: inline-flex; }
      .messages {
        padding: 10px 12px;
        gap: 10px;
        flex: 1;
        overflow: auto;
        padding-bottom: calc(120px + env(safe-area-inset-bottom));
        scroll-padding-bottom: calc(120px + env(safe-area-inset-bottom));
        overflow-x: hidden;
      }
      .message { grid-template-columns: 36px 1fr; gap: 10px; min-width: 0; }
      .avatar { width: 32px; height: 32px; font-size: 12px; }
      .bubble { padding: 8px 12px; border-radius: 12px; max-width: 85%; }
      .message .meta { font-size: 11px; }
      .msg-footer { font-size: 11px; gap: 8px; }
      .analysis-panel {
        bottom: max(14px, env(safe-area-inset-bottom, 14px));
        right: auto;
        top: calc(env(safe-area-inset-top, 0px) + 64px);
        left: 50%;
        transform: translate(-50%, 0);
        width: min(520px, calc(100vw - 32px));
        max-height: calc(100vh - 200px);
        height: auto;
        z-index: 30;
        border-radius: 26px;
        margin: 0;
        padding: 0;
        overflow: hidden;
        box-shadow: var(--shadow);
        display: none;
        touch-action: none;
        box-sizing: border-box;
      }
      .analysis-panel .title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }
      .analysis-panel .analysis {
        overflow-y: auto;
        overflow-x: hidden;
        padding: 0 16px 16px;
        touch-action: pan-y;
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
        box-sizing: border-box;
      }
    .route-title-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
    }
    .route-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .route-share {
      font-size: 13px;
      padding: 4px 10px;
    }
      html body.view-rotm { height: auto; overflow: auto; }
      body.view-rotm .app { height: auto; min-height: 100vh; }
      .rotm-grid { grid-template-columns: 1fr; min-height: 0; }
      .rotm-card { min-height: 360px; }
      .rotm-feed { min-height: 260px; }
      .rotm-leaderboard { min-height: 260px; }
      .rotm-leader-row {
        grid-template-columns: 32px 1fr 1fr;
        gap: 10px;
      }
      .rotm-leader-row .rotm-leader-meta {
        text-align: left;
      }
      .rotm-leader-row .rotm-leader-rank {
        grid-row: span 2;
      }
      .rotm-leader-row .rotm-leader-node {
        font-size: 13px;
      }
      .rotm-settings-grid { grid-template-columns: 1fr; }
      .rotm-feed-row { grid-template-columns: 1fr; }
      .rotm-leader-row {
        grid-template-columns: 28px 1fr;
        grid-template-rows: auto auto;
      }
      .rotm-leader-row .rotm-leader-meta {
        grid-column: 1 / -1;
      }
      #rotmQsoMap { height: 260px; }
      body.view-channels .analysis-panel { display: none; }
      body.route-open .analysis-panel { display: flex; }
      body.route-open .route-backdrop { display: block; }
      .analysis { grid-template-rows: 1fr auto; }
      #routeMap { min-height: 200px; }
      .rank-body { grid-template-columns: 1fr; }
      .rank-summary { padding: 8px 10px; gap: 8px; }
      .summary-card { padding: 8px 10px; }
      .summary-card strong { font-size: 14px; }
      .rank-detail-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 0, 0, 0.4);
        align-items: center;
        justify-content: center;
        z-index: 900;
      }
      .rank-detail-overlay.open {
        display: flex;
      }
      .rank-detail-card {
        background: var(--panel);
        border-radius: 18px;
        padding: 20px;
        width: min(96vw, 520px);
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      }
      .rank-detail-close {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 12px;
      }
      .rank-detail-close button {
        background: none;
        border: none;
        color: var(--muted);
        font-size: 18px;
        cursor: pointer;
      }
      .rank-detail-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 14px;
      }
      .route-history-title {
        font-size: 16px;
        font-weight: 700;
        margin-bottom: 4px;
      }
      .route-history-meta {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 12px;
      }
      .route-history-list {
        display: grid;
        gap: 10px;
      }
      .route-history-item {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        background: var(--panel);
      }
      .route-history-path {
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 6px;
      }
      .route-history-sub {
        color: var(--muted);
        font-size: 12px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .rank-body { height: auto; }
      .rank-map { display: none; }
      #rankMap { display: none; }
      #observerRankMap { display: none; }
      .node-rank-map { display: none; }
      #nodeRankMap { display: none; }
      .rank-scroll,
      #channels {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      .rank-scroll::-webkit-scrollbar,
      #channels::-webkit-scrollbar {
        width: 0 !important;
        height: 0 !important;
        background: transparent !important;
      }
      .rank-scroll::-webkit-scrollbar-track,
      #channels::-webkit-scrollbar-track,
      .rank-scroll::-webkit-scrollbar-thumb,
      #channels::-webkit-scrollbar-thumb {
        background: transparent !important;
        border: none !important;
      }
      #channels {
        max-height: 100%;
        overflow: overlay;
        overflow-x: hidden;
      }
      .rf-body { grid-template-columns: 1fr; }
      .rf-table { overflow-x: auto; }
      body.view-rf .rf-row { min-width: 0; grid-template-columns: 70px 70px 1fr 70px 60px 60px; }
      body.view-rf .rf-row > div:nth-child(3),
      body.view-rf .rf-row > div:nth-child(4),
      body.view-rf .rf-row > div:nth-child(5),
      body.view-rf .rf-row > div:nth-child(10),
      body.view-rf .rf-row > div:nth-child(11),
      body.view-rf .rf-row > div:nth-child(12) { display: none; }
      .observer-body { grid-template-columns: 1fr; }
      .observer-map { height: 260px; }
      .observer-rank-body { grid-template-columns: 1fr; }
      .observer-rank-map { display: none; }
      #observerRankMap { display: none; }
      .why-body { grid-template-columns: 1fr; }
      .meshscore-panel { min-height: 0; overflow: hidden; }
      .meshscore-body { min-height: 0; height: 100%; overflow: auto; }
      body.view-rank .rank-panel,
      body.view-observer-rank .observer-rank-panel,
      body.view-node-rank .node-rank-panel { overflow: auto; }
    }
    .coverage-popup {
      position: fixed;
      inset: 0;
      background: rgba(10, 11, 14, 0.75);
      display: none;
      justify-content: center;
      align-items: center;
      padding: 20px;
      z-index: 1100;
    }
    .coverage-popup.open {
      display: flex;
    }
    .coverage-popup .coverage-card {
      max-width: 420px;
      width: 100%;
      background: var(--panel);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }
    .coverage-popup .coverage-card h3 {
      margin: 0;
      font-size: 20px;
    }
    .coverage-popup .coverage-card p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .coverage-popup .coverage-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .coverage-popup .coverage-close {
      position: absolute;
      top: 10px;
      right: 12px;
      border: none;
      background: transparent;
      font-size: 20px;
      cursor: pointer;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
        <div class="brand">
          <div class="brand-logo">
            <img src="/meshrank.png?v=1.1.2" alt="MeshRank logo"/>
          </div>
          <div class="brand-text">
            <strong>MeshRank.net</strong>
            <span>by G5AIL</span>
          </div>
        </div>
    <nav class="nav">
      <a href="#" class="active" data-view="channels">Messages</a>
      <a href="#" data-view="channel-directory">Channels</a>
      <a href="#" data-view="rotm">#ROTM</a>
      <a href="#" data-view="rank">Repeater Rank</a>
      <a href="#" data-view="node-rank">Node Rank</a>
        <a href="#" data-view="meshscore">MeshRank</a>
        <a href="#" data-view="observer-rank">Observer Rank</a>
        <a href="#" data-view="rf">MeshFlow</a>
        <a href="#" data-view="why">Why MeshRank?</a>
        <a href="#" data-view="observer">Become an Observer</a>
      </nav>
      <button class="theme-toggle" id="themeToggle" type="button" aria-pressed="false">Dark mode</button>
      <button class="btn" id="loginBtn" type="button">Login</button>
      <button class="menu-toggle" id="menuToggle" type="button" aria-label="Open menu">
        <span class="burger" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
        </span>
      </button>
    </header>
    <div class="menu-backdrop" id="menuBackdrop"></div>
    <div class="mobile-menu" id="mobileMenu">
      <a href="#" class="active" data-view="channels">Messages</a>
      <a href="#" data-view="channel-directory">Channels</a>
      <a href="#" data-view="rotm">#ROTM</a>
      <a href="#" data-view="rank">Repeater Rank</a>
      <a href="#" data-view="node-rank">Node Rank</a>
      <a href="#" data-view="meshscore">MeshRank</a>
      <a href="#" data-view="observer-rank">Observer Rank</a>
      <a href="#" data-view="rf">MeshFlow</a>
      <a href="#" data-view="why">Why MeshRank?</a>
      <a href="#" data-view="observer">Become an Observer</a>
    </div>
    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <section class="panel sidebar-panel">
      <div class="title column">
        <span>Messages <span class="chip">UK Mesh</span></span>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <button class="btn" id="addChannelBtn">Add Channel</button>
          <div class="node-controls auth-only" id="nodeControlsContainer">
            <button class="btn" id="connectNodeBtn" type="button">
              <span class="node-connection-dot" id="nodeStatusDot"></span>
              <span id="nodeButtonLabel">Connect node</span>
            </button>
            <span class="node-status-text" id="nodeStatusText">Not connected</span>
          </div>
          <button class="btn btn-ghost" id="leaveChannelBtn">Leave Channels</button>
          <div class="admin-only channel-history-control">
            <span>History</span>
            <select id="channelHistoryLimit" aria-label="Channel history limit"></select>
          </div>
        </div>
          <div class="node-connection-hint admin-only" id="nodeConnectionHint" style="display:none;">WebSerial is not supported in this browser. Use Chrome or Edge to connect a node.</div>
          <div class="auto-responder-panel admin-only" id="autoResponderPanel">
            <label for="autoResponderChannel">Channel</label>
            <input id="autoResponderChannel" type="text" value="#test" />
            <label for="autoResponderDelay">Delay</label>
            <input id="autoResponderDelay" type="range" min="1" max="20" value="5" />
            <span id="autoResponderDelayValue">5s</span>
            <button class="btn btn-ghost" id="autoResponderToggle" type="button">Enable auto-responder</button>
            <span class="auto-responder-status" id="autoResponderStatus">Paused</span>
          </div>
      </div>
      <div class="sidebar">
        <div class="sidebar-helper" id="channelSidebarHelper">
          <div>
            <strong>Your feed is now customisable.</strong>
            <p>Weve introduced a new Channels page where you can add or remove the channels you like. Open the Channels tab by clicking Add Channel above, or select it from the menu.</p>
          </div>
        </div>
        <div id="channels"></div>
      </div>
    </section>

    <section class="panel content">
      <div class="title channel-title">
        <button class="channel-selector" type="button" data-channels-toggle>
          <span>Other channels</span>
          <span class="badge-bubble channels-unread">0</span>
        </button>
        <span class="channel-title-label">Other channels</span>
        <button class="channel-selector" id="channelsTab" type="button" data-channels-toggle>
          <span id="activeChannel">#public</span>
        </button>
      </div>
      <div class="helper-banner" id="loginHelper" style="display:none;">
        Cant see your channels? Please log in or sign up to manage them.
      </div>
      <div class="messages" id="messages"></div>
      <div class="node-composer auth-only" id="nodeComposer">
        <textarea id="nodeComposerInput" placeholder="Connect a node to send a message via mesh" disabled></textarea>
        <div class="node-composer-row">
          <span class="composer-status" id="nodeComposerStatus">Connect a node to send via mesh.</span>
          <button class="btn primary" id="nodeComposerSend" type="button" disabled>Send</button>
        </div>
      </div>
    </section>

    <section class="panel directory-panel" id="channelDirectoryPanel">
        <div class="title column">
        <span>Channels.</span>
        <div class="muted">Discover and add channels so others can add to their personal feed.</div>
      </div>
      <div class="directory-content">
        <div class="channel-page">
          <div class="channel-box">
            <div class="channel-box-head">
              <div>
                <h3>Popular Channels</h3>
                <div class="muted">Channels you might like (last 24 hours).</div>
              </div>
            </div>
            <div class="directory-strip">
              <div id="popularChannels" class="directory-strip-row"></div>
            </div>
          </div>
          <div class="channel-box">
            <div class="channel-box-head">
              <div>
                <h3>Browse by group</h3>
                <div class="muted">Add channels to your feed by category.</div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;">
                <button class="btn" id="channelDirectoryAddBtn" type="button">Add Channel</button>
                <button class="btn btn-ghost admin-only" id="channelDirectoryAddGroupBtn" type="button">Add Group</button>
              </div>
            </div>
            <div id="groupedChannels" class="directory-groups"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel auth-panel" id="authPanel">
      <div class="auth-card">
        <button class="auth-close" id="authCloseBtn" type="button" aria-label="Close login"></button>
        <div class="auth-header">
          <h2>Log in or sign up</h2>
          <p class="muted">You'll get a more tailored experience and exclusive data access.</p>
        </div>
        <div class="auth-providers">
          <div id="gsiButton"></div>
          <div id="gsiFallback" class="google-config-hint">Google login is not configured yet.</div>
        </div>
        <div class="auth-form" id="authFlowForm">
          <label class="field">
            <span>Email address</span>
            <input id="authFlowEmail" type="email" placeholder="you@example.com"/>
          </label>
          <label class="field" id="authFlowNameField" style="display:none;">
            <span>Your name</span>
            <input id="authFlowName" type="text" placeholder="Display name"/>
          </label>
          <label class="field" id="authFlowPasswordField" style="display:none;">
            <span>Password</span>
            <div class="password-row">
              <input id="authFlowPassword" type="password" placeholder=""/>
              <button class="btn btn-ghost" type="button" data-toggle-password="#authFlowPassword">Show</button>
            </div>
          </label>
          <div class="auth-hint" id="authFlowError"></div>
          <button class="btn primary" id="authFlowSubmit" type="button">Continue</button>
          <div class="auth-links">
            <a href="#" id="forgotPasswordLink" class="muted">Forgot password?</a>
            <a href="#" class="muted" data-view="terms">Terms</a>
            <a href="#" class="muted" data-view="privacy">Privacy</a>
          </div>
          <div class="auth-hint" id="authFlowHint" style="display:none;">Password strength: use 8+ characters with a mix of letters and numbers.</div>
        </div>
      </div>
    </section>

    <section class="panel account-panel" id="accountPanel">
      <div class="auth-card account-modal">
        <button class="auth-close" id="accountCloseBtn" type="button" aria-label="Close account"></button>
        <div class="title column" style="gap:6px;">
          <span>Account</span>
          <div class="muted">Manage your profile, nodes, and joined channels.</div>
        </div>
        <div class="account-content">
          <div class="account-card">
            <h3>Account</h3>
            <div id="accountSummary">Not logged in.</div>
            <button class="btn" id="accountLogoutBtn" type="button">Logout</button>
          </div>
          <div class="account-card">
            <h3>Claim your node</h3>
            <p class="muted">Enter your public node ID to link it to your account.</p>
            <input id="accountNodeId" class="rf-input" type="text" placeholder="Public node ID"/>
            <button class="btn" id="accountClaimBtn" type="button">Claim node</button>
            <div class="auth-hint" id="accountClaimStatus"></div>
            <div id="accountNodes" class="account-list"></div>
          </div>
          <div class="account-card">
            <h3>Your channels</h3>
            <div class="account-list" style="max-height: 220px; overflow-y: auto;" id="accountChannels"></div>
            <button class="btn btn-ghost" id="accountManageChannels" type="button">Manage channels</button>
          </div>
        </div>
      </div>
    </section>

    <div class="route-backdrop" id="routeBackdrop"></div>
    <section class="panel analysis-panel">
      <div class="title">
        <div class="route-title-label">
          Route Path <span class="chip" id="routeKey">none</span>
        </div>
        <div class="route-actions">
          <button class="link-btn route-share" id="routeShareBtn" type="button">Share</button>
          <button class="route-close" id="routeClose" type="button" aria-label="Close route path"><span aria-hidden="true"></span></button>
        </div>
      </div>
      <div class="analysis">
        <div id="routeMap"></div>
        <div id="routeLegend" class="route-legend"></div>
        <div class="analysis-body">
          <div class="row"><span>Message key</span><span id="routeMessage">-</span></div>
          <div class="row"><span>Source</span><span id="routeSource">-</span></div>
          <div class="row"><span>Confidence</span><span id="routeConfidence">-</span></div>
          <div class="row"><span>Path depth</span><span id="routeDepth">-</span></div>

          <div class="row"><span>Packets heard</span><span class="badge" id="routeCount">0</span></div>
          <div class="list" id="routeList"></div>
          <div style="display:flex;align-items:center;gap:8px;">
            <button class="link-btn" id="routeOverrideBtn" type="button" onclick="window.openRouteOverride && window.openRouteOverride()">Route path wrong?</button>
            <span style="font-size:12px;color:var(--muted);">Suggest a correction for a 2-digit code.</span>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rotm-panel" id="rotm">
      <div class="title rotm-title" style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
          <span>#ROTM - Repeaters on the Mesh</span>
          <button class="rotm-info-link" type="button" id="rotmInfoBtn">What is ROTM?</button>
        </div>
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
          <button class="rotm-info-link admin-only" type="button" id="rotmSettingsBtn">Change ROTM key</button>
          <span class="chip" id="rotmUpdated">--</span>
        </div>
      </div>
      <div class="rotm-body">
        <div class="rotm-grid">
          <div class="rotm-card">
            <div class="rotm-card-title">Live #rotm activity feed</div>
            <div class="rotm-feed" id="rotmFeed"></div>
          </div>
          <div class="rotm-card">
            <div class="rotm-card-title">Repeater activations</div>
            <div class="rotm-leaderboard" id="rotmLeaderboard"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rank-panel">
      <div class="title">
        Repeater Rank
        <span class="chip" id="rankUpdated">--</span>
        <span class="rank-cache-badge" id="rankCacheBadge" style="display:none;">Cached </span>
      </div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total repeaters</div>
          <strong id="rankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="rankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>MeshRank today</div>
          <strong id="rankMeshToday">0</strong>
          <div style="font-size:11px;color:var(--muted);">Yesterday: <span id="rankMeshYesterday">0</span></div>
        </div>
      </div>
      <div class="rank-helper-row">
        <button class="link-btn" id="rankFlaggedLink" type="button">
          Can't see your repeater? Check the implausible GPS list.
        </button>
        <button class="link-btn" id="rankExplainLink" type="button">
          How repeater scores are calculated
        </button>
      </div>
      <div class="rank-body">
        <div class="rank-map">
          <div class="rank-map-note">
            Repeaters marked with  in their names are hidden from the map.
            If youd prefer not to share your exact location with anyone, you should set your GPS to 0000N 0000E.
          </div>
          <div id="rankMap"></div>
        </div>
        <div class="rank-list">
          <div class="rank-loading" id="rankLoading">
            <span class="spinner" aria-hidden="true"></span>
            <span>Running repeater rank, please hold</span>
          </div>
          <input class="rank-search" id="rankSearch" type="text" placeholder="Search repeaters (name, key, or code [55])"/>
          <div class="rank-search-hint" id="rankSearchHint"></div>
          <div class="rank-scroll" id="rankScroll">
            <div id="rankList"></div>
          </div>
          <div id="rankStatus" class="rank-status"></div>
          <div id="rankDebugOverlay" class="rank-debug"></div>
        </div>
      </div>
    </section>

    <section class="panel node-rank-panel">
      <div class="title">Node Rank <span class="chip" id="nodeRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total nodes</div>
          <strong id="nodeRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="nodeRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Messages (24h)</div>
          <strong id="nodeRankMessages">0</strong>
        </div>
      </div>
      <div class="rank-body node-rank-body">
        <div class="rank-map node-rank-map">
          <div id="nodeRankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="nodeRankSearch" type="text" placeholder="Search nodes"/>
          <div class="rank-scroll" id="nodeRankScroll">
            <div id="nodeRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel meshscore-panel">
      <div class="title">MeshRank <span class="chip" id="meshUpdated">--</span></div>
      <div class="meshscore-body">
        <div class="meshscore-hero">
          <div style="font-weight:700;">MeshRank tracks network health using active repeaters, message volume, and repeat reliability.</div>
          <div style="font-size:12px;color:var(--muted);">Scores update from live RF logs and decoded mesh traffic. Higher scores mean wider coverage, better repeat density, and more reliable delivery.</div>
        </div>
        <div class="meshscore-cards">
          <div class="summary-card">
            <div>MeshRank today</div>
            <strong id="meshToday">0</strong>
          </div>
          <div class="summary-card">
            <div>MeshRank yesterday</div>
            <strong id="meshYesterday">0</strong>
          </div>
          <div class="summary-card">
            <div>Change</div>
            <strong id="meshDelta">0</strong>
          </div>
          <div class="summary-card">
            <div>Messages (24h)</div>
            <strong id="meshMessages">0</strong>
          </div>
        </div>
        <div class="meshscore-chart">
          <div class="range-tabs" id="meshRangeTabs">
            <button data-range="7" class="active">7d</button>
            <button data-range="30">30d</button>
            <button data-range="90">90d</button>
            <button data-range="365">1y</button>
          </div>
          <svg id="meshChart" viewBox="0 0 600 220" width="100%" height="220" style="background:var(--panel);border-radius:12px;">
            <polyline id="meshLine" fill="none" stroke="#007aff" stroke-width="3" points=""></polyline>
            <polyline id="meshArea" fill="rgba(0,122,255,0.12)" stroke="none" points=""></polyline>
          </svg>
        </div>
        <div class="meshscore-grid">
          <div class="summary-card">
            <div>Total devices</div>
            <strong id="meshDevices">0</strong>
          </div>
          <div class="summary-card">
            <div>Repeaters active</div>
            <strong id="meshRepeaters">0</strong>
          </div>
          <div class="summary-card">
            <div>Room servers</div>
            <strong id="meshRooms">0</strong>
          </div>
          <div class="summary-card">
            <div>Chat nodes</div>
            <strong id="meshChat">0</strong>
          </div>
          <div class="summary-card">
            <div>Companion nodes</div>
            <strong id="meshCompanions">0</strong>
          </div>
          <div class="summary-card">
            <div>Mesh msgs today</div>
            <strong id="meshMsgsToday">0</strong>
          </div>
          <div class="summary-card">
            <div>Observer msgs today</div>
            <strong id="meshMsgsObserver">0</strong>
          </div>
        </div>
      </div>
    </section>

    <section class="panel mesh-live-panel">
      <div class="mesh-live-header">
        <div>
          <span class="mesh-live-title">MeshLive</span>
          <p class="muted">Live visibility into packet flow, repeaters, and evolving mesh health.</p>
        </div>
        <div id="meshLiveDaily" class="mesh-live-daily">
          <div>Loading daily delta</div>
        </div>
      </div>
      <div class="mesh-live-grid">
        <div class="mesh-live-stats">
          <div class="mesh-live-card">
            <div class="mesh-live-card-label">Packet throughput</div>
            <strong id="meshLivePacketRate">--</strong>
            <span class="muted">packets per minute</span>
          </div>
          <div class="mesh-live-card">
            <div class="mesh-live-card-label">Repeaters plotted</div>
            <strong id="meshLiveRepeaterCount">--</strong>
            <span class="muted">with GPS fixes</span>
          </div>
          <div class="mesh-live-card">
            <div class="mesh-live-card-label">Daily movement</div>
            <strong id="meshLiveDailyChange">--</strong>
            <span class="muted">MeshRank / msgs</span>
          </div>
        </div>
        <div class="mesh-live-right-pane">
          <div class="mesh-live-visitor-grid">
            <div class="visitor-card">
              <div class="visitor-label">Active visitors</div>
              <strong id="visitorActive">0</strong>
            </div>
            <div class="visitor-card">
              <div class="visitor-label">Connections (1m)</div>
              <strong id="visitorRate1m">0</strong>
            </div>
            <div class="visitor-card">
              <div class="visitor-label">Connections (1h)</div>
              <strong id="visitorRate1h">0</strong>
            </div>
            <div class="visitor-card">
              <div class="visitor-label">Peak concurrent</div>
              <strong id="visitorPeak">0</strong>
            </div>
          </div>
          <div class="visitor-note">Counts reflect open listeners on the live stream.</div>
        </div>
      </div>
      <div class="mesh-live-list-wrapper">
        <div class="mesh-live-list-title">Repeaters with recent packets</div>
        <div class="mesh-live-list" id="meshLiveList"></div>
      </div>
    </section>

    <section class="panel rf-panel">
      <div class="title">MeshFlow <span class="chip" id="rfCount">0 packets</span></div>
      <div class="rf-body">
        <div class="rf-table">
          <div class="rf-controls">
            <input class="rf-input" id="rfSearch" type="text" placeholder="Search hash or hex"/>
            <select class="rf-input" id="rfTypeFilter">
              <option value="">All types</option>
              <option value="Advert">Advert</option>
              <option value="GroupText">GroupText</option>
              <option value="Request">Request</option>
              <option value="Response">Response</option>
              <option value="Path">Path</option>
              <option value="Ack">Ack</option>
            </select>
            <span class="chip" id="rfUpdated">--</span>
          </div>
          <div class="rf-summary">
            <div>Total packets<strong id="rfTotal">0</strong></div>
            <div>CRC ok<strong id="rfOk">0</strong></div>
            <div>CRC bad<strong id="rfBad">0</strong></div>
            <div>Top type<strong id="rfTopType">--</strong></div>
          </div>
          <div class="rf-list" id="rfList"></div>
        </div>
        <div class="rf-detail" id="rfDetail">
          <div class="rf-kv">Select a packet to inspect its payload.</div>
        </div>
      </div>
    </section>

    <section class="panel observer-panel">
      <div class="title">Become an Observer <span class="chip">Quick setup</span></div>
      <div class="observer-body">
          <div class="observer-card">
            <div style="font-weight:700;">Bring your observer online</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.5;">
              Observer Nodes listen silently and relay RF traffic to MeshRank without stressing repeaters.
              Place it where Wi-Fi and RF are strong. Firmware is Heltec V3 only.
            </div>
            <div class="observer-steps">
              <div class="observer-step"><strong>1</strong> Plug in your Heltec V3 in DFU mode.</div>
              <div class="observer-step">
                <strong>2</strong> Flash the firmware via MeshCore flasher.
                <div class="observer-actions">
                  <button class="btn" id="observerFlashLink" type="button">Open MeshRank Flasher</button>
                </div>
                <div style="font-size:12px;color:var(--muted);">The in-page flasher erases and writes the full merged firmware image, then reboots the device.</div>
                <div class="flash-panel" id="flashPanel">
                  <div style="font-weight:700;">MeshRank Observer Flasher</div>
                  <div style="font-size:12px;color:var(--muted);line-height:1.5;">
                    This flashes the full merged image for Heltec V3 (ESP32-S3). It will erase the device first.
                  </div>
                  <div class="flash-row">
                    <div>Firmware</div>
                    <strong id="flashVersion">observer-merged-1.1.8.bin</strong>
                  </div>
                  <div class="flash-row">
                    <div>Offset</div>
                    <strong>0x0 (full image)</strong>
                  </div>
                  <div class="flash-log" id="flashLog">Ready to flash.</div>
                  <div class="observer-actions">
                    <button class="btn" id="flashStart" type="button">Start flash</button>
                    <button class="btn" id="flashHide" type="button">Hide</button>
                  </div>
                </div>
              </div>
              <div class="observer-step">
                <strong>3</strong> Enter your Wi-Fi credentials and click send, then reboot the node.
                <div class="observer-grid">
                  <div>
                    <label for="observerName">Observer name</label>
                    <input id="observerName" type="text" placeholder="Observer name"/>
                  </div>
                  <div>
                    <label for="observerWifi">Wi-Fi SSID</label>
                    <input id="observerWifi" type="text" placeholder="MyWiFi"/>
                  </div>
                  <div>
                    <label for="observerPass">Wi-Fi password</label>
                    <input id="observerPass" type="password" placeholder="password"/>
                  </div>
                </div>
                <div class="observer-actions">
                  <button class="btn" type="button" id="observerSendConfig">Send Wi-Fi config</button>
                </div>
              </div>
              <div class="observer-step"><strong>4</strong> If your node appears in Pending Observers, send a repeater advert to speed up geolocation.</div>
              <div class="observer-step"><strong>5</strong> Once validated, it moves to Observer Rank automatically.</div>
            </div>
          <div class="observer-status" id="observerStatus"></div>
          <div id="installLog" class="install-log">Verbose install log ready.</div>
        </div>
        <div class="observer-right">
          <div class="observer-card">
            <div style="font-weight:700;">Current Observer Coverage</div>
            <div class="observer-legend">
              <span><i></i> Active &lt; 24h</span>
              <span><i class="warn"></i> Low packet rate (15m-24h)</span>
              <span><i class="bad"></i> Offline 24h+</span>
            </div>
            <div style="font-size:12px;color:var(--muted);">Location pending observers stay off the map until validated.</div>
            <div id="observerMap" class="observer-map"></div>
          </div>
          <div class="observer-card">
            <div style="font-weight:700;">Pending Observers</div>
            <div style="font-size:12px;color:var(--muted);">Only observers awaiting geolocation appear here.</div>
            <div id="observerList" class="rf-list"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel observer-rank-panel">
      <div class="title">Observer Rank <span class="chip" id="observerRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total observers</div>
          <strong id="observerRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (&lt;24h)</div>
          <strong id="observerRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Packets (24h)</div>
          <strong id="observerRankPackets">0</strong>
        </div>
      </div>
      <div class="rank-body observer-rank-body">
        <div class="rank-map observer-rank-map">
          <div id="observerRankMap"></div>
        </div>
        <div class="rank-list">
          <div class="rank-loading" id="observerRankLoading">
            <span class="spinner" aria-hidden="true"></span>
            <span>Running observer rank, please hold</span>
          </div>
          <input class="rank-search" id="observerRankSearch" type="text" placeholder="Search observers"/>
          <div class="rank-scroll" id="observerRankScroll">
            <div id="observerRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <div class="observer-location-modal" id="observerLocationModal">
      <div class="observer-location-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong>Set Observer Location</strong>
          <button class="observer-location-button" type="button" id="observerLocationClose">Close</button>
        </div>
        <div class="observer-location-map" id="observerLocationMap"></div>
        <div class="observer-location-meta">
          <span id="observerLocationLabel">Observer: --</span>
          <span id="observerLocationCoords">Lat/Lon: --</span>
        </div>
        <div class="observer-location-actions">
          <button class="btn" type="button" id="observerLocationSave">Save location</button>
        </div>
      </div>
    </div>

    <div class="observer-location-modal" id="repeaterLocationModal">
      <div class="observer-location-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong>Set Repeater Location</strong>
          <button class="observer-location-button" type="button" id="repeaterLocationClose">Close</button>
        </div>
        <div class="observer-location-map" id="repeaterLocationMap"></div>
        <div class="observer-location-meta">
          <span id="repeaterLocationLabel">Repeater: --</span>
          <span id="repeaterLocationCoords">Lat/Lon: --</span>
        </div>
        <div class="observer-location-actions">
          <button class="btn" type="button" id="repeaterLocationSave">Save location</button>
        </div>
      </div>
    </div>

    <div class="neighbor-map-modal" id="neighborMapModal">
      <div class="neighbor-map-card">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
          <strong id="neighborMapTitle">Local Neighbors</strong>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn btn-ghost" type="button" id="neighborEditToggle">Something not right?</button>
            <button class="observer-location-button" type="button" id="neighborMapClose">Close</button>
          </div>
        </div>
        <div class="neighbor-map" id="neighborMap"></div>
        <div class="neighbor-map-legend">
          <div class="neighbor-map-legend-item"><span class="neighbor-map-legend-swatch" style="background:#34c759;"></span>Reciprocal neighbor</div>
          <div class="neighbor-map-legend-item"><span class="neighbor-map-legend-swatch" style="background:#ffcc00;"></span>One-way neighbor</div>
        </div>
        <div class="neighbor-map-list" id="neighborMapList"></div>
        <div class="confidence-meta" id="neighborMapMeta">Lines show likely zero-hop neighbours matched using AI-inspired geo intelligence that blends route codes with nearby repeater clusters.</div>
      </div>
    </div>

    <div class="modal admin-only" id="neighborOverrideModal">
      <div class="modal-card">
        <strong>Choose repeater</strong>
        <div style="margin-top:10px;">
          <select id="neighborOverrideSelect" class="rotm-qso-select"></select>
        </div>
        <div class="modal-actions">
          <button class="btn" type="button" id="neighborOverrideSave">Save</button>
          <button class="btn" type="button" id="neighborOverrideClose">Close</button>
        </div>
      </div>
    </div>

    <section class="panel why-panel">
      <div class="title">Why MeshRank?</div>
      <div class="why-body">
        <div class="why-card">
          <h3>Why MeshRank?</h3>
          <p>Mesh networks promise resilience, but in their early stages they often struggle with something more basic: confidence.</p>
          <p>With MeshCORE, new repeaters are frequently deployed into sparse or growing networks. When messages dont appear to move - or theres no clear feedback - operators naturally assume the repeater isnt helping. Too often, it gets switched off, and the network loses coverage just when it needs it most.</p>
          <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping?</p>
          <p>By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient. MeshRank exists to change that experience.</p>
          <p>It provides visibility into how the mesh is actually performing:</p>
          <p>Which repeaters are active and contributing over time. Which messages were delivered, with a confidence score rather than guesswork. Where messages were observed but failed to fully propagate.</p>
          <p>This feedback loop keeps operators engaged and informed, even when the network is still maturing.</p>
          <p>MeshRank uses a passive observer network to provide insight without increasing mesh traffic. By reducing the need for repeated test messages, it lowers network load while giving users meaningful information about whats happening behind the scenes.</p>
          <p>Repeaters are ranked based on real contribution, not assumptions - encouraging operators to keep nodes online, improve placement, and actively strengthen the network.</p>
          <p>MeshRank doesnt replace the mesh, and it doesnt route traffic through the internet. It simply helps the mesh understand itself.</p>
          <p>Visibility builds confidence. Confidence builds resilience.</p>
        </div>
        <div class="why-card">
          <h3>Frequently Asked Questions</h3>
          <div class="faq-item">
            <strong>Does MeshRank route messages over the internet?</strong>
            <p>No. MeshRank does not forward, relay, or complete mesh messages using the internet. All mesh communication still happens entirely over RF. MeshRank only observes what has already occurred and reports that information back to users.</p>
          </div>
          <div class="faq-item">
            <strong>Does this break the idea of a pure mesh?</strong>
            <p>No. The mesh remains fully autonomous and functional without MeshRank. If MeshRank disappeared tomorrow, the mesh would continue to operate exactly as it does today. MeshRank does not participate in routing decisions, message delivery, or network control - it provides visibility, not dependency.</p>
          </div>
          <div class="faq-item">
            <strong>Why involve the internet at all?</strong>
            <p>Because feedback matters. In early and sparse networks, lack of feedback causes repeaters to be switched off, not improved. MeshRank uses off-mesh observation to help operators understand whats happening without increasing RF traffic or adding test spam to the network. This strengthens the mesh - it doesnt weaken it.</p>
          </div>
          <div class="faq-item">
            <strong>Could this become a central point of failure?</strong>
            <p>No. MeshRank is not in the message path. It cannot block, delay, or interfere with mesh traffic. If MeshRank goes offline, the mesh continues to operate unchanged. There is no reliance on MeshRank for delivery, routing, or authentication.</p>
          </div>
          <div class="faq-item">
            <strong>Does this reduce resilience by encouraging internet dependence?</strong>
            <p>Quite the opposite. MeshRank encourages: better repeater placement, higher uptime, reduced test traffic, and faster identification of coverage gaps. All of these increase RF-only resilience, even when the internet is unavailable.</p>
          </div>
          <div class="faq-item">
            <strong>Is this surveillance or message tracking?</strong>
            <p>No. Observers do not inject traffic or control the network. They report limited metadata needed to understand propagation - not to monitor users. The goal is network health, not message content analysis.</p>
          </div>
          <div class="faq-item">
            <strong>Why ranking repeaters? Isnt that gamification?</strong>
            <p>Yes - intentionally. Visibility and motivation matter. Ranking makes contribution measurable, encourages operators to keep repeaters online, and helps the network grow during its most fragile phase. Strong networks are built by engaged operators.</p>
          </div>
          <div class="faq-item">
            <strong>What happens when the mesh becomes dense and mature?</strong>
            <p>MeshRank becomes less critical - and thats a success. As density increases, confidence becomes self-sustaining. MeshRanks role naturally shifts toward diagnostics, optimisation, and historical insight rather than reassurance.</p>
          </div>
          <div class="faq-item">
            <strong>So what is MeshRank really for?</strong>
            <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping? By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="panel terms-panel">
      <div class="title">Terms of Use</div>
      <div class="legal-body">
        <div class="legal-card">
          <h3>Overview</h3>
          <p>These terms apply to your use of MeshRank.net and related services. By using the site, you agree to these terms.</p>
        </div>
        <div class="legal-card">
          <h3>Acceptable use</h3>
          <ul>
            <li>Use the service lawfully and respectfully.</li>
            <li>Do not attempt to disrupt, overload, or bypass security.</li>
            <li>Do not upload or share unlawful, harmful, or misleading content.</li>
          </ul>
        </div>
        <div class="legal-card">
          <h3>Accounts</h3>
          <p>You are responsible for keeping your login details secure and for activity under your account.</p>
        </div>
        <div class="legal-card">
          <h3>Availability</h3>
          <p>We aim to keep the service available but do not guarantee uninterrupted access.</p>
        </div>
        <div class="legal-card">
          <h3>Liability</h3>
          <p>The service is provided as is. To the extent allowed by law, we exclude liability for indirect or consequential loss.</p>
        </div>
        <div class="legal-card">
          <h3>Changes</h3>
          <p>We may update these terms. Continued use after changes means you accept the updated terms.</p>
        </div>
        <div class="legal-card">
          <h3>Contact</h3>
          <p>Questions? Contact us via the MeshRank site.</p>
        </div>
      </div>
    </section>

    <section class="panel privacy-panel">
      <div class="title">Privacy Policy (UK)</div>
      <div class="legal-body">
        <div class="legal-card">
          <h3>What we collect</h3>
          <ul>
            <li>Account details (email, display name).</li>
            <li>Usage data and basic analytics to operate the service.</li>
            <li>Node identifiers you choose to claim.</li>
          </ul>
        </div>
        <div class="legal-card">
          <h3>How we use data</h3>
          <ul>
            <li>To provide and improve the service.</li>
            <li>To keep accounts secure.</li>
            <li>To personalise your experience where enabled.</li>
          </ul>
        </div>
        <div class="legal-card">
          <h3>Lawful basis</h3>
          <p>We process personal data under legitimate interests and, where applicable, consent or contract.</p>
        </div>
        <div class="legal-card">
          <h3>Sharing</h3>
          <p>We do not sell personal data. We may use trusted service providers for hosting and authentication.</p>
        </div>
        <div class="legal-card">
          <h3>Retention</h3>
          <p>We keep data only as long as needed for the service or legal obligations.</p>
        </div>
        <div class="legal-card">
          <h3>Your rights</h3>
          <p>You can request access, correction, or deletion of your personal data, and object to processing where applicable.</p>
        </div>
        <div class="legal-card">
          <h3>Contact</h3>
          <p>For privacy requests, contact us via the MeshRank site.</p>
        </div>
      </div>
    </section>
  </div>

    <div class="modal" id="channelCreateModal">
      <div class="modal-card">
        <strong>Add channel to <span id="channelCreateGroup">Group</span></strong>
        <div class="modal-body">
          <label class="field">
            <span># Name</span>
            <input id="channelCreateName" type="text" placeholder="#channel"/>
          </label>
          <div class="modal-row">
            <label class="field">
              <span>Group</span>
              <select id="channelCreateGroupSelect" class="rf-input"></select>
            </label>
            <label class="field">
              <span>Key</span>
              <input id="channelCreateCode" type="text" placeholder="Channel hash / node id"/>
            </label>
          </div>
          <div class="field">
            <span>Emoji (optional)</span>
            <div id="channelCreateEmojiGrid" class="emoji-grid"></div>
            <div class="emoji-picker-trigger">
              <span class="emoji-preview" id="emojiPreview"></span>
              <button class="btn btn-ghost" type="button" id="openEmojiPicker">More emojis</button>
            </div>
          </div>
          <label class="field admin-only" id="channelPopularWrap">
            <span>Popular list</span>
            <label class="checkbox">
              <input id="channelCreatePopular" type="checkbox" checked />
              <span>Allow in popular channels</span>
            </label>
          </label>
          <label class="field admin-only" id="channelBlockedWrap">
            <span>Visibility</span>
            <label class="checkbox">
              <input id="channelCreateBlocked" type="checkbox" />
              <span>Block channel for non-admins</span>
            </label>
          </label>
        </div>
        <div class="modal-actions">
          <button class="btn btn-ghost" id="channelCreateCancel">Cancel</button>
          <button class="btn" id="channelCreateSave">Add channel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="emojiPickerModal">
      <div class="modal-card">
        <strong>Select any emoji</strong>
        <div class="modal-body">
          <label class="field">
            <span>Custom emoji</span>
            <input id="emojiCustomInput" type="text" placeholder="Paste emoji here"/>
          </label>
          <div id="emojiPickerGrid" class="emoji-grid"></div>
        </div>
        <div class="modal-actions">
          <button class="btn btn-ghost" id="emojiPickerClose">Close</button>
          <button class="btn" id="emojiPickerApply">Use emoji</button>
        </div>
      </div>
    </div>

    <div class="modal" id="channelPreviewModal">
      <div class="modal-card">
        <strong id="channelPreviewTitle">Channel</strong>
        <div class="modal-body" id="channelPreviewBody"></div>
        <div class="modal-actions">
          <button class="btn btn-ghost" id="channelPreviewClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="guestChannelNoticeModal">
      <div class="modal-card">
        <strong>Channel saved locally</strong>
        <div class="modal-body">
          <p id="guestChannelNoticeText">Channels are stored in your browser cache. Log in or register to sync them across devices.</p>
        </div>
        <div class="modal-actions">
          <button class="btn btn-ghost" id="guestChannelNoticeClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="rotmInfoModal">
      <div class="modal-card">
        <strong>#ROTM - Repeaters on the Mesh</strong>
        <p>Repeaters on the Mesh (#ROTM) builds naturally on the spirit of Parks on the Air (POTA), Summits on the Air (SOTA), and FT8 - taking the same portable, exploratory, quick-contact ethos that hams love and applying it to mesh networks.</p>
        <p>Just like activating a park or summit, you get out into the real world to test and extend coverage. And just like FT8's efficient, low-power digital exchanges, #ROTM uses short, structured messages on the dedicated #rotm channel to confirm contacts and "activate" repeaters.</p>
        <p><strong>How it works (classic ham QSO flow adapted to mesh):</strong></p>
        <p><strong>Initiate the call:</strong> Send a message on the #rotm channel that starts with CQ (e.g., "CQ ROTM via GB3STK @G5AIL testing" or simply "CQ via hill repeater"). This is your activation call - observers capture it with repeater path, hops, and confidence metadata.</p>
        <p><strong>Respond:</strong> Another node replies within 120 minutes, making sure to include the CQ sender's @node handle in their message (e.g., "@G5AIL 5/9 solid copy via same repeater 73" or "@NodeA msg ack 73 de @YourNode"). No strict wording required - just acknowledge and mention their @handle to link the exchange.</p>
        <p><strong>Confirmation & credit:</strong> When both messages are observed at high confidence (&gt;70% packets heard), MeshRank resolves the repeater hop using AI-assisted geo-intelligence from observer data. The repeater is then credited as "activated" for both nodes (added to unique claimed repeaters), and the QSO is logged. No credit for unheard paths - exactly like needing chasers to complete a POTA/SOTA activation.</p>
        <div class="modal-actions">
          <button class="btn" type="button" id="rotmInfoClose">Close</button>
        </div>
      </div>
    </div>
    </div>

    <div class="modal admin-only" id="rotmSettingsModal">
      <div class="modal-card rotm-settings">
        <strong>ROTM channel settings</strong>
        <div class="rotm-settings-grid">
          <label class="field">
            <span>Channel name</span>
            <input id="rotmChannelName" type="text" placeholder="#rotm"/>
          </label>
          <label class="field">
            <span>Channel secret (32 hex chars)</span>
            <input id="rotmChannelSecret" type="text" placeholder="0123456789abcdef0123456789abcdef"/>
          </label>
        </div>
        <div class="rotm-settings-actions">
          <button class="btn" type="button" id="rotmChannelSave">Save ROTM settings</button>
          <button class="btn" type="button" id="rotmSettingsClose">Close</button>
          <span class="rotm-settings-note" id="rotmChannelStatus">Secret is stored until you update it.</span>
        </div>
      </div>
    </div>

    <div class="modal" id="rotmQsoModal">
      <div class="modal-card">
        <strong id="rotmQsoTitle">ROTM QSO log</strong>
        <div class="rotm-map-title" id="rotmQsoMapTitle">Activated repeaters</div>
        <div id="rotmQsoMap"></div>
        <div class="rotm-claim-list" id="rotmQsoClaimList"></div>
        <div class="rotm-qso-log" id="rotmQsoLog"></div>
        <div class="modal-actions">
          <button class="btn" type="button" id="rotmQsoClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="rotmQsoDetailModal">
      <div class="modal-card">
        <strong id="rotmQsoDetailTitle">QSO details</strong>
        <div id="rotmQsoDetailBody"></div>
        <div class="modal-actions">
          <button class="btn" type="button" id="rotmQsoDetailClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="routeOverrideModal">
      <div class="modal-card route-modal-card">
        <strong>Suggest route fixes</strong>
        <div style="font-size:12px;color:var(--muted);line-height:1.5;">
          Pick the correct repeater for each 2-digit code. Suggestions are weighted over time, so one user cannot rewrite the route.
        </div>
        <div class="route-override-list" id="routeOverrideList"></div>
        <div class="route-override-status" id="routeOverrideStatus">No changes submitted yet.</div>
        <div class="modal-actions">
          <button class="btn" id="routeOverrideClose">Close</button>
          <button class="btn" id="routeOverrideSave">Submit suggestions</button>
        </div>
      </div>
    </div>

    <div class="modal" id="observerHitsModal">
      <div class="modal-card">
        <strong>Observers</strong>
        <div id="observerHitsSummary" style="font-size:12px;color:var(--muted);margin-top:6px;">No observers available.</div>
        <div id="observerHitsList" style="display:grid;gap:8px;margin-top:12px;"></div>
        <div class="modal-actions">
          <button class="btn" id="observerHitsClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="authModal">
      <div class="modal-card">
        <strong>Account</strong>
        <div style="display:grid;gap:10px;margin-top:12px;">
          <input id="authUsername" class="rf-input" type="text" placeholder="Username"/>
          <input id="authPassword" class="rf-input" type="password" placeholder="Password"/>
          <div id="authStatus" style="font-size:12px;color:var(--muted);"></div>
        </div>
        <div class="directory-actions" style="margin-top:12px;">
          <button class="btn btn-ghost" id="authGoogle" type="button">Continue with Google</button>
          <button class="btn btn-ghost" id="authApple" type="button">Continue with Apple</button>
          <button class="btn btn-ghost" id="authFacebook" type="button">Continue with Facebook</button>
        </div>
        <div style="margin-top:14px;display:grid;gap:8px;">
          <strong style="font-size:13px;">Claim a node</strong>
          <input id="claimPub" class="rf-input" type="text" placeholder="Public ID (e.g. A1B2C3...)"/>
          <button class="btn" id="claimNodeBtn" type="button">Submit claim</button>
          <div id="claimStatus" style="font-size:12px;color:var(--muted);"></div>
        </div>
        <div class="modal-actions">
          <button class="btn" id="authLogin">Login</button>
          <button class="btn" id="authBootstrap">Setup admin</button>
          <button class="btn" id="authLogout">Logout</button>
          <button class="btn" id="authClose">Close</button>
        </div>
      </div>
    </div>

    <div class="modal" id="changesModal">
      <div class="modal-card">
        <strong>Channels update</strong>
        <p>Weve improved channels! You can now personalise your experience by joining the channels you care about  and even add new channels for others to join.</p>
        <div class="modal-actions">
          <button class="btn" type="button" id="changesClose">Got it</button>
        </div>
      </div>
    </div>

  </div>

  <script type="module" src="https://unpkg.com/esp-web-tools@9.1.0/dist/web/install-button.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    document.body.classList.add("view-channels");
    const FIXED_CHANNELS = ["#public", "#meshranksuggestions", "#test"];
    const appData = {
        channels: [],
        userChannels: [],
        userNodes: [],
        channelDirectory: null,
        channelPreviews: {},
        channelGroupFlags: {},
        directoryGroupState: {},
        mutedChannels: [],
        guestChannels: [],
        dismissedChannels: [],
        leaveMode: false,
        leaveSelection: new Set(),
        messages: [],
        lastChannelsSig: "",
        lastMessagesSig: "",
        renderedIdsByChannel: {},
        meshScore: null,
        rankSummary: null,
        rankData: [],
        rankTotalCount: 0,
        rankFilter: "",
        rankCodeFilter: null,
        rankVisibleItems: [],
        rankRenderedCount: 0,
        rankMarkerNextIndex: 0,
        rankMarkerCount: 0,
        rankRenderToken: null,
        rankMarkerToken: null,
        rankLoadToken: null,
        rankLoadComplete: false,
        rankMarkersQueued: false,
        rankMarkersDrawn: false,
        rankTotalExpected: null,
        rankPerf: {
          uiPaintMs: null,
          fetchMs: null,
          renderMs: null,
          first100Ms: null,
          loadedCount: 0,
          markerCount: 0
        },
        nodeRankSummary: null,
        nodeRank: null,
        unreadByChannel: {},
        lastReadByChannel: {},
        historyByChannel: {},
        rfPackets: [],
        rfSelected: null,
        rfLastSig: "",
        observerRank: null,
        observerRankSummary: null,
        observersById: {},
        observersByName: {},
        observersByIdUpper: {},
        observersByNameLower: {},
        observersUpdatedAt: 0,
        routeSuggestions: null,
        repeatersByCode: null,
        routeActivePathCodes: [],
      routeActivePathPoints: [],
          routeActiveMsg: null,
          channelHistoryLimit: 10,
          authUser: null,
        rotmData: null,
        rotmConfigLoaded: false,
        rotmChannelName: null,
        rotmSelectedNodeKey: null,
        rotmLastFetch: 0,
        latestByChannel: {},
        channelCounts24h: {},
        recentStatsByChannel: {},
        neighborEditMode: false,
        neighborEditActiveEntry: null,
        livePulse: {
          timer: null,
          running: false,
          channelId: null,
            startedAt: 0,
            latestSeenTs: 0,
            newMessageCount: 0,
            limitMs: 5000,
            maxNewMessages: 2
          },
        meshLive: {
          polling: null
        },
        visitorStats: {
          active: 0,
          rate1m: 0,
          rate1h: 0,
          peak: 0
        },
      messageStream: {
        es: null,
        connected: false,
        lastHealthAt: 0
      },
      nodeConnected: false,
      autoResponderConfig: loadAutoResponderConfig(),
        authToken: null,
        googleInitialized: false
      };

    const urlParams = new URLSearchParams(window.location.search);
    const rankDebugMode = urlParams.get("debug") === "1";
    let rankDebugOverlay = null;

    const colors = ["#007aff", "#5856d6", "#ff9500", "#34c759"];
    const MAP_HIDE_EMOJI = "";

    const SOURCE_MASK = { INTERNET: 1, MESH: 2 };
    const SHARE_URL_BASE = "https://meshrank.net/msg/";
    const TEST_CHANNEL_ID = "test";
    const AUTO_RESPONDER_STORAGE_KEY = "meshrank.autoResponder";

    const FRAME_START_RADIO = 0x3E;
    const FRAME_START_APP = 0x3C;
    const CMD_APP_START = 1;
    const CMD_SEND_CHANNEL_TXT_MSG = 3;
    const CMD_SYNC_NEXT_MESSAGE = 10;
    const CMD_DEVICE_QUERY = 22;
    const RESP_CODE_OK = 0;
    const RESP_CODE_ERR = 1;
    const RESP_CODE_SELF_INFO = 5;
    const RESP_CODE_NO_MORE_MESSAGES = 10;
    const RESP_CODE_DEVICE_INFO = 13;
    const RESP_CODE_CONTACT_MSG_RECV_V3 = 16;
    const RESP_CODE_CHANNEL_MSG_RECV_V3 = 17;
    const PUSH_CODE_MSG_WAITING = 0x83;

    const HANDSHAKE_TIMEOUT = 12000;
    const nodeSerialService = (() => {
      const supports = !!(navigator?.serial);
      const decoder = new TextDecoder();
      const encoder = new TextEncoder();
      const multiWaiters = new Set();
      const listeners = new Set();
      const debugFrames = true;
      let port = null;
      let reader = null;
      let writer = null;
      let buffer = new Uint8Array(0);
      let ready = false;
      let draining = null;
      let handshakeInfo = {
        firmwareVersion: null,
        protocolVersion: 0,
        selfName: null
      };

      function concatBuffer(left, right) {
        const combined = new Uint8Array(left.length + right.length);
        combined.set(left);
        combined.set(right, left.length);
        return combined;
      }

      function consumeBuffer(count) {
        const consumed = buffer.slice(0, count);
        buffer = buffer.slice(count);
        return consumed;
      }

      function triggerWaiters(code, payload) {
        for (const entry of Array.from(multiWaiters)) {
          if (entry.codes.has(code)) {
            entry.resolve(code, payload);
            clearTimeout(entry.timer);
            multiWaiters.delete(entry);
          }
        }
      }

      function expectCodes(codes, timeout = 6000) {
        return new Promise((resolve, reject) => {
          const entry = {
            codes: new Set(codes),
            resolve: (code, payload) => resolve({ code, payload }),
            reject,
            timer: setTimeout(() => {
              multiWaiters.delete(entry);
              reject(new Error("Timeout waiting for response."));
            }, timeout)
          };
          multiWaiters.add(entry);
        });
      }

      function clearWaiters() {
        multiWaiters.forEach((entry) => {
          clearTimeout(entry.timer);
          entry.reject && entry.reject(new Error("Disconnected"));
        });
        multiWaiters.clear();
      }

      function decodeNullTerminated(bytes) {
        const end = bytes.indexOf(0);
        const slice = end === -1 ? bytes : bytes.subarray(0, end);
        return decoder.decode(slice).trim();
      }

      function handleMessageFrame(code, payload) {
        const timestampOffset = code === RESP_CODE_CONTACT_MSG_RECV_V3 ? 12 : 7;
        const textOffset = code === RESP_CODE_CONTACT_MSG_RECV_V3 ? 16 : 11;
        const dv = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        const ts = dv.getUint32(timestampOffset, true);
        const text = decodeNullTerminated(payload.subarray(textOffset));
        const channelName = code === RESP_CODE_CHANNEL_MSG_RECV_V3
          ? resolveChannelNameByIndex(payload[4])
          : "#public";
        const channelId = normalizeChannelId(channelName);
        const sender = code === RESP_CODE_CHANNEL_MSG_RECV_V3 ? channelName : formatSenderPrefix(payload.subarray(4, 10));
        const channelIdx = code === RESP_CODE_CHANNEL_MSG_RECV_V3 ? payload[4] : 0;
        const nodeMessage = appendNodeMessage(text, "in", {
          sender,
          channelId,
          tsRaw: new Date(ts * 1000).toISOString(),
          type: "mesh",
          source: "mesh",
          channelIdx
        });
        maybeAutoRespondToTest(nodeMessage);
        listeners.forEach((cb) => {
          try {
            cb(nodeMessage);
          } catch (err) {
            console.error("nodeSerial listener failed", err);
          }
        });
      }

      function formatSenderPrefix(prefixBytes) {
        if (!prefixBytes || !prefixBytes.length) return "MeshNode";
        return prefixBytes.map((b) => b.toString(16).padStart(2, "0")).join("").toUpperCase();
      }

      function handleFrame(payload) {
        const code = payload[0];
        switch (code) {
          case RESP_CODE_CONTACT_MSG_RECV_V3:
          case RESP_CODE_CHANNEL_MSG_RECV_V3:
            handleMessageFrame(code, payload);
            break;
          case PUSH_CODE_MSG_WAITING:
            drainMessages().catch(() => {});
            break;
          default:
            break;
        }
        triggerWaiters(code, payload);
      }

      function processIncoming(chunk) {
        buffer = concatBuffer(buffer, chunk);
        while (true) {
          if (buffer.length < 3) return;
          const start = buffer[0];
          if (start !== FRAME_START_RADIO) {
            buffer = buffer.slice(1);
            continue;
          }
          const length = buffer[1] | (buffer[2] << 8);
          if (buffer.length < 3 + length) return;
          const frame = buffer.subarray(3, 3 + length);
          handleFrame(frame);
          buffer = buffer.slice(3 + length);
        }
      }

      async function readLoop() {
        if (!reader) return;
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value && value.length) {
              processIncoming(value);
            }
          }
        } catch (err) {
          if (err?.message && !err.message.includes("Canceled")) {
            console.error("nodeSerial read error", err);
          }
        } finally {
          reader?.releaseLock();
          reader = null;
        }
      }

      async function writeFrame(payload) {
        if (!writer) throw new Error("Serial port not connected.");
        const frame = new Uint8Array(3 + payload.length);
        frame[0] = FRAME_START_APP;
        frame[1] = payload.length & 0xff;
        frame[2] = (payload.length >> 8) & 0xff;
        frame.set(payload, 3);
        await writer.write(frame);
      }

      async function sendCommandAndWait(payload, waitCodes, timeout = 6000) {
        const waitPromise = expectCodes([...waitCodes, RESP_CODE_ERR], timeout);
        await writeFrame(payload);
        const { code, payload: frame } = await waitPromise;
        if (code === RESP_CODE_ERR) {
          const errCode = frame?.[1] ?? -1;
          throw new Error(`Companion reported error ${errCode}`);
        }
        return { code, payload: frame };
      }

      async function runHandshake(appTargetVersion = 3) {
        ready = false;
        clearWaiters();
        const deviceResp = await sendCommandAndWait(new Uint8Array([CMD_DEVICE_QUERY, appTargetVersion]), [RESP_CODE_DEVICE_INFO], HANDSHAKE_TIMEOUT);
        handshakeInfo.firmwareVersion = decodeNullTerminated(deviceResp.payload.subarray(1));
        handshakeInfo.protocolVersion = appTargetVersion;
        const selfResp = await sendCommandAndWait(new Uint8Array([CMD_APP_START]), [RESP_CODE_SELF_INFO], HANDSHAKE_TIMEOUT);
        handshakeInfo.selfName = decodeNullTerminated(selfResp.payload.subarray(1));
        ready = true;
        drainMessages().catch(() => {});
        return { ...handshakeInfo };
      }

      async function drainMessages() {
        if (!ready) return;
        if (draining) return draining;
        draining = (async () => {
          try {
            while (ready) {
              const { code } = await sendCommandAndWait(new Uint8Array([CMD_SYNC_NEXT_MESSAGE]), [
                RESP_CODE_CONTACT_MSG_RECV_V3,
                RESP_CODE_CHANNEL_MSG_RECV_V3,
                RESP_CODE_NO_MORE_MESSAGES
              ]);
              if (code === RESP_CODE_NO_MORE_MESSAGES) break;
            }
          } catch (err) {
            console.warn("Mesh drain stopped", err);
          } finally {
            draining = null;
          }
        })();
        return draining;
      }

      async function connect() {
        if (!supports) throw new Error("WebSerial not supported in this browser.");
        if (port) await disconnect();
        const requested = await navigator.serial.requestPort();
        await requested.open({ baudRate: 115200 });
        port = requested;
        const writable = port.writable;
        const readable = port.readable;
        writer = writable?.getWriter() ?? null;
        reader = readable?.getReader() ?? null;
        if (reader) readLoop().catch(() => {});
      let info;
      const versions = [3, 2, 1];
      for (let idx = 0; idx < versions.length; idx += 1) {
        const target = versions[idx];
        try {
          info = await runHandshake(target);
          break;
        } catch (err) {
          const isLast = idx === versions.length - 1;
          console.warn(`Protocol ${target} handshake failed${isLast ? "" : ", retrying"}`, err);
          if (isLast) {
            await disconnect();
            console.error("Protocol handshake failed with all versions", err);
            throw err;
          }
        }
      }
        return { meta: getMeta(), info };
      }

      async function disconnect() {
        ready = false;
        clearWaiters();
        if (reader) {
          try {
            await reader.cancel();
          } catch {}
          reader?.releaseLock();
          reader = null;
        }
        if (writer) {
          try {
            await writer.close();
          } catch {}
          writer?.releaseLock();
          writer = null;
        }
        if (port && port.readable) {
          try {
            await port.close();
          } catch {}
        }
        port = null;
        buffer = new Uint8Array(0);
      }

      async function sendMessage(text, channelIdx = 0) {
        if (!ready) throw new Error("Companion node not ready.");
        const textBytes = encoder.encode(String(text || ""));
        const payload = new Uint8Array(1 + 1 + 1 + 4 + textBytes.length);
        payload[0] = CMD_SEND_CHANNEL_TXT_MSG;
        payload[1] = 0; // text type plain
        payload[2] = channelIdx;
        const dv = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        dv.setUint32(3, Math.floor(Date.now() / 1000), true);
        payload.set(textBytes, 7);
        await sendCommandAndWait(payload, [RESP_CODE_OK]);
      }

      function onMessage(callback) {
        if (!callback) return () => {};
        listeners.add(callback);
        return () => listeners.delete(callback);
      }

      function isConnected() {
        return !!(writer && reader);
      }

      function isSupported() {
        return supports;
      }

      function getMeta() {
        if (!port) return null;
        const info = port.getInfo?.() || {};
        return {
          vendorId: info.usbVendorId || null,
          productId: info.usbProductId || null,
          label: info.usbProductId ? `Node ${info.usbProductId}` : "MeshCore node"
        };
      }

      return {
        connect,
        disconnect,
        sendMessage,
        onMessage,
        isConnected,
        isSupported,
        getMeta
      };
    })();
    let nodeMessageCounter = 0;
    const nodeComposerDefaultStatus = "Connect a node to send via mesh.";

    function formatTimestamp(tsRaw) {
      if (!tsRaw) return "--";
      const parsed = new Date(tsRaw);
      if (!parsed || Number.isNaN(parsed.getTime())) return "--";
      return parsed.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false });
    }

    function resolveChannelNameByIndex(idx) {
      const numeric = Number(idx);
      if (!Number.isFinite(numeric)) return "#public";
      const fallback = (appData.channels || []).find((ch) => {
        const candidateIndex = Number(ch.channel_idx ?? ch.idx ?? ch.channelIndex);
        return candidateIndex === numeric;
      });
      if (fallback) {
        return fallback.name || fallback.id || `#chan${numeric}`;
      }
      if (numeric === 0) return "#public";
      return `#chan${numeric}`;
    }

    function channelIdToIndex(channelId) {
      if (!channelId) return 0;
      const normalized = normalizeChannelId(channelId);
      if (normalized === "public") return 0;
      const match = normalized.match(/^chan(\d+)$/);
      if (match) return Number(match[1]);
      return 0;
    }

    function updateChannelTracking(msg, markUnread = false) {
      if (!msg?.channelId) return;
      const channelId = msg.channelId;
      const tsValue = msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0;
      if (Number.isFinite(tsValue)) {
        appData.latestByChannel[channelId] = Math.max(appData.latestByChannel[channelId] || 0, tsValue);
      }
      if (markUnread && !isChannelMuted(channelId) && activeChannelId !== channelId) {
        appData.unreadByChannel[channelId] = (appData.unreadByChannel[channelId] || 0) + 1;
      }
    }

    function findSimilarMessage(body, channelId, tsRaw) {
      if (!body) return null;
      const cleaned = String(body || "").trim().toLowerCase();
      if (!cleaned) return null;
      const windowMs = 30 * 1000;
      const refTime = tsRaw ? new Date(tsRaw).getTime() : Date.now();
      const candidates = appData.messages || [];
      for (let msg of candidates) {
        if (!msg.body || msg.channelId !== channelId) continue;
        if (String(msg.body || "").trim().toLowerCase() === cleaned) {
          if (!msg.tsRaw) return msg;
          const msgTime = new Date(msg.tsRaw).getTime();
          if (Math.abs(msgTime - refTime) < windowMs) return msg;
        }
      }
      return null;
    }

    function markMessageMesh(nodeMsg) {
      const target = nodeMsg || null;
      if (!target) return null;
      target.sourceMask = (target.sourceMask || SOURCE_MASK.INTERNET) | SOURCE_MASK.MESH;
      return target;
    }

    const autoRespondCache = new Set();

    async function maybeAutoRespondToTest(nodeMsg) {
      if (!nodeMsg) return;
      if (!nodeSerialService.isConnected()) return;
      const config = appData.autoResponderConfig;
      if (!config.enabled) return;
      const normalizedChannel = normalizeChannelId(nodeMsg.channelId);
      const normalizedTrigger = normalizeChannelId(config.channel);
      if (normalizedChannel !== normalizedTrigger) return;
      const bodyText = String(nodeMsg.body || "").toLowerCase();
      if (!bodyText.includes("test")) return;
      const key = `${nodeMsg.id || ""}:${nodeMsg.tsRaw || ""}`;
      if (autoRespondCache.has(key)) return;
      autoRespondCache.add(key);
      const match = await findMessageRecordForNode(nodeMsg);
      const shareLink = match ? await createShareLinkForMessage(match) : null;
      const hops = getHopCount(nodeMsg) || nodeMsg.pathLength || 0;
      const observerCount = Number.isFinite(nodeMsg.observerCount) ? nodeMsg.observerCount : 0;
      const mention = String(nodeMsg.sender || "Mesh").split(/\s+/)[0];
      const link = shareLink || "https://meshrank.net";
      const reply = `@${mention} ${hops} hops witnessed by ${observerCount} observers ${link}`;
      const delaySeconds = Math.max(1, Math.min(20, Number(config.delay) || 1));
      const channelIdx = Number.isFinite(nodeMsg.channelIdx) ? nodeMsg.channelIdx : channelIdToIndex(config.channel || TEST_CHANNEL_ID);
      if (autoResponderTimers.has(key)) return;
      const scheduleReply = async () => {
        autoResponderTimers.delete(key);
        const outgoing = appendNodeMessage(reply, "out", {
          sender: nodeSerialService.getMeta()?.label || "MeshRank",
          channelId: nodeMsg.channelId,
          failed: false,
          source: "mesh"
        });
        try {
          await nodeSerialService.sendMessage(reply, channelIdx);
          outgoing.failed = false;
        } catch (err) {
          outgoing.failed = true;
          console.error("Auto responder failed", err);
        }
        renderMessages(false, { preserveScroll: true });
      };
      const timer = setTimeout(scheduleReply, delaySeconds * 1000);
      autoResponderTimers.set(key, timer);
    }

    async function findMessageRecordForNode(nodeMsg) {
      if (!nodeMsg) return null;
      try {
        const channelName = nodeMsg.channelId || `#${TEST_CHANNEL_ID}`;
        const url = new URL("/api/messages", window.location.origin);
        url.searchParams.set("channel", channelName);
        url.searchParams.set("limit", "20");
        const res = await fetch(url.toString(), { cache: "no-store" });
        if (!res.ok) return null;
        const data = await res.json().catch(() => null);
        if (!data || !Array.isArray(data.messages)) return null;
        return data.messages.find(
          (entry) => entry.ts === nodeMsg.tsRaw && entry.body === nodeMsg.body
        );
      } catch (err) {
        console.error("Failed to lookup message for auto-response", err);
        return null;
      }
    }

    async function createShareLinkForMessage(record) {
      if (!record) return null;
      const canonicalId = (record.messageHash || record.frameHash || record.id || "").toUpperCase();
      if (!canonicalId) return null;
      try {
        const res = await fetch(`/api/routes/${canonicalId}/share`, {
          method: "POST",
          headers: { "Content-Type": "application/json" }
        });
        if (!res.ok) return null;
        const data = await res.json().catch(() => null);
        if (!data?.ok) return null;
        if (data.url) return data.url;
        return data.code ? `${SHARE_URL_BASE}${data.code}` : null;
      } catch (err) {
        console.error("Failed to create share link", err);
        return null;
      }
    }

    function appendNodeMessage(body, direction = "in", overrides = {}) {
      const tsRaw = new Date().toISOString();
      const messageId = `node_${tsRaw}_${String(++nodeMessageCounter).padStart(3, "0")}`;
      const channelId = overrides.channelId || activeChannelId;
      const msg = {
        id: messageId,
        channelId,
        sender: overrides.sender || "MeshNode",
        body: String(body || ""),
        tsRaw,
        ts: formatTimestamp(tsRaw),
        type: overrides.type || "mesh",
        source: overrides.source || "mesh",
        direction,
        failed: overrides.failed || false,
        ...overrides
      };
      const similar = findSimilarMessage(msg.body, channelId, tsRaw);
      if (similar) {
        markMessageMesh(similar);
        renderMessages(false, { preserveScroll: true });
        renderChannels();
        return similar;
      }
      msg.sourceMask = SOURCE_MASK.MESH;
      const merged = mergeMappedMessages(appData.messages || [], [msg]);
      appData.messages = merged;
      updateChannelTracking(msg, direction === "in");
      renderMessages(false, { preserveScroll: true });
      renderChannels();
      return msg;
    }

    function setComposerEnabled(enabled, note) {
      const composer = document.getElementById("nodeComposerInput");
      const sendBtn = document.getElementById("nodeComposerSend");
      const status = document.getElementById("nodeComposerStatus");
      if (composer) composer.disabled = !enabled;
      if (sendBtn) sendBtn.disabled = !enabled;
      if (status) {
        if (note) status.textContent = note;
        else status.textContent = enabled
          ? `Connected to ${nodeSerialService.getMeta()?.label || "node"}.`
          : nodeComposerDefaultStatus;
      }
    }

    function loadAutoResponderConfig() {
      const defaults = { enabled: false, channel: "#test", delay: 5 };
      try {
        const raw = localStorage.getItem(AUTO_RESPONDER_STORAGE_KEY);
        if (!raw) return defaults;
        const parsed = JSON.parse(raw);
        const delayValue = Number.isFinite(Number(parsed.delay)) ? Math.min(20, Math.max(1, Number(parsed.delay))) : defaults.delay;
        return {
          enabled: Boolean(parsed.enabled),
          channel: formatResponderChannel(parsed.channel || defaults.channel),
          delay: delayValue
        };
      } catch (err) {
        return defaults;
      }
    }

    const autoResponderTimers = new Map();

    function saveAutoResponderConfig(config) {
      try {
        localStorage.setItem(AUTO_RESPONDER_STORAGE_KEY, JSON.stringify({
          enabled: !!config.enabled,
          channel: String(config.channel || "#test"),
          delay: Number.isFinite(Number(config.delay)) ? Number(config.delay) : 5
        }));
      } catch {}
    }

    function updateAutoResponderControls() {
      const config = appData.autoResponderConfig;
      const toggle = document.getElementById("autoResponderToggle");
      const channelInput = document.getElementById("autoResponderChannel");
      const delayInput = document.getElementById("autoResponderDelay");
      const delayLabel = document.getElementById("autoResponderDelayValue");
      const status = document.getElementById("autoResponderStatus");
      if (toggle) toggle.textContent = config.enabled ? "Disable auto-responder" : "Enable auto-responder";
      if (channelInput) channelInput.value = config.channel;
      if (delayInput) delayInput.value = String(config.delay);
      if (delayLabel) delayLabel.textContent = `${config.delay}s`;
      if (status) status.textContent = config.enabled ? "Active" : "Paused";
    }

    function formatResponderChannel(value) {
      const raw = String(value || "").trim();
      if (!raw) return "#test";
      return raw.startsWith("#") ? raw : `#${raw}`;
    }

    function clearAutoResponderTimers() {
      autoResponderTimers.forEach((timer) => clearTimeout(timer));
      autoResponderTimers.clear();
    }

    function updateNodeConnectionDisplay(isConnected, meta, note) {
      appData.nodeConnected = !!isConnected;
      const statusDot = document.getElementById("nodeStatusDot");
      const connectBtn = document.getElementById("connectNodeBtn");
      const statusText = document.getElementById("nodeStatusText");
      const hint = document.getElementById("nodeConnectionHint");
      if (statusDot) statusDot.classList.toggle("connected", !!isConnected);
      if (connectBtn) {
        connectBtn.classList.toggle("primary", !!isConnected);
        connectBtn.textContent = isConnected ? "Disconnect node" : "Connect node";
      }
      if (statusText) {
        statusText.textContent = note || (isConnected ? "Connected" : "Not connected");
      }
      if (hint) {
        hint.style.display = nodeSerialService.isSupported() ? "none" : "block";
      }
      setComposerEnabled(!!isConnected, note);
      if (!isConnected) {
        clearAutoResponderTimers();
      }
      renderMessages(true);
    }

    async function handleNodeConnectToggle() {
      const connectBtn = document.getElementById("connectNodeBtn");
      if (!nodeSerialService.isSupported()) return;
      if (nodeSerialService.isConnected()) {
        await nodeSerialService.disconnect();
        updateNodeConnectionDisplay(false);
        return;
      }
      if (connectBtn) connectBtn.disabled = true;
      try {
        const { meta, info } = await nodeSerialService.connect();
        const noteParts = [];
        if (info?.firmwareVersion) noteParts.push(`fw=${info.firmwareVersion}`);
        if (info?.protocolVersion) noteParts.push(`proto=${info.protocolVersion}`);
        if (info?.selfName) noteParts.push(info.selfName);
        const note = noteParts.length ? `Connected (${noteParts.join(", ")})` : "Connected";
        updateNodeConnectionDisplay(true, meta, note);
      } catch (err) {
        const message = err?.message || "Connection failed";
        updateNodeConnectionDisplay(false, null, message);
        showToast(`Node connection failed: ${message}`);
      } finally {
        if (connectBtn) connectBtn.disabled = false;
      }
    }

    async function handleNodeComposerSend() {
      const composer = document.getElementById("nodeComposerInput");
      const sendBtn = document.getElementById("nodeComposerSend");
      if (!composer || !sendBtn) return;
      const text = composer.value.trim();
      if (!text) return;
      composer.value = "";
      sendBtn.disabled = true;
      const outgoing = appendNodeMessage(text, "out");
      try {
        const channelIdx = channelIdToIndex(activeChannelId);
        await nodeSerialService.sendMessage(text, channelIdx);
      } catch (err) {
        outgoing.failed = true;
        showToast(`Mesh send failed: ${err?.message || err}`);
        renderMessages(false, { preserveScroll: true });
      } finally {
        sendBtn.disabled = !nodeSerialService.isConnected();
      }
    }

    function initNodeSerialControls() {
      const connectBtn = document.getElementById("connectNodeBtn");
      connectBtn?.addEventListener("click", handleNodeConnectToggle);
      const sendBtn = document.getElementById("nodeComposerSend");
      sendBtn?.addEventListener("click", handleNodeComposerSend);
      const composer = document.getElementById("nodeComposerInput");
      composer?.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleNodeComposerSend();
        }
      });
      const autoToggle = document.getElementById("autoResponderToggle");
      const autoChannel = document.getElementById("autoResponderChannel");
      const autoDelay = document.getElementById("autoResponderDelay");
      autoToggle?.addEventListener("click", () => {
        appData.autoResponderConfig.enabled = !appData.autoResponderConfig.enabled;
        if (!appData.autoResponderConfig.enabled) {
          clearAutoResponderTimers();
        }
        saveAutoResponderConfig(appData.autoResponderConfig);
        updateAutoResponderControls();
      });
      autoChannel?.addEventListener("change", () => {
        appData.autoResponderConfig.channel = formatResponderChannel(autoChannel.value);
        saveAutoResponderConfig(appData.autoResponderConfig);
        updateAutoResponderControls();
      });
      autoDelay?.addEventListener("input", () => {
        appData.autoResponderConfig.delay = Number(autoDelay.value);
        saveAutoResponderConfig(appData.autoResponderConfig);
        updateAutoResponderControls();
      });
      const nodeControls = document.getElementById("nodeControlsContainer");
      if (!nodeSerialService.isSupported()) {
        if (connectBtn) connectBtn.disabled = true;
        if (nodeControls) nodeControls.classList.add("hidden");
        const hint = document.getElementById("nodeConnectionHint");
        if (hint) hint.style.display = "block";
      } else {
        if (nodeControls) nodeControls.classList.remove("hidden");
        const hint = document.getElementById("nodeConnectionHint");
        if (hint) hint.style.display = "none";
      }
      updateNodeConnectionDisplay(false);
      updateAutoResponderControls();
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function hasValidGps(r) {
      const lat = r?.gps?.lat;
      const lon = r?.gps?.lon;
      return Number.isFinite(lat) && Number.isFinite(lon) && !(lat === 0 && lon === 0);
    }

    function isRepeaterHidden(r) {
      if (!r) return false;
      if (r.hiddenOnMap) return true;
      if (r.gpsImplausible || r.gpsFlagged) return true;
      return !hasValidGps(r);
    }

    function hasMapHideEmoji(r) {
      const name = String(r?.name || "");
      return name.includes(MAP_HIDE_EMOJI);
    }

    function isNeighborHidden(neighbor) {
      if (!neighbor) return false;
      const hash = String(neighbor.hash || "").toUpperCase();
      const hiddenSet = appData.hiddenRepeaterHashes || new Set();
      if (hash && hiddenSet.has(hash)) return true;
      return hasMapHideEmoji(neighbor);
    }

    function confidence(msg) {
      const repeats = msg.repeats || msg.pathLength || 1;
      const observerCount = Number.isFinite(msg.observerCount)
        ? msg.observerCount
        : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
      const repeatScore = clamp(repeats / 8, 0, 1);
      const observerScore = clamp(observerCount / 3, 0, 1);
      const score = 100 * clamp(0.2 + (0.5 * repeatScore) + (0.3 * observerScore), 0, 1);
      return Math.round(score);
    }

    function mapObserverLabels(list) {
      const byId = appData.observersById || {};
      const byIdUpper = appData.observersByIdUpper || {};
      const byName = appData.observersByName || {};
      const byNameLower = appData.observersByNameLower || {};
      const rawList = Array.isArray(list) ? list : [];
      return rawList.map((raw) => {
        const key = String(raw || "").trim();
        if (!key) return "";
        const upper = key.toUpperCase();
        const lower = key.toLowerCase();
        const entry = byId[key] || byIdUpper[upper] || byName[key] || byNameLower[lower] || null;
        return entry?.name || entry?.id || key;
      }).filter(Boolean);
    }

    function resolveObserverLabel(raw) {
      const key = String(raw || "").trim();
      if (!key) return "";
      const upper = key.toUpperCase();
      const lower = key.toLowerCase();
      const entry =
        appData.observersById?.[key] ||
        appData.observersByIdUpper?.[upper] ||
        appData.observersByName?.[key] ||
        appData.observersByNameLower?.[lower] ||
        null;
      return entry?.name || entry?.id || key;
    }

    function normalizeChannelId(value) {
      return String(value || "").trim().replace(/^#/, "").toLowerCase();
    }

    function normalizeChannelName(value) {
      const raw = String(value || "").trim();
      if (!raw) return null;
      return raw.startsWith("#") ? raw : `#${raw}`;
    }

    function loadAuthToken() {
      try {
        return localStorage.getItem("mesh_session_token");
      } catch {
        return null;
      }
    }

    function setRankLoading(show) {
      const el = document.getElementById("rankLoading");
      if (!el) return;
      el.classList.toggle("active", !!show);
    }

    function setObserverRankLoading(show) {
      const el = document.getElementById("observerRankLoading");
      if (!el) return;
      el.classList.toggle("active", !!show);
    }

    function formatRelativeMinutes(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) return "--";
      if (totalMinutes < 60) return `${Math.round(totalMinutes)}m ago`;
      const hours = Math.round(totalMinutes / 60);
      if (hours < 48) return `${hours}h ago`;
      const days = Math.round(totalMinutes / (60 * 24));
      return `${days}d ago`;
    }

    function saveAuthToken(token) {
      try {
        if (token) localStorage.setItem("mesh_session_token", token);
        else localStorage.removeItem("mesh_session_token");
      } catch {}
    }

    let toastTimer = null;
    function showToast(message) {
      const toast = document.getElementById("toast");
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add("show");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toast.classList.remove("show");
      }, 2600);
    }

    function loadCachedUserChannels() {
      try {
        const raw = localStorage.getItem("meshrank.userChannels.cached");
        const parsed = JSON.parse(raw || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveCachedUserChannels(channels) {
      try {
        localStorage.setItem("meshrank.userChannels.cached", JSON.stringify(channels || []));
      } catch {}
    }

    function loadMutedChannels() {
      try {
        const raw = localStorage.getItem("meshrank.mutedChannels");
        const parsed = JSON.parse(raw || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveMutedChannels(channels) {
      try {
        localStorage.setItem("meshrank.mutedChannels", JSON.stringify(channels || []));
      } catch {}
    }

    function isChannelMuted(channelId) {
      return appData.mutedChannels.includes(channelId);
    }

    const GUEST_CHANNELS_KEY = "meshrank.guestChannels.v2";
    function loadGuestChannels() {
      try {
        localStorage.removeItem("meshrank.guestChannels");
        const raw = localStorage.getItem(GUEST_CHANNELS_KEY);
        const parsed = JSON.parse(raw || "[]");
        if (!Array.isArray(parsed)) return [];
        const cleaned = parsed.map((item) => {
          if (typeof item === "string") return normalizeChannelName(item);
          if (item && typeof item === "object") {
            return normalizeChannelName(item.name || item.channel || item.channelName || "");
          }
          return null;
        }).filter(Boolean);
        const unique = Array.from(new Set(cleaned));
        if (unique.length !== parsed.length) {
          localStorage.setItem(GUEST_CHANNELS_KEY, JSON.stringify(unique));
        }
        return unique;
      } catch {
        return [];
      }
    }

    function saveGuestChannels(list) {
      try {
        const cleaned = (list || []).map((item) => normalizeChannelName(item)).filter(Boolean);
        const unique = Array.from(new Set(cleaned));
        localStorage.setItem(GUEST_CHANNELS_KEY, JSON.stringify(unique));
      } catch {}
    }

    function isGuestChannel(name) {
      const id = normalizeChannelId(name);
      return (appData.guestChannels || []).some((c) => normalizeChannelId(c) === id);
    }

    function loadDismissedChannels() {
      try {
        const raw = localStorage.getItem("meshrank.dismissedChannels");
        const parsed = JSON.parse(raw || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveDismissedChannels(list) {
      try {
        localStorage.setItem("meshrank.dismissedChannels", JSON.stringify(list || []));
      } catch {}
    }

    function isDismissedChannel(name) {
      const id = normalizeChannelId(name);
      return (appData.dismissedChannels || []).some((c) => normalizeChannelId(c) === id);
    }

    function loadChannelHistoryLimit() {
      try {
        const raw = localStorage.getItem("meshrank.channelHistoryLimit");
        const value = Number(raw);
        if (Number.isFinite(value) && value >= 1 && value <= 50) return value;
      } catch {}
      return 10;
    }

    function saveChannelHistoryLimit(value) {
      try {
        localStorage.setItem("meshrank.channelHistoryLimit", String(value));
      } catch {}
    }

    function authHeaders() {
      const token = appData.authToken || loadAuthToken();
      if (!token) return {};
      return { Authorization: `Bearer ${token}` };
    }

    function updateRotmNavVisibility() {
      const showRotm = !!appData.authUser?.isAdmin;
      document.querySelectorAll("[data-view='rotm']").forEach((link) => {
        link.style.display = showRotm ? "" : "none";
      });
    }

    function updateNodeRankVisibility() {
      const showNodeRank = !!appData.authUser?.isAdmin;
      document.querySelectorAll("[data-view='node-rank']").forEach((link) => {
        link.style.display = showNodeRank ? "" : "none";
      });
    }

    function updateRepeaterRankVisibility() {
      const showRank = !!appData.authUser?.isAdmin;
      document.querySelectorAll("[data-view='rank']").forEach((link) => {
        link.style.display = showRank ? "" : "none";
      });
    }

    function setAuthUser(user) {
      appData.authUser = user || null;
      const btn = document.getElementById("loginBtn");
      if (btn) {
        const label = user ? (user.displayName || user.username) : "Login";
        btn.textContent = label;
      }
      document.querySelectorAll(".auth-only").forEach((el) => {
        el.style.display = user ? "" : "none";
      });
      const isAdmin = !!user?.isAdmin;
      document.body.classList.toggle("is-admin", isAdmin);
      const addBtn = document.getElementById("addChannelBtn");
      if (addBtn) addBtn.disabled = false;
      document.querySelectorAll(".admin-only").forEach((el) => {
        if (!isAdmin) {
          el.style.display = "none";
          return;
        }
        if (el.classList.contains("repeater-location-controls")) {
          el.style.display = "flex";
          return;
        }
        if (el.classList.contains("panel") || el.classList.contains("modal")) {
          el.style.display = "";
          return;
        }
        el.style.display = "inline-flex";
      });
      if (isAdmin) {
        fetchRotmConfig()
          .then((cfg) => {
            if (cfg?.channel) appData.rotmChannelName = cfg.channel;
            renderChannels();
          })
          .catch(() => {});
      }
      updateNodeRankVisibility();
      renderChannels();
      updateLoginHelper();
      maybeShowChangesModal();
      updateRotmNavVisibility();
      if (user) {
        loadAccountData().catch(() => {});
        syncGuestChannelsToAccount().catch(() => {});
      } else {
        renderAccountSummary();
      }
    }

    function maybeShowChangesModal() {
      if (!appData.authUser) return;
      const key = "meshrank.channels.update.v1";
      try {
        if (localStorage.getItem(key)) return;
        const modal = document.getElementById("changesModal");
        modal?.classList.add("open");
        localStorage.setItem(key, "1");
      } catch {}
    }

    function updateLoginHelper() {
      const banner = document.getElementById("loginHelper");
      if (!banner) return;
      const isMessagesView = document.body.classList.contains("view-channels");
      const hasUser = !!appData.authUser;
      const hasSelection = hasUser
        ? (appData.userChannels || []).length > 0
        : (appData.guestChannels || []).length > 0;
      const cached = loadCachedUserChannels();
      if (!hasUser && cached.length) {
        banner.textContent = "Youre on a new browser. Log in to restore your personalised feed.";
      } else {
        banner.textContent = "Cant see your channels? Please log in or sign up to manage them.";
      }
      const show = isMessagesView && (!hasUser || !hasSelection);
      banner.style.display = show ? "block" : "none";
    }

    async function syncGuestChannelsToAccount() {
      if (!appData.authUser) return;
      const fixed = new Set(["#public", "#meshranksuggestions", "#test"]);
      const pending = (appData.guestChannels || []).filter((name) => !fixed.has(normalizeChannelName(name)));
      if (!pending.length) return;
      try {
        await Promise.allSettled(pending.map((name) =>
          fetch("/api/user/channels/join", {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ channelName: name })
          })
        ));
        appData.guestChannels = [];
        saveGuestChannels([]);
        await loadChannels();
        await loadChannelDirectory();
      } catch {}
    }

    function setBootstrapVisibility(hasAdmin) {
      const btn = document.getElementById("authBootstrap");
      if (!btn) return;
      btn.style.display = hasAdmin ? "none" : "inline-flex";
    }

    function updateNodeRankVisibility() {
      const isAuthed = !!appData.authUser;
      document.querySelectorAll('[data-view="node-rank"]').forEach((el) => {
        el.style.display = isAuthed ? "" : "none";
      });
      if (!isAuthed && document.body.classList.contains("view-node-rank")) {
        setView("channels");
      }
    }

    let googleInitTimer = null;

    function setView(view) {
      if (view !== "rank") cancelRankLoad();
      const views = [
        "channels",
        "channel-directory",
        "rotm",
        "rank",
        "node-rank",
        "meshscore",
        "rf",
        "observer",
        "observer-rank",
        "why",
        "terms",
        "privacy",
        "auth",
        "account"
      ];
      views.forEach((name) => {
        document.body.classList.toggle(`view-${name}`, name === view);
      });
      document.querySelectorAll(".nav a, .mobile-nav a, .mobile-menu a").forEach((l) => {
        l.classList.toggle("active", l.dataset.view === view);
      });
      if (view !== "channels") updateChannelParam(null);
      updateLoginHelper();
    }

    tryInitGoogleSignin();
    if (!googleInitTimer) {
      googleInitTimer = window.setInterval(tryInitGoogleSignin, 500);
    }


    function renderMeshLivePayload(payload) {
      if (!payload) return;
      const packetRateEl = document.getElementById("meshLivePacketRate");
      if (packetRateEl) {
        packetRateEl.textContent = payload.packetRate ? payload.packetRate.toLocaleString() : "0";
      }
      const repeaterCountEl = document.getElementById("meshLiveRepeaterCount");
      const repeaters = Array.isArray(payload.repeaters) ? payload.repeaters : [];
      if (repeaterCountEl) {
        repeaterCountEl.textContent = repeaters.length.toLocaleString();
      }
      const dailyEl = document.getElementById("meshLiveDaily");
      const dailyStats = payload.daily || {};
      const todayScore = dailyStats.today?.score;
      const diffScore = dailyStats.diff?.score;
      const diffMsgs = dailyStats.diff?.messages;
      if (dailyEl) {
        dailyEl.innerHTML = `
          <div>MeshRank today: <strong>${todayScore?.toFixed(1) ?? "--"}</strong></div>
          <div>Change: <strong>${diffScore ? `${diffScore > 0 ? "+" : ""}${diffScore.toFixed(1)}` : "--"}</strong></div>
          <div>Msgs : <strong>${diffMsgs ? `${diffMsgs > 0 ? "+" : ""}${diffMsgs}` : "--"}</strong></div>
        `;
      }
      const changeEl = document.getElementById("meshLiveDailyChange");
      if (changeEl) {
        const scoreText = diffScore ? `${diffScore > 0 ? "+" : ""}${diffScore.toFixed(1)} pts` : "--";
        const msgText = diffMsgs ? `${diffMsgs > 0 ? "+" : ""}${diffMsgs} msgs` : "--";
        changeEl.textContent = `${scoreText} / ${msgText}`;
      }
      const listEl = document.getElementById("meshLiveList");
      if (listEl) {
        listEl.innerHTML = repeaters.slice(0, 6).map((item) => {
          const name = item.name || item.pub || item.hash || "Unnamed";
          const score = Number.isFinite(item.score) ? `${item.score.toFixed(1)} pts` : "Score n/a";
          const total = Number.isFinite(item.total24h) ? item.total24h : 0;
          return `
            <div class="mesh-live-list-item">
              <div>
                <strong>${name}</strong>
                <div class="muted">${score}</div>
              </div>
              <span class="mesh-live-badge">24h ${total}</span>
            </div>
          `;
        }).join("");
      }
    }

    async function loadMeshLivePayload() {
      try {
        const res = await fetch("/api/mesh-live");
        const payload = await res.json();
        if (!payload?.ok) return;
        renderMeshLivePayload(payload);
      } catch (err) {
        console.error("MeshLive refresh failed", err);
      }
    }

    function startMeshLivePolling() {
      if (appData.meshLive.polling) return;
      loadMeshLivePayload();
      appData.meshLive.polling = window.setInterval(loadMeshLivePayload, 8000);
    }

    function stopMeshLivePolling() {
      if (!appData.meshLive.polling) return;
      clearInterval(appData.meshLive.polling);
      appData.meshLive.polling = null;
    }

    function formatVisitorNumber(value) {
      if (!Number.isFinite(value)) return "0";
      return value.toLocaleString();
    }

    function updateVisitorDisplay() {
      const stats = appData.visitorStats || {};
      const entries = [
        { id: "visitorActive", value: stats.active },
        { id: "visitorRate1m", value: stats.rate1m },
        { id: "visitorRate1h", value: stats.rate1h },
        { id: "visitorPeak", value: stats.peak }
      ];
      entries.forEach(({ id, value }) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.textContent = formatVisitorNumber(value);
      });
    }

    function applyVisitorStats(payload) {
      if (!payload) return;
      appData.visitorStats = {
        active: Number.isFinite(payload.active) ? payload.active : 0,
        rate1m: Number.isFinite(payload.rate1m) ? payload.rate1m : 0,
        rate1h: Number.isFinite(payload.rate1h) ? payload.rate1h : 0,
        peak: Number.isFinite(payload.peak) ? payload.peak : 0
      };
      updateVisitorDisplay();
    }

    async function handleGoogleCredentialResponse(response) {
      if (!response?.credential) return;
      try {
        const res = await fetch("/api/auth/google-id-token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ credential: response.credential })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) throw new Error(data.error || "Google login failed.");
        appData.authToken = data.token || null;
        saveAuthToken(appData.authToken);
        setAuthUser(data.user || null);
        await loadChannels();
        setView("channels");
        setAuthFlowMode("email");
      } catch (err) {
        showToast(err?.message || "Google login failed.");
      }
    }

    function initGoogleSigninButton() {
      const btn = document.getElementById("gsiButton");
      const fallback = document.getElementById("gsiFallback");
      const clientId = window.meshConfig?.googleClientId || "";
      if (!btn) return;
      if (!clientId) {
        if (fallback) fallback.style.display = "block";
        btn.innerHTML = "<div class='muted'>Google login is not configured.</div>";
        return;
      }
      if (!window.google?.accounts?.id) return;
      if (appData.googleInitialized) return;
      google.accounts.id.initialize({
        client_id: clientId,
        callback: handleGoogleCredentialResponse,
        ux_mode: "popup"
      });
      google.accounts.id.renderButton(btn, {
        type: "standard",
        size: "large",
        theme: "outline",
        text: "sign_in_with",
        shape: "rectangular",
        logo_alignment: "left"
      });
      appData.googleInitialized = true;
      if (fallback) fallback.style.display = "none";
    }

    function tryInitGoogleSignin() {
      const clientId = window.meshConfig?.googleClientId;
      if (!clientId) {
        const fallback = document.getElementById("gsiFallback");
        if (fallback) fallback.style.display = "block";
        return;
      }
      if (appData.googleInitialized) return;
      if (window.google && window.google.accounts && window.google.accounts.id) {
        initGoogleSigninButton();
        if (googleInitTimer) {
          clearInterval(googleInitTimer);
          googleInitTimer = null;
        }
      }
    }

    function renderAccountSummary() {
      const summary = document.getElementById("accountSummary");
      if (!summary) return;
      if (!appData.authUser) {
        summary.textContent = "Not logged in.";
        return;
      }
      const label = appData.authUser.displayName || appData.authUser.username;
      summary.textContent = `Logged in as ${label}`;
    }

    function renderAccountNodes() {
      const list = document.getElementById("accountNodes");
      if (!list) return;
      if (!appData.authUser) {
        list.innerHTML = "<div class='muted'>Log in to claim your nodes.</div>";
        return;
      }
      if (!appData.userNodes.length) {
        list.innerHTML = "<div class='muted'>No nodes claimed yet.</div>";
        return;
      }
      list.innerHTML = appData.userNodes.map((node) => `
        <div class="account-item">
          <div>
            <div><strong>${node.public_id}</strong></div>
            <div class="muted">${new Date(node.created_at).toLocaleDateString()}</div>
          </div>
          <button class="btn btn-ghost" type="button" data-node-unclaim="${node.public_id}">Unclaim</button>
        </div>
      `).join("");
      list.querySelectorAll("[data-node-unclaim]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const pub = btn.getAttribute("data-node-unclaim");
          if (!pub) return;
          try {
            const res = await fetch("/api/user/nodes/unclaim", {
              method: "POST",
              headers: { "Content-Type": "application/json", ...authHeaders() },
              body: JSON.stringify({ publicNodeId: pub })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || !data.ok) throw new Error(data.error || "Unclaim failed.");
            appData.userNodes = data.nodes || [];
            renderAccountNodes();
          } catch (err) {
            showToast(err?.message || String(err));
          }
        });
      });
    }

    function renderAccountChannels() {
      const list = document.getElementById("accountChannels");
      if (!list) return;
      if (!appData.authUser) {
        list.innerHTML = "<div class='muted'>Log in to manage your channels.</div>";
        return;
      }
      if (!appData.userChannels.length) {
        list.innerHTML = "<div class='muted'>No channels joined yet.</div>";
        return;
      }
      list.innerHTML = appData.userChannels.map((name) => `
        <div class="account-item">
          <div>${name}</div>
          <button class="btn btn-ghost" type="button" data-channel-leave="${name}">Leave</button>
        </div>
      `).join("");
      list.querySelectorAll("[data-channel-leave]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const name = btn.getAttribute("data-channel-leave");
          if (!name) return;
          try {
            const res = await fetch("/api/user/channels/leave", {
              method: "POST",
              headers: { "Content-Type": "application/json", ...authHeaders() },
              body: JSON.stringify({ channelName: name })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || !data.ok) throw new Error(data.error || "Unable to leave channel.");
            await loadChannels();
            await loadChannelDirectory();
            renderAccountChannels();
          } catch (err) {
            showToast(err?.message || String(err));
          }
        });
      });
    }

    async function loadAccountData() {
      if (!appData.authUser) return;
      renderAccountSummary();
      try {
        const [channelsRes, nodesRes] = await Promise.all([
          fetch("/api/user/channels", { headers: authHeaders(), cache: "no-store" }),
          fetch("/api/user/nodes", { headers: authHeaders(), cache: "no-store" })
        ]);
        if (channelsRes.ok) {
          const data = await channelsRes.json().catch(() => ({}));
          if (Array.isArray(data.userChannels)) {
            appData.userChannels = data.userChannels;
            saveCachedUserChannels(data.userChannels);
          }
        }
        if (nodesRes.ok) {
          const data = await nodesRes.json().catch(() => ({}));
          appData.userNodes = data.nodes || [];
        }
      } catch {}
      renderAccountChannels();
      renderAccountNodes();
    }

    async function fetchAuthMe() {
      const res = await fetch("/api/auth/me", { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) return null;
      const data = await res.json();
      return data.user || null;
    }

    async function fetchDashboard(channelName, limit) {
      const url = new URL("/api/dashboard", window.location.origin);
      if (channelName) url.searchParams.set("channel", channelName);
      if (Number.isFinite(limit) && limit > 0) url.searchParams.set("limit", String(limit));
      const res = await fetch(url.toString(), { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function fetchChannelDirectory() {
      const res = await fetch("/api/channel-directory", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function fetchPopularChannels(limit = 6) {
      const url = new URL("/api/channels/popular", window.location.origin);
      url.searchParams.set("limit", String(limit));
      const res = await fetch(url.toString(), { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      return Array.isArray(data.popular) ? data.popular : [];
    }

    async function fetchChannelPreview(channelName, limit = 10) {
      const url = new URL("/api/messages", window.location.origin);
      url.searchParams.set("channel", channelName);
      url.searchParams.set("limit", String(limit));
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      return Array.isArray(data.messages) ? data.messages : [];
    }

    function buildDirectoryActions(name, isJoined, isBlocked) {
      return `
        <div class="directory-actions">
          <button class="btn btn-ghost" type="button" data-channel-view="${name}">View</button>
          <button class="btn" type="button" data-channel-join="${name}" ${isJoined || isBlocked ? "disabled" : ""}>${isJoined ? "Joined" : "Join"}</button>
          <button class="btn btn-ghost" type="button" data-channel-dismiss="${name}">Not interested</button>
        </div>
      `;
    }

    function buildDirectoryCard(item, joined) {
      const name = item.name || "#unknown";
      const emoji = item.emoji || "";
      const count = item.messageCount24h ?? item.messages ?? 0;
      const last = item.lastMessageAt ? new Date(item.lastMessageAt).toLocaleTimeString() : null;
      const meta = last
        ? `${count} messages (24h)  Last activity ${last}`
        : `${count} messages (24h)`;
      return `
        <div class="directory-card">
          <h4 style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
            <span>${emoji} ${name}</span>
            ${count ? `<span class="badge-bubble">${count}</span>` : ""}
          </h4>
          <div class="muted">${meta}</div>
          ${buildDirectoryActions(name, joined, false)}
        </div>
      `;
    }

    function buildDirectoryRow(item, joined) {
      const name = item.name || "#unknown";
      const emoji = item.emoji || "";
      const group = item.group || "";
      const code = item.code || getChannelCode(item.name || "") || "";
      const allowPopular = item.allowPopular !== false;
      const count24h = Number(item.messageCount24h || 0);
      const metaText = count24h
        ? `${count24h} message${count24h === 1 ? "" : "s"} (24h)`
        : "No recent activity";
      const isAdmin = !!appData.authUser?.isAdmin;
      const isBlocked = item.blocked === true;
      return `
        <div class="directory-row ${joined ? "joined" : ""} ${isBlocked ? "blocked" : ""}" data-channel-name="${name}" data-channel-group="${group}" data-channel-code="${code}" data-channel-emoji="${emoji}" data-channel-popular="${allowPopular ? "1" : "0"}" data-channel-blocked="${isBlocked ? "1" : "0"}">
          <div class="row-main">
            <div class="row-title">${emoji} ${name}${count24h ? ` <span class="badge-bubble">${count24h}</span>` : ""}${isBlocked ? ` <span class="badge badge-gray">Blocked</span>` : ""}</div>
            <div class="row-meta">${metaText}</div>
          </div>
          <div class="row-actions">
            ${buildDirectoryActions(name, joined, isBlocked)}
            ${isAdmin ? `<button class="btn btn-ghost" type="button" data-channel-edit="${name}">Edit</button>` : ""}
          </div>
        </div>
      `;
    }

    function renderPopularChannels(list) {
      const popularEl = document.getElementById("popularChannels");
      if (!popularEl) return;
      const joined = new Set((appData.userChannels || []).map((name) => String(name || "").toLowerCase()));
      const dismissed = new Set((appData.dismissedChannels || []).map((name) => String(name || "").toLowerCase()));
      if (!list.length) {
        popularEl.innerHTML = "<div class='directory-card'>No popular channels yet.</div>";
        return;
      }
      const skipPopular = new Set(FIXED_CHANNELS.map((name) => normalizeChannelName(name)).filter(Boolean));
      const filtered = list
        .filter((row) => !dismissed.has(String(row.name || "").toLowerCase()))
        .filter((row) => {
          const normalized = normalizeChannelName(row.name);
          if (!normalized) return false;
          if (skipPopular.has(normalized)) return false;
          if (isRotmChannel(normalized) && !appData.authUser?.isAdmin) return false;
          return true;
        });
      if (!filtered.length) {
        popularEl.innerHTML = "<div class='directory-card'>No popular channels yet.</div>";
        return;
      }
      popularEl.innerHTML = filtered.map((row) => {
        const name = row.name || "#unknown";
        const isJoined = joined.has(String(name || "").toLowerCase());
        return buildDirectoryCard(row, isJoined);
      }).join("");
    }

    function renderGroupedChannels(groups) {
      const groupsEl = document.getElementById("groupedChannels");
      if (!groupsEl) return;
      const joined = new Set((appData.userChannels || []).map((name) => String(name || "").toLowerCase()));
      const groupKeys = Object.keys(groups || {});
      groupsEl.innerHTML = groupKeys.map((group) => {
        const list = groups[group] || [];
        const expanded = appData.directoryGroupState[group] === true;
        const collapsed = !expanded;
        const groupFlag = appData.channelGroupFlags[group] || {};
        const newCount = Number(groupFlag.newChannelCount || 0);
        const badgeHtml = newCount ? `<span class="directory-group-badge">${newCount} new</span>` : "";
        const filtered = list.filter((item) => {
          const normalized = normalizeChannelName(item.name);
          return normalized && (!isRotmChannel(normalized) || appData.authUser?.isAdmin);
        });
        const rows = filtered.map((item) => {
          const name = item.name || "#unknown";
          const isJoined = joined.has(String(name || "").toLowerCase());
          return buildDirectoryRow({ ...item, group }, isJoined);
        }).join("");
        return `
          <div class="directory-group ${collapsed ? "collapsed" : ""}" data-group="${group}">
            <div class="directory-group-header">
              <h4 data-group-toggle="${group}">
                <span class="directory-group-toggle">${collapsed ? "+" : ""}</span>
                <span class="directory-group-title">
                  <span class="directory-group-name">${group}</span>
                  ${badgeHtml}
                </span>
              </h4>
            </div>
            <div class="directory-group-body">${rows || "<div class='muted'>No channels yet.</div>"}</div>
          </div>
        `;
      }).join("");
    }

    async function joinChannel(channelName) {
      if (!appData.authUser) {
        const fixed = new Set(["#public", "#meshranksuggestions", "#test"]);
        const normalized = normalizeChannelName(channelName);
        if (!normalized || fixed.has(normalized)) return false;
        const blocked = (appData.channelDirectory?.groups && Object.values(appData.channelDirectory.groups).some((list) =>
          list.some((row) => normalizeChannelName(row.name) === normalized && row.blocked)
        )) || false;
        if (blocked) {
          showToast("This channel is blocked.");
          return false;
        }
        appData.guestChannels = [...new Set([...(appData.guestChannels || []), normalized])];
        saveGuestChannels(appData.guestChannels);
        await loadChannels();
        await loadChannelDirectory();
        return true;
      }
      try {
        const res = await fetch("/api/user/channels/join", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ channelName })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) throw new Error(data.error || "Join failed.");
        await loadChannels();
        await loadChannelDirectory();
        if (document.body.classList.contains("view-channel-directory")) {
          try {
            const popular = await fetchPopularChannels(6);
            appData.channelDirectory = appData.channelDirectory || { groups: {} };
            appData.channelDirectory.popular = popular;
          } catch {}
          renderPopularChannels(appData.channelDirectory?.popular || []);
          renderGroupedChannels(appData.channelDirectory?.groups || {});
          attachChannelDirectoryHandlers();
        }
        return true;
      } catch (err) {
        showToast(err?.message || String(err));
        return false;
    }
  }

    function isRotmChannel(channelName) {
      return normalizeChannelName(channelName) === normalizeChannelName("#rotm");
    }

    function findChannelDirectoryEntry(name) {
      const normalized = normalizeChannelName(name);
      if (!normalized) return null;
      const directory = appData.channelDirectory || {};
      const popular = directory.popular || [];
      const groups = directory.groups || {};
      for (const entry of popular) {
        if (normalizeChannelName(entry.name) === normalized) return entry;
      }
      for (const list of Object.values(groups)) {
        for (const entry of list || []) {
          if (normalizeChannelName(entry.name) === normalized) return entry;
        }
      }
      return null;
    }

    function getChannelCode(name) {
      const entry = findChannelDirectoryEntry(name);
      return entry?.code || entry?.description || "";
    }

    async function showChannelPreview(channelName) {
      if (!channelPreviewModal || !channelPreviewBody) return;
      if (channelPreviewTitle) channelPreviewTitle.textContent = `${channelName} (last 10)`;
      channelPreviewBody.textContent = "Loading last 10 messages...";
      channelPreviewModal.classList.add("open");
      try {
        const rows = await fetchChannelPreview(channelName, 10);
        if (!rows.length) {
          channelPreviewBody.textContent = "No recent messages.";
          return;
        }
        channelPreviewBody.innerHTML = rows.map((m) => {
          const rawTs = m.ts || m.tsRaw || m.time || "";
          const time = rawTs ? new Date(rawTs).toLocaleTimeString() : "--";
          const sender = m.sender || "unknown";
          const text = (m.body || m.text || "").slice(0, 140);
          return `
            <div class="preview-item">
              <span class="preview-text">${sender}: ${text}</span>
              <span>${time}</span>
            </div>
          `;
        }).join("");
      } catch (err) {
        channelPreviewBody.textContent = "Unable to load messages.";
      }
    }

    function attachChannelDirectoryHandlers() {
      document.querySelectorAll("[data-channel-view]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const channel = btn.getAttribute("data-channel-view");
          if (channel) showChannelPreview(channel);
        });
      });
      document.querySelectorAll("[data-channel-join]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const channel = btn.getAttribute("data-channel-join");
          if (!channel || btn.disabled) return;
          btn.disabled = true;
          btn.textContent = "Joined";
          const ok = await joinChannel(channel);
          if (ok && !appData.authUser) {
            openGuestChannelNotice();
          }
          if (!ok) {
            btn.disabled = false;
            btn.textContent = "Join";
          }
        });
      });
      document.querySelectorAll("[data-channel-dismiss]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const channel = btn.getAttribute("data-channel-dismiss");
          if (!channel) return;
          appData.dismissedChannels = [...new Set([...(appData.dismissedChannels || []), channel])];
          saveDismissedChannels(appData.dismissedChannels);
          renderPopularChannels(appData.channelDirectory?.popular || []);
          attachChannelDirectoryHandlers();
        });
      });
      document.querySelectorAll("[data-group-toggle]").forEach((toggle) => {
        toggle.addEventListener("click", () => {
          const group = toggle.getAttribute("data-group-toggle");
          if (!group) return;
          const expanded = appData.directoryGroupState[group] === true;
          appData.directoryGroupState[group] = !expanded;
          renderGroupedChannels(appData.channelDirectory?.groups || {});
          attachChannelDirectoryHandlers();
        });
      });
      // Group add buttons removed; use the single top-level add button.

      if (appData.authUser?.isAdmin) {
        document.querySelectorAll(".directory-row").forEach((row) => {
          row.setAttribute("draggable", "true");
          row.addEventListener("dragstart", (e) => {
            row.classList.add("dragging");
            const name = row.getAttribute("data-channel-name");
            e.dataTransfer.setData("text/plain", name || "");
          });
          row.addEventListener("dragend", () => {
            row.classList.remove("dragging");
          });
        });
        document.querySelectorAll(".directory-group-body").forEach((body) => {
          body.addEventListener("dragover", (e) => {
            e.preventDefault();
          });
          body.addEventListener("drop", async (e) => {
            e.preventDefault();
            const group = body.closest(".directory-group")?.getAttribute("data-group") || "";
            const name = e.dataTransfer.getData("text/plain");
            if (!group || !name) return;
            try {
              const res = await fetch("/api/channels/move", {
                method: "POST",
                headers: { "Content-Type": "application/json", ...authHeaders() },
                body: JSON.stringify({ name, group })
              });
              const data = await res.json().catch(() => ({}));
              if (!res.ok || !data.ok) throw new Error(data.error || "Unable to move channel.");
              appData.channelDirectory = data.directory || appData.channelDirectory;
              renderGroupedChannels(appData.channelDirectory?.groups || {});
              attachChannelDirectoryHandlers();
              showToast("Channel moved.");
            } catch (err) {
              showToast(err?.message || String(err));
            }
          });
        });
      }
      document.querySelectorAll("[data-channel-edit]").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!appData.authUser?.isAdmin) return;
          const row = btn.closest(".directory-row");
          if (!row) return;
          const name = row.getAttribute("data-channel-name") || "";
      const code = row.getAttribute("data-channel-code") || "";
      const emoji = row.getAttribute("data-channel-emoji") || "";
      const group = row.getAttribute("data-channel-group") || "";
      const allowPopular = row.getAttribute("data-channel-popular") !== "0";
      const blocked = row.getAttribute("data-channel-blocked") === "1";
      openChannelCreateModal(group, { name, code, emoji, allowPopular, blocked, mode: "edit" });
        });
      });
    }

    async function loadChannelDirectory() {
      try {
        const [directory, popular] = await Promise.all([
          fetchChannelDirectory(),
          fetchPopularChannels(6)
        ]);
        appData.channelDirectory = directory || { groups: {} };
        appData.channelDirectory.popular = popular;
        appData.channelGroupFlags = directory?.groupFlags || {};
        if (directory?.channelCounts24h) appData.channelCounts24h = directory.channelCounts24h;
      } catch {
        appData.channelDirectory = { popular: [], groups: {} };
      }
      renderPopularChannels(appData.channelDirectory.popular || []);
      renderGroupedChannels(appData.channelDirectory.groups || {});
      attachChannelDirectoryHandlers();
    }

    function getChannelNameById(id) {
      const entry = appData.channels.find((c) => c.id === id);
      return entry ? entry.name : `#${id}`;
    }

    function stopLiveMessagePulse() {
      const pulse = appData.livePulse;
      if (pulse.timer) clearInterval(pulse.timer);
      pulse.timer = null;
      pulse.running = false;
      pulse.channelId = null;
      pulse.startedAt = 0;
      pulse.latestSeenTs = 0;
      pulse.newMessageCount = 0;
    }

    async function runLiveMessagePulse() {
      const pulse = appData.livePulse;
      if (pulse.running) return;
      if (!pulse.channelId || pulse.channelId !== activeChannelId) return stopLiveMessagePulse();
      if (!document.body.classList.contains("view-channels")) return stopLiveMessagePulse();
      if (Date.now() - pulse.startedAt > pulse.limitMs) return stopLiveMessagePulse();

      pulse.running = true;
      try {
        await loadMessages(false, {
          limit: Math.max(10, appData.channelHistoryLimit),
          channel: getChannelNameById(pulse.channelId),
          preserveScroll: true,
          liveEnrich: true
        });
      } catch {}
      pulse.running = false;

      const latest = appData.latestByChannel[pulse.channelId] || 0;
      if (latest > pulse.latestSeenTs) {
        pulse.latestSeenTs = latest;
        pulse.newMessageCount += 1;
      }
      if (pulse.newMessageCount >= pulse.maxNewMessages) stopLiveMessagePulse();
    }

    function startLiveMessagePulse(channelId, latestTs) {
      const pulse = appData.livePulse;
      if (!channelId) return;
      if (pulse.timer) clearInterval(pulse.timer);
      pulse.channelId = channelId;
      pulse.startedAt = Date.now();
      pulse.latestSeenTs = latestTs || 0;
      pulse.newMessageCount = 0;
      pulse.running = false;
      pulse.timer = setInterval(runLiveMessagePulse, 1000);
      runLiveMessagePulse();
    }

    let activeChannelId = "public";
    function applyChannels(channels) {
      let list = channels || [];
      if (!appData.authUser) {
        const fixed = new Set(["public", "meshranksuggestions", "test"]);
        const guest = new Set((appData.guestChannels || []).map((c) => normalizeChannelId(c)));
        const allowed = new Set([...fixed, ...guest]);
        list = list.filter((ch) => allowed.has(normalizeChannelId(ch.id || ch.name)));
      }
      appData.channels = list.map((c) => ({
        ...c,
        id: normalizeChannelId(c.id || c.name)
      }));
          const fixedNames = ["#public", "#meshranksuggestions", "#test"];
      fixedNames.forEach((name) => {
        const id = normalizeChannelId(name);
        const exists = appData.channels.some((c) => c.id === id);
        if (!exists) {
          appData.channels.unshift({
            id,
            name,
            snippet: "No channels yet.",
            time: "--"
          });
        }
      });
      if (appData.authUser?.isAdmin) {
        const rotmName = appData.rotmChannelName || "#rotm";
        const rotmId = normalizeChannelId(rotmName);
        const exists = appData.channels.some((c) => c.id === rotmId);
        if (!exists) {
          appData.channels.unshift({
            id: rotmId,
            name: rotmName,
            snippet: "Admin-only ROTM feed",
            time: "--"
          });
        }
      }
      if (appData.channels.length) {
        const exists = appData.channels.some((c) => c.id === activeChannelId);
        if (!exists) activeChannelId = appData.channels[0].id;
        const active = appData.channels.find((c) => c.id === activeChannelId);
        if (active) document.getElementById("activeChannel").textContent = active.name;
      } else {
        activeChannelId = "public";
        document.getElementById("activeChannel").textContent = "#public";
      }
      renderChannels();
    }

    function mergeChannelMetadata(channels = []) {
      if (!Array.isArray(channels) || !appData.channels.length) return;
      const metaById = new Map();
      channels.forEach((ch) => {
        const id = normalizeChannelId(ch.id || ch.name);
        if (!id) return;
        metaById.set(id, ch);
      });
      if (!metaById.size) return;
      appData.channels = appData.channels.map((ch) => {
        const meta = metaById.get(ch.id);
        if (!meta) return ch;
        return {
          ...ch,
          snippet: meta.snippet ?? ch.snippet,
          time: meta.time ?? meta.lastMessageAt ?? ch.time,
          messageCount24h: meta.messageCount24h ?? meta.messages ?? ch.messageCount24h
        };
      });
    }
    function updateChannelParam(channelId) {
      const url = new URL(window.location.href);
      if (channelId) {
        url.searchParams.set("channel", channelId);
      } else {
        url.searchParams.delete("channel");
      }
      window.history.replaceState({}, "", url.toString());
    }

    function setActiveChannelByName(channelName) {
      const normalizedName = normalizeChannelName(channelName || "#public");
      const normalizedId = normalizeChannelId(normalizedName);
      if (!appData.channels?.length) {
        appData.channels = [{ id: "public", name: "#public", snippet: "Shared route", time: "--" }];
      }
      let channel = appData.channels.find((ch) => ch.id === normalizedId);
      if (!channel) {
        channel = { id: normalizedId, name: normalizedName, snippet: "Shared route", time: "--" };
        appData.channels.unshift(channel);
      }
      activeChannelId = normalizedId;
      const activeLabel = document.getElementById("activeChannel");
      if (activeLabel) activeLabel.textContent = channel.name;
      updateChannelParam(activeChannelId);
      renderChannels();
      renderMessages(true);
      loadMessages(false, { limit: appData.channelHistoryLimit, replace: true });
    }

    function renderChannels() {
      const el = document.getElementById("channels");
      const tabBadges = document.querySelectorAll(".channels-unread");
      el.innerHTML = "";
      const list = appData.channels.length
        ? appData.channels
        : [{ id: "public", name: "#public", snippet: "No channels yet.", time: "--" }];
      const totalUnread = Object.entries(appData.unreadByChannel || {}).reduce((sum, [key, value]) => {
        if (isChannelMuted(key)) return sum;
        return sum + (value || 0);
      }, 0);
      tabBadges.forEach((badge) => {
        badge.textContent = totalUnread || 0;
        badge.style.display = totalUnread ? "inline-flex" : "none";
      });
      const leaveMode = !!appData.leaveMode;
      const selection = appData.leaveSelection || new Set();
      const canManage = false;
      list.forEach((ch, idx) => {
        const muted = isChannelMuted(ch.id);
        const unread = muted ? 0 : (appData.unreadByChannel[ch.id] || 0);
        const displayName = ch.name || "#unknown";
        const nameKey = normalizeChannelName(displayName) || displayName;
        const avatarChar = (displayName[1] || displayName[0] || "?").toUpperCase();
        const snippet = ch.snippet || "No recent messages.";
        const time = ch.time || "--";
        const count24h = appData.channelCounts24h?.[ch.id] || 0;
        const row = document.createElement("div");
        const fixedChannels = new Set(["#public", "#meshranksuggestions", "#test"]);
        const isFixed = fixedChannels.has(displayName.toLowerCase());
        const rowClasses = [
          "channel",
          ch.id === activeChannelId ? "active" : "",
          unread ? "unread" : "",
          muted ? "channel-muted" : "",
          leaveMode && isFixed ? "channel-fixed" : ""
        ].filter(Boolean).join(" ");
        row.className = rowClasses;
        const isSelected = selection.has(nameKey);
        row.innerHTML = `
          <div class="avatar" style="background:${colors[idx % colors.length]}">${avatarChar}</div>
          <div>
            <div class="name">${displayName}</div>
            <div class="channel-meta">
              <div class="snippet">${snippet}</div>
              ${muted ? `<div class="muted-label">Muted</div>` : ""}
              <div class="channel-time">${time}</div>
            </div>
          </div>
          <div style="display:grid;gap:6px;justify-items:end;">
            ${unread ? `<div class="badge-bubble">${unread}</div>` : ""}
            ${leaveMode ? `
              <label class="channel-leave-toggle">
                <input type="checkbox" data-leave="${nameKey}" ${isFixed ? "disabled" : ""} ${isSelected ? "checked" : ""}>
                <span>Leave</span>
              </label>
            ` : ""}
            <button class="channel-mute" type="button" data-mute="${ch.id}">${muted ? "Unmute" : "Mute"}</button>
            ${canManage && !isFixed ? `<button class="channel-remove" type="button" data-remove="${displayName}">Leave</button>` : ""}
          </div>
        `;
        const muteBtn = row.querySelector(".channel-mute");
        muteBtn?.addEventListener("click", (ev) => {
          ev.stopPropagation();
          if (muted) {
            appData.mutedChannels = appData.mutedChannels.filter((id) => id !== ch.id);
          } else {
            appData.mutedChannels = [...new Set([...(appData.mutedChannels || []), ch.id])];
            appData.unreadByChannel[ch.id] = 0;
          }
          saveMutedChannels(appData.mutedChannels);
          renderChannels();
        });
        if (canManage) {
          const removeBtn = row.querySelector(".channel-remove");
          if (removeBtn) {
            removeBtn.style.display = "inline-flex";
            removeBtn.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              if (!confirm(`Leave ${displayName}?`)) return;
              try {
                if (!appData.authUser) {
                  appData.guestChannels = (appData.guestChannels || []).filter(
                    (c) => normalizeChannelId(c) !== normalizeChannelId(displayName)
                  );
                  saveGuestChannels(appData.guestChannels);
                  await loadChannels();
                  await loadChannelDirectory();
                  await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
                  return;
                }
                const res = await fetch("/api/user/channels/leave", {
                  method: "POST",
                  headers: { "Content-Type": "application/json", ...authHeaders() },
                  body: JSON.stringify({ channelName: displayName })
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok || !data.ok) throw new Error(data.error || "Failed to remove channel.");
                await loadChannels();
                await loadChannelDirectory();
                await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
              } catch (err) {
                showToast(err?.message || String(err));
              }
            });
          }
        }
        if (leaveMode) {
          const leaveToggle = row.querySelector("input[data-leave]");
          leaveToggle?.addEventListener("click", (ev) => ev.stopPropagation());
          leaveToggle?.addEventListener("change", (ev) => {
            const checked = ev.target?.checked;
            if (!checked) {
              selection.delete(nameKey);
            } else {
              selection.add(nameKey);
            }
          });
        }
          row.addEventListener("click", () => {
            activeChannelId = ch.id;
            document.getElementById("activeChannel").textContent = ch.name;
            updateChannelParam(activeChannelId);
            const latest = appData.messages
              .filter((msg) => msg.channelId === activeChannelId)
              .map((msg) => msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0)
              .reduce((a, b) => Math.max(a, b), 0);
            if (latest) appData.lastReadByChannel[activeChannelId] = latest;
            appData.unreadByChannel[activeChannelId] = 0;
            saveReadState();
            renderChannels();
            renderMessages(true);
          loadMessages(false, { limit: appData.channelHistoryLimit });
            document.body.classList.remove("menu-open-left", "menu-open-right");
          });
        el.appendChild(row);
      });
      updateChannelSidebarHelper();
    }

    function channelSelectionList() {
      const list = appData.authUser ? (appData.userChannels || []) : (appData.guestChannels || []);
      if (!Array.isArray(list)) return [];
      return list.map((name) => normalizeChannelName(name)).filter(Boolean);
    }

    function hasOnlyDefaultChannels() {
      const selection = channelSelectionList();
      if (!selection.length) return true;
      return selection.every((name) => FIXED_CHANNELS.includes(name));
    }

    function updateChannelSidebarHelper() {
      const helper = document.getElementById("channelSidebarHelper");
      if (!helper) return;
      helper.style.display = hasOnlyDefaultChannels() ? "block" : "none";
    }

    function renderMessages(full, opts = {}) {
      const preserveScroll = !!opts.preserveScroll;
      const el = document.getElementById("messages");
      const nearBottom = (el.scrollHeight - el.scrollTop - el.clientHeight) < 80;
      const filtered = appData.messages.filter((msg) => msg.channelId === activeChannelId);
      const key = activeChannelId;
      const historyState = appData.historyByChannel[key] || { loading: false, done: false };
      if (!filtered.length && !historyState.loading && !historyState.done) {
        loadMoreHistory();
      }
      let rendered = appData.renderedIdsByChannel[key] || new Set();
      if (!full && rendered.size !== filtered.length) {
        full = true;
      }
      if (full) {
        el.innerHTML = "";
        rendered = new Set();
        appData.renderedIdsByChannel[key] = rendered;
      }

      filtered.forEach((msg, idx) => {
        const keyId = msg.frameHash || msg.id;
        const conf = confidence(msg);
        if (rendered.has(keyId)) {
          const existing = el.querySelector(`.message[data-id="${keyId}"]`);
          if (existing) {
            const observerEl = existing.querySelector(".msg-observers");
            if (observerEl) {
              const updatedCount = Number.isFinite(msg.observerCount)
                ? msg.observerCount
                : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
              const updatedHits = Array.isArray(msg.observerHits) ? msg.observerHits : [];
              observerEl.textContent = `Observers: ${updatedCount}`;
              observerEl.dataset.observers = updatedHits.map((v) => String(v).trim()).filter(Boolean).join("|");
              observerEl.dataset.id = keyId;
            }
            const hopsEl = existing.querySelector(".msg-hops");
            if (hopsEl) {
              hopsEl.textContent = `Total hops: ${getHopCount(msg)}`;
            }
            const confEl = existing.querySelector(".msg-confidence");
            if (confEl) {
              confEl.textContent = `MeshRank Confidence: ${conf}%`;
              confEl.dataset.id = keyId;
            }
          }
          return;
        }
        const mask = msg.sourceMask || (msg.source === "mesh" ? SOURCE_MASK.MESH : SOURCE_MASK.INTERNET);
        const effectiveMask = appData.nodeConnected ? mask : (mask & ~SOURCE_MASK.INTERNET);
        const rowClasses = ["message"];
        if (effectiveMask & SOURCE_MASK.MESH) rowClasses.push("message-mesh");
        if (effectiveMask & SOURCE_MASK.INTERNET) rowClasses.push("message-internet");
        const row = document.createElement("div");
        row.className = rowClasses.join(" ").trim();
        row.dataset.id = keyId;
        const observerCount = Number.isFinite(msg.observerCount)
          ? msg.observerCount
          : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
        const observerList = (Array.isArray(msg.observerHits) ? msg.observerHits : [])
          .map((v) => String(v).trim())
          .filter(Boolean)
          .join("|");
        const hopCount = getHopCount(msg);
        const badgeParts = [];
        if (effectiveMask & SOURCE_MASK.MESH) {
          badgeParts.push('<span class="badge mesh-badge">Mesh</span>');
        }
        if (effectiveMask & SOURCE_MASK.INTERNET) {
          badgeParts.push('<span class="badge internet-badge">Internet</span>');
        }
        const badgeHtml = badgeParts.join(" ");
        const failedIndicator = msg.failed
          ? '<div class="msg-failed" title="Send failed to node.">Send failed</div>'
          : "";
        row.innerHTML = `
          <div class="avatar" style="background:${colors[(idx + 1) % colors.length]}">${msg.sender[0]}</div>
          <div>
            <div class="meta">
              <strong>${msg.sender}</strong>
              <span>${msg.ts}</span>
              ${badgeHtml}
            </div>
            <div class="bubble ${msg.type || "mesh"}">${msg.body}</div>
            ${failedIndicator}
              <div class="msg-footer">
                <a class="msg-observers" href="#" data-id="${keyId}" data-observers="${observerList.replace(/"/g, "&quot;")}">Observers: ${observerCount}</a>
                <a class="msg-hops" href="#" data-id="${keyId}">Total hops: ${hopCount}</a>
                <a class="msg-confidence" href="#" data-id="${keyId}">MeshRank Confidence: ${conf}%</a>
              </div>
          </div>
        `;
        el.appendChild(row);
        rendered.add(keyId);
      });
      appData.renderedIdsByChannel[key] = rendered;
      if (!preserveScroll && nearBottom) el.scrollTop = el.scrollHeight;
    }

    function getOldestTs(channelId) {
      let oldest = null;
      appData.messages.forEach((msg) => {
        if (msg.channelId !== channelId || !msg.tsRaw) return;
        if (!oldest || new Date(msg.tsRaw) < new Date(oldest)) oldest = msg.tsRaw;
      });
      return oldest;
    }

    async function loadMoreHistory() {
      const channelId = activeChannelId;
      const state = appData.historyByChannel[channelId] || { loading: false, done: false };
      if (state.loading || state.done) return;
      const before = getOldestTs(channelId) || new Date().toISOString();

      state.loading = true;
      appData.historyByChannel[channelId] = state;
      const el = document.getElementById("messages");
      const prevHeight = el.scrollHeight;
      try {
        const added = await loadMessages(false, {
          channel: getChannelNameById(channelId),
          before,
          limit: appData.channelHistoryLimit,
          preserveScroll: true
        });
        const newHeight = el.scrollHeight;
        el.scrollTop = newHeight - prevHeight;
        if (!added) {
          state.done = true;
        }
      } finally {
        state.loading = false;
        appData.historyByChannel[channelId] = state;
      }
    }

    let map;
    let routeLayer;
    let confidenceMap;
    let confidenceLayers = [];
    let confidenceTimer = null;

    function initMap() {
      map = L.map("routeMap", { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);
      routeLayer = L.layerGroup().addTo(map);
    }

    async function showRoute(msgId) {
      const msg = appData.messages.find((m) => (m.frameHash || m.id) === msgId || m.id === msgId);
      if (!msg) return;
      if (!map) initMap();
      appData.routeActiveId = msgId;
      appData.routeActiveMsg = msg;
      document.body.classList.add("route-open");
      setTimeout(() => {
        if (map) map.invalidateSize();
      }, 120);

      await ensureRouteSuggestions();
      await ensureObservers();
      document.getElementById("routeKey").textContent = msg.id;
      document.getElementById("routeMessage").textContent = msg.frameHash || msg.messageHash || msg.id;
      document.getElementById("routeSource").textContent = msg.type;
      document.getElementById("routeConfidence").textContent = confidence(msg) + "%";

      const depth = Math.max(1, msg.path.length || 1);
      const maxDepth = depth;
      document.getElementById("routeDepth").textContent = maxDepth + " hops";

      routeLayer.clearLayers();
      const routeLegend = document.getElementById("routeLegend");
      if (routeLegend) routeLegend.innerHTML = "";

      const list = document.getElementById("routeList");
      list.innerHTML = "";
        const lines = msg.path && msg.path.length ? msg.path : ["no route data"];
        const names = msg.pathNames && msg.pathNames.length ? msg.pathNames : [];
        const slicedLines = lines.slice(0, maxDepth);
        const slicedNames = names.slice(0, maxDepth);
        appData.routeActivePathCodes = slicedLines.slice();
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        slicedLines.forEach((node, idx) => {
          const label = resolveRouteName(node, slicedNames[idx] ? slicedNames[idx] : node);
          const code = String(node || "").toUpperCase();
          const isRepeater = repeatersByCode && repeatersByCode.has(code);
          const item = document.createElement("div");
          item.className = "list-item";
        item.innerHTML = isRepeater
          ? `<span>${label}</span><span class="repeater-tag">Repeater</span>`
          : `<span>${label}</span>`;
        list.appendChild(item);
      });

        const observerHits = Array.isArray(msg.observerHits) ? msg.observerHits : [];
        if (observerHits.length) {
        const byId = appData.observersById || {};
        const byName = appData.observersByName || {};
        observerHits.forEach((raw) => {
          const key = String(raw || "").trim();
          if (!key) return;
          const entry = byId[key] || byName[key] || null;
          const label = entry?.name || entry?.id || key;
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `<span>${label}</span><span class="observer-tag">Observer</span>`;
          list.appendChild(item);
        });
      }

      document.getElementById("routeCount").textContent = slicedLines.length + observerHits.length;

      if (routeLayer) {
        routeLayer.clearLayers();
        const path = Array.isArray(msg.path) ? msg.path.slice(0, maxDepth) : [];
          const rawPoints = Array.isArray(msg.pathPoints) ? msg.pathPoints.slice(0, maxDepth) : [];
          appData.routeActivePathPoints = rawPoints.slice();
        const pathLen = Math.max(path.length, rawPoints.length);
        const normalized = [];

        function hasGps(p) {
          if (!p || !p.gps || !Number.isFinite(p.gps.lat) || !Number.isFinite(p.gps.lon)) return false;
          if (p.gps.lat === 0 && p.gps.lon === 0) return false;
          return true;
        }

          for (let i = 0; i < pathLen; i += 1) {
            const base = rawPoints[i] || { hash: path[i], name: msg.pathNames?.[i] || path[i] || "#unknown" };
            const resolvedName = resolveRouteName(base.hash || path[i], base.name);
            normalized.push({ ...base, name: resolvedName });
          }

          const latlngs = [];
          const mainRoute = [];
          normalized.forEach((p) => {
            if (!hasGps(p)) return;
            const gps = p.gps;
            const latlng = [gps.lat, gps.lon];
            latlngs.push(latlng);
            mainRoute.push(latlng);
            const color = "#007aff";
            L.circleMarker(latlng, {
              radius: 5,
              color,
              fillColor: color,
              fillOpacity: 0.9,
              weight: 2
            }).bindPopup(p.name || "#unknown").addTo(routeLayer);
          });

          if (mainRoute.length >= 2) {
            L.polyline(mainRoute, {
              color: "#007aff",
              weight: 3,
              opacity: 0.85
            }).addTo(routeLayer);
          }

        const observerPaths = Array.isArray(msg.observerPaths) ? msg.observerPaths : [];
        const branchPalette = ["#34c759", "#007aff", "#ff9500", "#ff2d55", "#5856d6", "#8e8e93"];
        const branchEntries = observerPaths.map((entry) => {
          const points = (entry.pathPoints || [])
            .filter((pt) => pt?.gps && Number.isFinite(pt.gps.lat) && Number.isFinite(pt.gps.lon) && !(pt.gps.lat === 0 && pt.gps.lon === 0))
            .map((pt) => [pt.gps.lat, pt.gps.lon]);
          return {
            label: entry.observerName || entry.observerId || "Observer",
            points
          };
        }).filter((entry) => entry.points.length >= 2);
        branchEntries.sort((a, b) => b.points.length - a.points.length);
        if (branchEntries.length && routeLegend) {
          routeLegend.innerHTML = "";
        }
        branchEntries.forEach((entry, idx) => {
          const color = branchPalette[idx % branchPalette.length];
          const line = L.polyline(entry.points, {
            color,
            weight: idx === 0 ? 3 : 2,
            opacity: 0.9
          }).addTo(routeLayer);
          entry.points.forEach((pt) => latlngs.push(pt));
          if (routeLegend) {
            const label = idx === 0 ? `${entry.label} (longest)` : entry.label;
            routeLegend.insertAdjacentHTML("beforeend",
              `<div class="route-legend-item"><span class="route-legend-swatch" style="background:${color}"></span>${label}</div>`
            );
          }
        });

        if (observerHits.length) {
          const byId = appData.observersById || {};
          const byName = appData.observersByName || {};
          observerHits.forEach((raw) => {
            const key = String(raw || "").trim();
            if (!key) return;
            const entry = byId[key] || byName[key] || null;
              const gps = entry?.gps || null;
              if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
              const latlng = [gps.lat, gps.lon];
              latlngs.push(latlng);
              const label = entry?.name || entry?.id || key;
              L.circleMarker(latlng, {
                radius: 6,
                color: "#00c853",
                fillColor: "#00c853",
                fillOpacity: 0.9,
                weight: 2
              }).bindPopup(`Observer: ${label}`).addTo(routeLayer);
            });
          }

        if (latlngs.length >= 2) {
          const unique = [];
          const seen = new Set();
          latlngs.forEach((pt) => {
            const key = `${pt[0].toFixed(6)}:${pt[1].toFixed(6)}`;
            if (!seen.has(key)) {
              seen.add(key);
              unique.push(pt);
            }
          });
          const bounds = unique.length >= 2 ? unique : latlngs;
          if (bounds.length >= 2) {
            map.fitBounds(bounds, { padding: [20, 20] });
          } else {
            map.setView(latlngs[0], 9);
          }
        } else if (latlngs.length === 1) {
          map.setView(latlngs[0], 9);
        } else {
          map.setView([52.2, -1.5], 6);
        }
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 120);
      }
    }

    document.addEventListener("click", async (e) => {
      const hops = e.target.closest(".msg-hops");
      if (hops) {
        e.preventDefault();
        showRoute(hops.dataset.id);
        return;
      }
      const observers = e.target.closest(".msg-observers");
      if (observers) {
        e.preventDefault();
        const msgId = observers.dataset.id;
        let list = [];
        if (msgId) {
          const msg = appData.messages.find((m) =>
            m.id === msgId || m.frameHash === msgId || m.messageHash === msgId
          );
          list = Array.isArray(msg?.observerHits) ? msg.observerHits : [];
        }
        if (!list.length) {
          list = String(observers.dataset.observers || "")
            .split("|")
            .map((v) => v.trim())
            .filter(Boolean);
        }
        await openObserverHitsModal(list);
        return;
      }
      const confidence = e.target.closest(".msg-confidence");
      if (confidence) {
        e.preventDefault();
        const id = confidence.dataset.id;
        if (id) openMessageRouteOverlay(id);
      }
    });

    const routeClose = document.getElementById("routeClose");
    const routeBackdrop = document.getElementById("routeBackdrop");
    function closeRouteOverlay() {
      document.body.classList.remove("route-open");
      preventRouteAutoClose = false;
      if (window.history.replaceState) {
        const path = window.location.pathname || "";
        if (path.startsWith("/msg/") || path.startsWith("/s/")) {
          window.history.replaceState({}, "", "/");
        }
      }
    }
    routeClose?.addEventListener("click", closeRouteOverlay);
    routeBackdrop?.addEventListener("click", closeRouteOverlay);
    const messageList = document.getElementById("messages");
    const isMobile = () => window.matchMedia?.("(max-width: 860px)")?.matches;
    messageList?.addEventListener("scroll", () => {
      if (isMobile() && document.body.classList.contains("route-open") && !preventRouteAutoClose) closeRouteOverlay();
      if (messageList.scrollTop <= 10) {
        loadMoreHistory();
      }
    });
    messageList?.addEventListener("click", () => {
      if (isMobile() && document.body.classList.contains("route-open") && !preventRouteAutoClose) closeRouteOverlay();
    });
    messageList?.addEventListener("touchstart", () => {
      if (isMobile() && document.body.classList.contains("route-open") && !preventRouteAutoClose) closeRouteOverlay();
    }, { passive: true });
    const rankFlaggedLink = document.getElementById("rankFlaggedLink");
    if (rankFlaggedLink) {
      rankFlaggedLink.addEventListener("click", (event) => {
        event.preventDefault();
        openImplausibleList();
      });
    }
    const rankExplainLink = document.getElementById("rankExplainLink");
    if (rankExplainLink) {
      rankExplainLink.addEventListener("click", (event) => {
        event.preventDefault();
        openRankExplain();
      });
    }
    window.addEventListener("resize", () => {
      if (!window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
    });

    const routeOverrideBtn = document.getElementById("routeOverrideBtn");
    const routeOverrideModal = document.getElementById("routeOverrideModal");
    const routeOverrideList = document.getElementById("routeOverrideList");
    const routeOverrideStatus = document.getElementById("routeOverrideStatus");
    const routeOverrideClose = document.getElementById("routeOverrideClose");
    const routeOverrideSave = document.getElementById("routeOverrideSave");

    const observerHitsModal = document.getElementById("observerHitsModal");
    const observerHitsList = document.getElementById("observerHitsList");
    const observerHitsSummary = document.getElementById("observerHitsSummary");
    const observerHitsClose = document.getElementById("observerHitsClose");

    async function openObserverHitsModal(list) {
      if (!observerHitsModal || !observerHitsList || !observerHitsSummary) return;
      try {
        await ensureObservers(true);
      } catch {}
      const items = Array.isArray(list) ? list.filter(Boolean) : [];
      const resolved = items.map(resolveObserverLabel).filter(Boolean);
      observerHitsSummary.textContent = resolved.length
        ? `${resolved.length} observer${resolved.length === 1 ? "" : "s"}`
        : "No observers available.";
      observerHitsList.innerHTML = resolved.length
        ? resolved.map((name) => `<div class="list-item">${name}</div>`).join("")
        : "";
      observerHitsModal.classList.add("open");
    }

    function closeObserverHitsModal() {
      observerHitsModal?.classList.remove("open");
    }

    observerHitsClose?.addEventListener("click", closeObserverHitsModal);
    observerHitsModal?.addEventListener("click", (e) => {
      if (e.target === observerHitsModal) closeObserverHitsModal();
    });

    function getRouteVoterId() {
      const key = "routeVoterId";
      let id = localStorage.getItem(key);
      if (id) return id;
      id = Math.random().toString(36).slice(2, 12);
      localStorage.setItem(key, id);
      return id;
    }

    function openRouteOverrideModal() {
      if (!routeOverrideModal || !routeOverrideList) return;
      const codes = appData.routeActivePathCodes || [];
      routeOverrideList.innerHTML = "";
      if (!codes.length) {
        routeOverrideList.innerHTML = `<div class="route-override-empty">Select a packet in MeshFlow first, then try again.</div>`;
        if (routeOverrideStatus) routeOverrideStatus.textContent = "No route selected yet.";
        routeOverrideModal.classList.add("open");
        return;
      }
      const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const suggestions = appData.routeSuggestions?.byCode || {};
      const points = appData.routeActivePathPoints || [];

      codes.forEach((code, idx) => {
        const key = String(code || "").toUpperCase();
        const options = repeatersByCode.get(key) || [];
        const pointName = points[idx]?.name || appData.routeActiveMsg?.pathNames?.[idx] || key;
        const currentName = resolveRouteName(key, pointName);
        const best = suggestions[key];
        const bestText = best && best.accepted ? `${best.name || best.pub} (${best.confidence}% confidence)` : "No community match yet";

        const row = document.createElement("div");
        row.className = "route-override-row";

        const label = document.createElement("div");
        label.className = "route-override-label";
        label.innerHTML = `<strong>${key}</strong><div>Current: ${currentName}</div><div>Community: ${bestText}</div>`;

        const select = document.createElement("select");
        select.className = "route-override-select";
        select.dataset.code = key;

        const optKeep = document.createElement("option");
        optKeep.value = "keep";
        optKeep.textContent = "Keep current";
        select.appendChild(optKeep);

        const optNone = document.createElement("option");
        optNone.value = "none";
        optNone.textContent = "None of these";
        select.appendChild(optNone);

        if (options.length) {
          const divider = document.createElement("option");
          divider.disabled = true;
          divider.textContent = "-- Repeaters with this code --";
          select.appendChild(divider);
          options.forEach((opt) => {
            const o = document.createElement("option");
            o.value = opt.pub || "";
            o.textContent = opt.name || opt.pub || key;
            select.appendChild(o);
          });
        }

        row.appendChild(label);
        row.appendChild(select);
        routeOverrideList.appendChild(row);
      });

      if (routeOverrideStatus) routeOverrideStatus.textContent = "Select repeaters, then submit.";
      routeOverrideModal.classList.add("open");
    }

    if (routeOverrideBtn) {
      routeOverrideBtn.addEventListener("click", async () => {
        await ensureRouteSuggestions();
        openRouteOverrideModal();
      });
    }

    window.openRouteOverride = async () => {
      await ensureRouteSuggestions();
      openRouteOverrideModal();
    };

    if (routeOverrideClose) {
      routeOverrideClose.addEventListener("click", () => {
        if (routeOverrideModal) routeOverrideModal.classList.remove("open");
      });
    }

    if (routeOverrideSave) {
      routeOverrideSave.addEventListener("click", async () => {
        if (!routeOverrideList) return;
        const voterId = getRouteVoterId();
        const pathGps = (appData.routeActivePathPoints || []).map((p) => p?.gps).filter(Boolean);
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        const selects = routeOverrideList.querySelectorAll("select[data-code]");
        const requests = [];

        selects.forEach((select) => {
          const code = select.dataset.code;
          const choice = select.value;
          if (!code || choice === "keep") return;
          if (choice === "none") {
            overrideRouteName(code, "");
            return;
          }
          const options = repeatersByCode.get(code) || [];
          const picked = options.find((opt) => opt.pub === choice);
          if (!picked) return;
          overrideRouteName(code, picked.name || code);
          requests.push(fetch("/api/route-suggest", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              code,
              repeaterPub: picked.pub,
              repeaterName: picked.name || "",
              voterId,
              pathGps
            })
          }));
        });

        if (!requests.length) {
          if (routeOverrideStatus) routeOverrideStatus.textContent = "No changes selected.";
          return;
        }

        if (routeOverrideStatus) routeOverrideStatus.textContent = "Submitting suggestions...";
        await Promise.allSettled(requests);
        try {
          appData.routeSuggestions = await fetchRouteSuggestions();
        } catch {}
        if (routeOverrideStatus) routeOverrideStatus.textContent = "Suggestions saved. Community scores update over time.";
        if (appData.routeActiveId) showRoute(appData.routeActiveId);
        renderRfList();
        renderRfDetail();
      });
    }

    const observerLocationModal = document.getElementById("observerLocationModal");
    const observerLocationClose = document.getElementById("observerLocationClose");
    const observerLocationSave = document.getElementById("observerLocationSave");
    const observerListEl = document.getElementById("observerList");
    const repeaterLocationModal = document.getElementById("repeaterLocationModal");
    const repeaterLocationClose = document.getElementById("repeaterLocationClose");
    const repeaterLocationSave = document.getElementById("repeaterLocationSave");
    const neighborMapModal = document.getElementById("neighborMapModal");
    const neighborMapClose = document.getElementById("neighborMapClose");
    const neighborEditToggle = document.getElementById("neighborEditToggle");
    const neighborOverrideModal = document.getElementById("neighborOverrideModal");
    const neighborOverrideClose = document.getElementById("neighborOverrideClose");
    const neighborOverrideSave = document.getElementById("neighborOverrideSave");
    const neighborOverrideSelect = document.getElementById("neighborOverrideSelect");

    observerLocationClose?.addEventListener("click", closeObserverLocationModal);
    observerLocationModal?.addEventListener("click", (e) => {
      if (e.target === observerLocationModal) closeObserverLocationModal();
    });
    repeaterLocationClose?.addEventListener("click", closeRepeaterLocationModal);
    repeaterLocationModal?.addEventListener("click", (e) => {
      if (e.target === repeaterLocationModal) closeRepeaterLocationModal();
    });
    neighborMapClose?.addEventListener("click", closeNeighborMapModal);
    neighborMapModal?.addEventListener("click", (e) => {
      if (e.target === neighborMapModal) closeNeighborMapModal();
    });
    neighborEditToggle?.addEventListener("click", () => {
      if (!appData.authUser?.isAdmin) {
        showToast("Admin access required to edit neighbors.");
        return;
      }
      appData.neighborEditMode = !appData.neighborEditMode;
      neighborEditToggle.textContent = appData.neighborEditMode ? "Done editing" : "Something not right?";
      if (appData.neighborEditMode) {
        showToast("Select a neighbor to change its repeater match.");
      }
      if (appData.neighborEditActiveEntry) {
        openNeighborMapModal(appData.neighborEditActiveEntry);
      }
    });
    neighborOverrideClose?.addEventListener("click", () => neighborOverrideModal?.classList.remove("open"));
    neighborOverrideModal?.addEventListener("click", (e) => {
      if (e.target === neighborOverrideModal) neighborOverrideModal.classList.remove("open");
    });
    const neighborMapList = document.getElementById("neighborMapList");
    if (neighborMapList) {
      neighborMapList.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-neighbor-change]");
        if (!btn) return;
        if (!appData.authUser?.isAdmin) return;
        event.preventDefault();
        const hash = String(btn.getAttribute("data-neighbor-change") || "");
        const currentPub = String(btn.getAttribute("data-neighbor-pub") || "");
        const options = appData.neighborOverrideOptions?.get(hash) || [];
        const targetPub = appData.neighborOverrideTargetPub;
        if (!hash || !targetPub || !neighborOverrideSelect) return;
        if (!Array.isArray(options) || !options.length) return;
        neighborOverrideSelect.innerHTML = options.map((opt) => {
          const label = opt.name || opt.hash || opt.pub;
          const selected = opt.pub === currentPub ? "selected" : "";
          return `<option value="${opt.pub}" ${selected}>${label}</option>`;
        }).join("");
        neighborOverrideSelect.setAttribute("data-target-pub", targetPub);
        neighborOverrideSelect.setAttribute("data-hash", hash);
        neighborOverrideModal?.classList.add("open");
      });
    }
    neighborOverrideSave?.addEventListener("click", async () => {
      if (!neighborOverrideSelect || !appData.authUser?.isAdmin) return;
      const targetPub = neighborOverrideSelect.getAttribute("data-target-pub");
      const hash = neighborOverrideSelect.getAttribute("data-hash");
      const pub = neighborOverrideSelect.value;
      if (!targetPub || !hash || !pub) return;
      try {
        await fetch("/api/zero-hop-override", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ targetPub, hash, pub })
        });
        neighborOverrideModal?.classList.remove("open");
        await loadRankDefault();
        fetchRankSummary().then(renderRankSummary).catch(() => {});
      } catch {
        neighborOverrideModal?.classList.remove("open");
      }
    });

    observerListEl?.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-observer-locate]");
      if (!btn) return;
      const id = btn.getAttribute("data-observer-locate");
      const entry = appData.observersById?.[id];
      if (!entry) return;
      openObserverLocationModal(entry);
    });

    observerLocationSave?.addEventListener("click", async () => {
      if (!observerLocationTarget || !observerLocationCoords) {
        alert("Click a location on the map first.");
        return;
      }
      try {
        const res = await fetch("/api/observer-location", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            id: observerLocationTarget.id,
            lat: observerLocationCoords.lat,
            lon: observerLocationCoords.lng
          })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await fetchObservers();
        updateObserversData(data);
        renderObserverMap(data);
        renderObserverList(data);
        closeObserverLocationModal();
      } catch (err) {
        alert("Unable to save location: " + (err?.message || err));
      }
    });

    repeaterLocationSave?.addEventListener("click", async () => {
      if (!repeaterLocationTarget || !repeaterLocationCoords) {
        alert("Click a location on the map first.");
        return;
      }
      try {
        const res = await fetch("/api/repeater-location", {
          method: "POST",
          headers: { "content-type": "application/json", ...authHeaders() },
          body: JSON.stringify({
            pub: repeaterLocationTarget.pub,
            lat: repeaterLocationCoords.lat,
            lon: repeaterLocationCoords.lng
          })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        await loadRankDefault();
        fetchRankSummary().then(renderRankSummary).catch(() => {});
        closeRepeaterLocationModal();
      } catch (err) {
        alert("Unable to save location: " + (err?.message || err));
      }
    });

    const addBtn = document.getElementById("addChannelBtn");
    const leaveBtn = document.getElementById("leaveChannelBtn");
    const channelCreateModal = document.getElementById("channelCreateModal");
    const channelCreateGroup = document.getElementById("channelCreateGroup");
    const channelCreateGroupSelect = document.getElementById("channelCreateGroupSelect");
    const channelCreateName = document.getElementById("channelCreateName");
    const channelCreateCode = document.getElementById("channelCreateCode");
    const channelCreateEmojiGrid = document.getElementById("channelCreateEmojiGrid");
    const openEmojiPicker = document.getElementById("openEmojiPicker");
    const emojiPreview = document.getElementById("emojiPreview");
    const channelCreatePopular = document.getElementById("channelCreatePopular");
    const channelCreateBlocked = document.getElementById("channelCreateBlocked");
    const emojiPickerModal = document.getElementById("emojiPickerModal");
    const emojiPickerGrid = document.getElementById("emojiPickerGrid");
    const emojiPickerClose = document.getElementById("emojiPickerClose");
    const emojiPickerApply = document.getElementById("emojiPickerApply");
    const emojiCustomInput = document.getElementById("emojiCustomInput");
    const channelPreviewModal = document.getElementById("channelPreviewModal");
    const channelPreviewTitle = document.getElementById("channelPreviewTitle");
    const channelPreviewBody = document.getElementById("channelPreviewBody");
    const channelPreviewClose = document.getElementById("channelPreviewClose");
    const channelDirectoryAddBtn = document.getElementById("channelDirectoryAddBtn");
    const channelDirectoryAddGroupBtn = document.getElementById("channelDirectoryAddGroupBtn");
    const guestChannelNoticeModal = document.getElementById("guestChannelNoticeModal");
    const guestChannelNoticeClose = document.getElementById("guestChannelNoticeClose");
    const channelCreateCancel = document.getElementById("channelCreateCancel");
    const channelCreateSave = document.getElementById("channelCreateSave");
    let channelCreateSelectedEmoji = "";

    function setLeaveMode(enabled) {
      appData.leaveMode = !!enabled;
      appData.leaveSelection = new Set();
      if (leaveBtn) {
        leaveBtn.textContent = appData.leaveMode ? "Save" : "Leave Channels";
      }
      document.body.classList.toggle("leave-mode", appData.leaveMode);
      renderChannels();
    }

    async function leaveSelectedChannels(list) {
      const fixed = new Set(["#public", "#meshranksuggestions", "#test"]);
      const targets = (list || [])
        .map((name) => normalizeChannelName(name))
        .filter((name) => name && !fixed.has(name.toLowerCase()));
      if (!targets.length) {
        showToast("No removable channels selected.");
        return;
      }
      if (!appData.authUser) {
        const removeSet = new Set(targets.map((name) => normalizeChannelId(name)));
        appData.guestChannels = (appData.guestChannels || []).filter(
          (name) => !removeSet.has(normalizeChannelId(name))
        );
        saveGuestChannels(appData.guestChannels);
      } else {
        for (const channelName of targets) {
          const res = await fetch("/api/user/channels/leave", {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ channelName })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) {
            throw new Error(data.error || `Failed to leave ${channelName}.`);
          }
        }
      }
      await loadChannels();
      await loadChannelDirectory();
      await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
      showToast("Channels updated.");
    }

    function populateGroupSelect(group) {
      if (!channelCreateGroupSelect) return;
      const fallbackGroups = [
        "General Chat",
        "Regional",
        "Specialist",
        "Clubs & Societies",
        "Testing",
        "Ham Radio",
        "Comedy",
        "Sports",
        "Music",
        "Other"
      ];
      const groups = Object.keys(appData.channelDirectory?.groups || {}).length
        ? Object.keys(appData.channelDirectory.groups)
        : fallbackGroups;
      channelCreateGroupSelect.innerHTML = groups.map((g) => `
        <option value="${g}">${g}</option>
      `).join("");
      if (group) channelCreateGroupSelect.value = group;
    }

    function openChannelCreateModal(group, preset = {}) {
      if (!appData.authUser) {
        openGuestChannelNotice();
      }
      if (channelCreateGroup) channelCreateGroup.textContent = group || "Group";
      populateGroupSelect(group);
      if (channelCreateName) channelCreateName.value = preset.name || "";
      if (channelCreateCode) {
        const fallbackCode = getChannelCode(preset.name || "") || getChannelCode(channelCreateName?.value || "");
        channelCreateCode.value = preset.code || fallbackCode || "";
      }
      channelCreateSelectedEmoji = preset.emoji || "";
      if (emojiPreview) emojiPreview.textContent = channelCreateSelectedEmoji;
      if (channelCreateSave) {
        channelCreateSave.textContent = preset.mode === "edit" ? "Save" : "Add channel";
      }
      if (channelCreatePopular) {
        const allowPopular = preset.allowPopular !== false;
        channelCreatePopular.checked = allowPopular;
      }
      if (channelCreateBlocked) {
        channelCreateBlocked.checked = preset.blocked === true;
      }
      if (channelCreateEmojiGrid) {
        const options = ["", "", "", "", "", "", "", "", "", "", "", ""];
        channelCreateEmojiGrid.innerHTML = options.map((emoji) => `
          <button class="emoji-btn ${emoji === channelCreateSelectedEmoji ? "active" : ""}" type="button" data-emoji="${emoji}">${emoji}</button>
        `).join("");
        channelCreateEmojiGrid.querySelectorAll("[data-emoji]").forEach((btn) => {
          btn.addEventListener("click", () => {
            channelCreateSelectedEmoji = btn.getAttribute("data-emoji") || "";
            if (emojiPreview) emojiPreview.textContent = channelCreateSelectedEmoji;
            channelCreateEmojiGrid.querySelectorAll(".emoji-btn").forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
          });
        });
      }
      channelCreateModal?.classList.add("open");
      channelCreateModal?.setAttribute("data-group", group || "");
      channelCreateModal?.setAttribute("data-mode", preset.mode || "create");
    }

    function closeChannelCreateModal() {
      channelCreateModal?.classList.remove("open");
    }

    function openEmojiPickerModal() {
      if (!emojiPickerModal) return;
      const options = [
        "","","","","","","","","","","","","","","","","","","","",
        "","","","","","","","","","","","","","","","","","","","",
        "","","","","","","","","","","","","","","",""
      ];
      if (emojiPickerGrid) {
        emojiPickerGrid.innerHTML = options.map((emoji) => `
          <button class="emoji-btn" type="button" data-emoji="${emoji}">${emoji}</button>
        `).join("");
        emojiPickerGrid.querySelectorAll("[data-emoji]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const emoji = btn.getAttribute("data-emoji") || "";
            if (emojiCustomInput) emojiCustomInput.value = emoji;
          });
        });
      }
      if (emojiCustomInput) emojiCustomInput.value = channelCreateSelectedEmoji || "";
      emojiPickerModal.classList.add("open");
    }

    function openGuestChannelNotice(message) {
      if (!guestChannelNoticeModal) return;
      const noticeText = document.getElementById("guestChannelNoticeText");
      if (noticeText) {
        noticeText.textContent = message || "Channel choices are stored in your browser cache. Log in or register to sync them across devices.";
      }
      guestChannelNoticeModal.classList.add("open");
    }

    function closeEmojiPickerModal() {
      emojiPickerModal?.classList.remove("open");
    }

    addBtn?.addEventListener("click", () => {
      setView("channel-directory");
      loadChannelDirectory().catch(() => {});
      if (!appData.authUser) {
        showToast("Channels added while logged out are only saved locally. Log in to keep them.");
        openGuestChannelNotice();
      }
    });
    channelDirectoryAddBtn?.addEventListener("click", () => {
      openChannelCreateModal("");
      if (!appData.authUser) {
        openGuestChannelNotice();
      }
    });
    channelDirectoryAddGroupBtn?.addEventListener("click", async () => {
      if (!appData.authUser?.isAdmin) {
        showToast("Admin access required.");
        return;
      }
      const name = prompt("Group name?");
      if (!name) return;
      const trimmed = name.trim();
      if (!trimmed) return;
      appData.channelDirectory = appData.channelDirectory || { groups: {} };
      appData.channelDirectory.groups = appData.channelDirectory.groups || {};
      if (appData.channelDirectory.groups[trimmed]) {
        showToast("Group already exists.");
        return;
      }
      appData.channelDirectory.groups[trimmed] = [];
      renderGroupedChannels(appData.channelDirectory.groups);
      attachChannelDirectoryHandlers();
      showToast("Group added (temporary). Save by adding a channel to it.");
    });
    leaveBtn?.addEventListener("click", async () => {
      if (!appData.leaveMode) {
        setLeaveMode(true);
        showToast("Select channels to leave, then click Save.");
        return;
      }
      const selected = Array.from(appData.leaveSelection || []);
      if (!selected.length) {
        setLeaveMode(false);
        return;
      }
      try {
        await leaveSelectedChannels(selected);
        setLeaveMode(false);
      } catch (err) {
        showToast(err?.message || String(err));
      }
    });
    openEmojiPicker?.addEventListener("click", () => openEmojiPickerModal());
    emojiPickerClose?.addEventListener("click", closeEmojiPickerModal);
    emojiPickerModal?.addEventListener("click", (e) => {
      if (e.target === emojiPickerModal) closeEmojiPickerModal();
    });
    emojiPickerApply?.addEventListener("click", () => {
      const value = emojiCustomInput?.value?.trim();
      if (value) {
        channelCreateSelectedEmoji = value;
        if (emojiPreview) emojiPreview.textContent = value;
      }
      closeEmojiPickerModal();
    });
    channelPreviewClose?.addEventListener("click", () => {
      channelPreviewModal?.classList.remove("open");
    });
    channelPreviewModal?.addEventListener("click", (e) => {
      if (e.target === channelPreviewModal) channelPreviewModal.classList.remove("open");
    });
    guestChannelNoticeClose?.addEventListener("click", () => {
      guestChannelNoticeModal?.classList.remove("open");
    });
    guestChannelNoticeModal?.addEventListener("click", (e) => {
      if (e.target === guestChannelNoticeModal) guestChannelNoticeModal.classList.remove("open");
    });
    channelCreateCancel?.addEventListener("click", closeChannelCreateModal);
    channelCreateModal?.addEventListener("click", (e) => {
      if (e.target === channelCreateModal) closeChannelCreateModal();
    });
    channelCreateSave?.addEventListener("click", async () => {
      const group = channelCreateGroupSelect?.value || channelCreateModal?.getAttribute("data-group") || "";
      const name = channelCreateName?.value?.trim() || "";
      const code = channelCreateCode?.value?.trim() || "";
      const mode = channelCreateModal?.getAttribute("data-mode") || "create";
      const allowPopular = channelCreatePopular ? channelCreatePopular.checked : true;
      const blocked = channelCreateBlocked ? channelCreateBlocked.checked : false;
      if (!name || (mode !== "edit" && !code)) {
        showToast("Please fill in all fields.");
        return;
      }
      const normalized = name.startsWith("#") ? name : `#${name}`;
      try {
        const endpoint = mode === "edit" ? "/api/channels/update" : "/api/channels/create";
        const res = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ group, name: normalized, code, emoji: channelCreateSelectedEmoji, allowPopular })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) throw new Error(data.error || "Unable to create channel.");
        if (appData.authUser?.isAdmin && mode === "edit") {
          const blockEndpoint = blocked ? "/api/channels/block" : "/api/channels/unblock";
          await fetch(blockEndpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ name: normalized })
          }).catch(() => {});
        }
        appData.channelDirectory = data.directory || appData.channelDirectory;
        renderPopularChannels(appData.channelDirectory?.popular || []);
        renderGroupedChannels(appData.channelDirectory?.groups || {});
        attachChannelDirectoryHandlers();
        closeChannelCreateModal();
        showToast(mode === "edit" ? "Channel updated." : "Channel added.");
      } catch (err) {
        showToast(err?.message || String(err));
      }
    });

    const rotmInfoModal = document.getElementById("rotmInfoModal");
    const rotmInfoBtn = document.getElementById("rotmInfoBtn");
    const rotmInfoClose = document.getElementById("rotmInfoClose");
    rotmInfoBtn?.addEventListener("click", () => rotmInfoModal?.classList.add("open"));
    rotmInfoClose?.addEventListener("click", () => rotmInfoModal?.classList.remove("open"));
    rotmInfoModal?.addEventListener("click", (e) => {
      if (e.target === rotmInfoModal) rotmInfoModal.classList.remove("open");
    });

    const rotmSettingsModal = document.getElementById("rotmSettingsModal");
    const rotmSettingsBtn = document.getElementById("rotmSettingsBtn");
    const rotmSettingsClose = document.getElementById("rotmSettingsClose");
    rotmSettingsBtn?.addEventListener("click", async () => {
      rotmSettingsModal?.classList.add("open");
      appData.rotmConfigLoaded = false;
      await loadRotm();
    });
    rotmSettingsClose?.addEventListener("click", () => rotmSettingsModal?.classList.remove("open"));
    rotmSettingsModal?.addEventListener("click", (e) => {
      if (e.target === rotmSettingsModal) rotmSettingsModal.classList.remove("open");
    });

    const rotmQsoModal = document.getElementById("rotmQsoModal");
    const rotmQsoClose = document.getElementById("rotmQsoClose");
    rotmQsoClose?.addEventListener("click", () => rotmQsoModal?.classList.remove("open"));
    rotmQsoModal?.addEventListener("click", (e) => {
      if (e.target === rotmQsoModal) rotmQsoModal.classList.remove("open");
    });
    const rotmQsoDetailModal = document.getElementById("rotmQsoDetailModal");
    const rotmQsoDetailClose = document.getElementById("rotmQsoDetailClose");
    rotmQsoDetailClose?.addEventListener("click", () => rotmQsoDetailModal?.classList.remove("open"));
    rotmQsoDetailModal?.addEventListener("click", (e) => {
      if (e.target === rotmQsoDetailModal) rotmQsoDetailModal.classList.remove("open");
    });

    async function loadChannels() {
      const url = appData.authUser ? "/api/user/channels" : "/api/channels";
      const res = await fetch(url, { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json().catch(() => ({}));
      if (Array.isArray(data.userChannels)) {
        appData.userChannels = data.userChannels;
        saveCachedUserChannels(data.userChannels);
      } else if (!appData.authUser) {
        appData.userChannels = [];
      }
      const rawChannels = Array.isArray(data.channels) ? data.channels : [];
      if (!appData.authUser) {
        const fixed = new Set(["public", "meshranksuggestions", "test"]);
        const guest = new Set((appData.guestChannels || []).map((c) => normalizeChannelId(c)));
        const allowed = new Set([...fixed, ...guest]);
        const filtered = rawChannels.filter((ch) => allowed.has(normalizeChannelId(ch.id || ch.name)));
        applyChannels(filtered.length ? filtered : [
          { id: "public", name: "#public", snippet: "No channels yet.", time: "--" },
          { id: "meshranksuggestions", name: "#meshranksuggestions", snippet: "No channels yet.", time: "--" }
        ]);
      } else {
        applyChannels(rawChannels);
      }
      updateLoginHelper();
    }

    function mergeMessages(raw) {
      const byKey = new Map();
      raw.forEach((m) => {
        const stableId = m.hash || m.fp || m.id;
        const ts = m.ts ? new Date(m.ts).getTime() : 0;
        const bucket = ts ? Math.round(ts / 10000) * 10000 : 0;
        const body = (m.body || "").trim();
        const key = stableId
          ? String(stableId).toLowerCase()
          : `${m.channelName || ""}|${m.sender || ""}|${body}|${bucket}`;
        let entry = byKey.get(key);
        if (!entry) {
          entry = {
            ...m,
            id: m.id || stableId || key,
            _observerSet: new Set(),
            _pathSet: new Set()
          };
          byKey.set(key, entry);
        }
        const observerHits = Array.isArray(m.observerHits) ? m.observerHits : [];
        observerHits.forEach((o) => entry._observerSet.add(o));
        const singleObserver = m.observerName || m.observerId || m.observer || null;
        if (singleObserver) entry._observerSet.add(singleObserver);
        const path = Array.isArray(m.path) ? m.path : [];
        path.forEach((code) => {
          if (code !== undefined && code !== null && String(code).length) {
            entry._pathSet.add(String(code));
          }
        });
        if (!entry.path?.length && path.length) entry.path = path;
        if (!entry.pathNames?.length && Array.isArray(m.pathNames) && m.pathNames.length) entry.pathNames = m.pathNames;
        if (!entry.pathPoints?.length && Array.isArray(m.pathPoints) && m.pathPoints.length) entry.pathPoints = m.pathPoints;
        entry.repeats = Math.max(entry.repeats || 0, m.repeats || 0);
        if (Number.isFinite(m.pathLength)) {
          entry.pathLength = Math.max(entry.pathLength || 0, m.pathLength || 0);
        }
      });
      return Array.from(byKey.values()).map((entry) => {
        const observerHits = Array.from(entry._observerSet || []);
        const uniqueHopCount = entry._pathSet && entry._pathSet.size ? entry._pathSet.size : 1;
        const { _observerSet, _pathSet, ...clean } = entry;
        return {
          ...clean,
          observerHits,
          observerCount: observerHits.length || entry.observerCount || 0,
          uniqueHopCount
        };
      });
    }

    function mergeMappedMessages(existing, incoming) {
      const byId = new Map();
      existing.forEach((msg) => {
        byId.set(msg.id, { ...msg });
      });
      incoming.forEach((next) => {
        const current = byId.get(next.id);
        if (!current) {
          byId.set(next.id, { ...next });
          return;
        }
        const mergedHits = new Set([...(current.observerHits || []), ...(next.observerHits || [])]);
        const nextTs = next.tsRaw ? new Date(next.tsRaw).getTime() : 0;
        const curTs = current.tsRaw ? new Date(current.tsRaw).getTime() : 0;
        byId.set(next.id, {
          ...current,
          frameHash: current.frameHash || next.frameHash,
          messageHash: current.messageHash || next.messageHash,
          tsRaw: nextTs > curTs ? next.tsRaw : current.tsRaw,
          ts: nextTs > curTs ? next.ts : current.ts,
          repeats: Math.max(current.repeats || 0, next.repeats || 0),
          pathLength: Number.isFinite(next.pathLength)
            ? Math.max(current.pathLength || 0, next.pathLength || 0)
            : current.pathLength,
          path: (next.path?.length || 0) > (current.path?.length || 0) ? next.path : current.path,
          pathNames: (next.pathNames?.length || 0) > (current.pathNames?.length || 0) ? next.pathNames : current.pathNames,
          pathPoints: (next.pathPoints?.length || 0) > (current.pathPoints?.length || 0) ? next.pathPoints : current.pathPoints,
          observerHits: Array.from(mergedHits),
          observerCount: mergedHits.size,
          sourceMask: ((current.sourceMask || SOURCE_MASK.INTERNET) | (next.sourceMask || SOURCE_MASK.INTERNET))
        });
      });
      return Array.from(byId.values()).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
    }

    function upsertSharedMessage(entry) {
      if (!entry?.id) return;
      appData.messages = Array.isArray(appData.messages) ? appData.messages : [];
      const targetId = String(entry.id).toUpperCase();
      const idx = appData.messages.findIndex((msg) => {
        const msgId = String(msg.id || msg.messageHash || "").toUpperCase();
        return msgId === targetId;
      });
      if (idx >= 0) {
        appData.messages[idx] = { ...appData.messages[idx], ...entry };
      } else {
        appData.messages.unshift(entry);
      }
    }

    async function fetchMessages(params = {}) {
      const url = new URL("/api/messages", window.location.origin);
      if (params.channel) url.searchParams.set("channel", params.channel);
      if (params.limit) url.searchParams.set("limit", String(params.limit));
      if (params.before) url.searchParams.set("before", params.before);
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function loadMessages(forceFull, opts = {}) {
      const previousLatest = appData.latestByChannel || {};
      const data = opts.preloadedData || await fetchMessages(opts);
      const raw = mergeMessages(data.messages || []);
      const mapped = raw.map((m) => ({
        id: m.id,
        frameHash: m.frameHash || null,
        messageHash: m.messageHash || null,
        channelId: normalizeChannelId(m.channelName || "#unknown"),
        sender: m.sender,
        body: m.body,
        tsRaw: m.ts || null,
        ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
        type: "mesh",
        source: "internet",
        repeats: m.repeats || 1,
        sourceMask: SOURCE_MASK.INTERNET,
        pathLength: Number.isFinite(m.pathLength) ? m.pathLength : null,
        uniqueHopCount: Number.isFinite(m.uniqueHopCount) ? m.uniqueHopCount : null,
        path: Array.isArray(m.path) ? m.path : [],
        pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
        pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : [],
        observerHits: Array.isArray(m.observerHits) ? m.observerHits : [],
        observerCount: Number.isFinite(m.observerCount) ? m.observerCount : null
      })).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
      appData.messages = opts.replace
        ? mapped
        : mergeMappedMessages(appData.messages || [], mapped);
      const unread = {};
      const latestByChannel = {};
      appData.messages.forEach((msg) => {
        if (!msg.channelId) return;
        const t = msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0;
        if (!latestByChannel[msg.channelId] || t > latestByChannel[msg.channelId]) {
          latestByChannel[msg.channelId] = t;
        }
        const lastRead = appData.lastReadByChannel[msg.channelId] || 0;
        if (t > lastRead && !isChannelMuted(msg.channelId)) {
          unread[msg.channelId] = (unread[msg.channelId] || 0) + 1;
        }
      });
      const activeLatest = latestByChannel[activeChannelId] || 0;
      if (activeLatest) {
        appData.lastReadByChannel[activeChannelId] = activeLatest;
        unread[activeChannelId] = 0;
        saveReadState();
      }
      appData.latestByChannel = latestByChannel;
      appData.unreadByChannel = unread;
      if (Array.isArray(data.channels)) {
        if (!appData.authUser) {
          const fixed = new Set(["public", "meshranksuggestions", "test"]);
          const guest = new Set((appData.guestChannels || []).map((c) => normalizeChannelId(c)));
          const allowed = new Set([...fixed, ...guest]);
          const filtered = data.channels.filter((ch) => allowed.has(normalizeChannelId(ch.id || ch.name)));
          applyChannels(filtered.length ? filtered : [
            { id: "public", name: "#public", snippet: "No channels yet.", time: "--" },
            { id: "meshranksuggestions", name: "#meshranksuggestions", snippet: "No channels yet.", time: "--" }
          ]);
        } else {
          mergeChannelMetadata(data.channels);
          renderChannels();
        }
      } else {
        renderChannels();
      }
      renderMessages(!!forceFull, { preserveScroll: !!opts.preserveScroll });
      if (document.body.classList.contains("view-channels")) {
        const prev = previousLatest[activeChannelId] || 0;
        const next = latestByChannel[activeChannelId] || 0;
        if (next && next > prev) {
          scheduleRecentStatsRefresh(activeChannelId);
        }
      }
      return mapped.length;
    }

    async function refreshRecentStats(channelId) {
      if (!channelId) return;
      try {
        const data = await fetchMessages({ channel: getChannelNameById(channelId), limit: 3 });
        const raw = mergeMessages(data.messages || []);
        const mapped = raw.map((m) => ({
          id: m.id,
          frameHash: m.frameHash || null,
          messageHash: m.messageHash || null,
          channelId: normalizeChannelId(m.channelName || "#unknown"),
          sender: m.sender,
          body: m.body,
          tsRaw: m.ts || null,
          ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
          type: "mesh",
          repeats: m.repeats || 1,
          pathLength: Number.isFinite(m.pathLength) ? m.pathLength : null,
          uniqueHopCount: Number.isFinite(m.uniqueHopCount) ? m.uniqueHopCount : null,
          path: Array.isArray(m.path) ? m.path : [],
          pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
          pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : [],
          observerHits: Array.isArray(m.observerHits) ? m.observerHits : [],
          observerCount: Number.isFinite(m.observerCount) ? m.observerCount : null
        })).sort((a, b) => {
          const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
          const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
          return ta - tb;
        });
        appData.messages = mergeMappedMessages(appData.messages || [], mapped);
        renderMessages(false, { preserveScroll: true });
      } catch {}
    }

    function scheduleRecentStatsRefresh(channelId) {
      const now = Date.now();
      const last = appData.recentStatsByChannel[channelId] || 0;
      if (now - last < 1000) return;
      appData.recentStatsByChannel[channelId] = now;
      setTimeout(() => refreshRecentStats(channelId), 1000);
      setTimeout(() => refreshRecentStats(channelId), 3000);
    }

    function applyMessageObserverUpdates(payload) {
      if (!payload?.updates?.length || !Array.isArray(appData.messages)) return;
      let changed = false;
      payload.updates.forEach((update) => {
        const key = String(update.messageHash || "").toUpperCase();
        const altKey = String(update.frameHash || "").toUpperCase();
        if (!key && !altKey) return;
        const nextHits = Array.isArray(update.observerHits) ? update.observerHits : [];
        appData.messages.forEach((msg) => {
          const msgKey = String(msg.messageHash || msg.frameHash || msg.id || "").toUpperCase();
          if (msgKey !== key && msgKey !== altKey) return;
          const merged = new Set([...(msg.observerHits || []), ...nextHits]);
          if (merged.size !== (msg.observerHits || []).length) {
            msg.observerHits = Array.from(merged);
            msg.observerCount = merged.size;
            changed = true;
          }
          if (Number.isFinite(update.pathLength) && (msg.pathLength || 0) < update.pathLength) {
            msg.pathLength = update.pathLength;
            changed = true;
          }
          if (Number.isFinite(update.repeats) && (msg.repeats || 0) < update.repeats) {
            msg.repeats = update.repeats;
            changed = true;
          }
        });
      });
      if (changed) renderMessages(false, { preserveScroll: true });
    }

    function initMessageStream() {
      if (!window.EventSource) return;
      if (appData.messageStream?.es) return;
      const es = new EventSource("/api/message-stream");
      appData.messageStream.es = es;
      appData.messageStream.connected = false;
      let lastChannelRefresh = 0;
      let lastActiveRefresh = 0;
      es.addEventListener("packet", (event) => {
        try {
          const data = JSON.parse(event.data);
          applyMessageObserverUpdates(data);
          if (document.body.classList.contains("view-channels")) {
            const now = Date.now();
            if (now - lastActiveRefresh > 500) {
              lastActiveRefresh = now;
              loadMessages(false, {
                channel: activeChannelId,
                limit: appData.channelHistoryLimit,
                preserveScroll: true
              }).catch(() => {});
            }
            if (now - lastChannelRefresh > 2000) {
              lastChannelRefresh = now;
              loadMessages(false, { limit: appData.channelHistoryLimit, preserveScroll: true }).catch(() => {});
            }
          }
        } catch {}
      });
      es.addEventListener("counters", (event) => {
        try {
          const data = JSON.parse(event.data);
          if (!appData.authUser && Array.isArray(data.channels)) applyChannels(data.channels);
          if (data.rotm) applyRotmPayload(data.rotm);
          if (data.visitors) applyVisitorStats(data.visitors);
        } catch {}
      });
      es.addEventListener("ranks", (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.repeater) {
            appData.rankSummary = data.repeater;
            renderRankSummary(data.repeater);
          }
          if (data.node) renderNodeRankSummary(data.node);
          if (data.observer) renderObserverRankSummary(data.observer);
          if (data.meshscore) renderMeshScore(data.meshscore, meshRangeDays);
        } catch {}
      });
      es.addEventListener("health", () => {
        setServerStatus(true);
        appData.messageStream.connected = true;
        appData.messageStream.lastHealthAt = Date.now();
      });
      es.addEventListener("ready", () => {
        setServerStatus(true);
        appData.messageStream.connected = true;
        appData.messageStream.lastHealthAt = Date.now();
      });
      es.onerror = () => {
        setServerStatus(false);
        appData.messageStream.connected = false;
      };
    }

    async function checkServerStatus() {
      try {
        const res = await fetch("/api/channels?ts=" + Date.now(), { cache: "no-store" });
        setServerStatus(res.ok);
        return res.ok;
      } catch {
        setServerStatus(false);
        return false;
      }
    }

    function loadReadState() {
      try {
        const raw = localStorage.getItem("meshmonitor.lastReadByChannel");
        const parsed = raw ? JSON.parse(raw) : {};
        if (parsed && typeof parsed === "object") appData.lastReadByChannel = parsed;
      } catch {}
    }

    function saveReadState() {
      localStorage.setItem("meshmonitor.lastReadByChannel", JSON.stringify(appData.lastReadByChannel));
    }

    function initChannelHistoryControl() {
      const select = document.getElementById("channelHistoryLimit");
      if (!select) return;
      select.innerHTML = "";
      for (let i = 1; i <= 50; i += 1) {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = String(i);
        select.appendChild(opt);
      }
      select.value = String(appData.channelHistoryLimit);
      select.addEventListener("change", async () => {
        const next = Number(select.value);
        if (!Number.isFinite(next) || next < 1 || next > 50) return;
        appData.channelHistoryLimit = next;
        saveChannelHistoryLimit(next);
        try {
          await loadMessages(true, { replace: true, limit: appData.channelHistoryLimit });
        } catch {}
      });
    }

    async function boot() {
      const url = new URL(window.location.href);
      const channelParam = url.searchParams.get("channel");
      if (channelParam) {
        activeChannelId = normalizeChannelId(channelParam);
      }
      appData.authToken = loadAuthToken();
      appData.mutedChannels = loadMutedChannels().filter(Boolean);
      appData.guestChannels = loadGuestChannels();
      appData.dismissedChannels = loadDismissedChannels();
      try {
        const channelName = channelParam ? (channelParam.startsWith("#") ? channelParam : `#${channelParam}`) : null;
        const dash = await fetchDashboard(channelName, appData.channelHistoryLimit);
        setAuthUser(dash.user || null);
        setBootstrapVisibility(!!dash.hasAdmin);
        if (Array.isArray(dash.userChannels)) {
          appData.userChannels = dash.userChannels;
          saveCachedUserChannels(dash.userChannels);
        }
        if (dash.channelCounts24h) {
          appData.channelCounts24h = dash.channelCounts24h;
        }
        if (dash.rotmConfig?.channel) {
          appData.rotmChannelName = dash.rotmConfig.channel;
          appData.rotmConfigLoaded = true;
        }
        if (Array.isArray(dash.channels)) applyChannels(dash.channels);
        await loadMessages(true, {
          replace: true,
          limit: appData.channelHistoryLimit,
          preloadedData: { channels: dash.channels || [], messages: dash.messages || [] }
        });
        initMessageStream();
        if (dash.rotm) applyRotmPayload(dash.rotm);
        if (dash.meshscore) renderMeshScore(dash.meshscore, meshRangeDays);
        setServerStatus(true);
        if (appData.authUser) loadAccountData().catch(() => {});
        updateLoginHelper();
      } catch {
        const msg = document.createElement("div");
        msg.className = "rank-item";
        msg.textContent = "No messages yet.";
        document.getElementById("messages").appendChild(msg);
        setServerStatus(false);
      }
      if (window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
      try {
        startRotmRefresh();
        startRotmTimers();
      } catch {}
      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        if (appData.messageStream?.connected) return;
        await refreshRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        const activeNodeRank = document.body.classList.contains("view-node-rank");
        if (!activeNodeRank) return;
        if (appData.messageStream?.connected) return;
        await refreshNodeRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        if (appData.messageStream?.connected) return;
        await refreshObserverRankSummary();
      }, 60 * 1000);

      setInterval(async () => {
        if (appData.messageStream?.connected) return;
        const ok = await checkServerStatus();
        if (!ok) return;
        try {
          await loadMessages(false, { limit: appData.channelHistoryLimit });
        } catch {}
      }, 2000);

      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        try {
          await refreshRankSummary();
          await loadRankDefault();
          setTimeout(async () => {
            try {
              const mesh = await fetchMeshScore();
              renderMeshScore(mesh, meshRangeDays);
            } catch {}
          }, 0);
        } catch {}
      }, 15 * 60 * 1000);

      setInterval(async () => {
        const activeNodeRank = document.body.classList.contains("view-node-rank");
        if (!activeNodeRank) return;
        try {
          await refreshNodeRankSummary();
          const data = await fetchNodeRank();
          renderNodeRank(data);
        } catch {}
      }, 5 * 60 * 1000);

      setInterval(async () => {
        const activeRf = document.body.classList.contains("view-rf");
        if (!activeRf) return;
        try {
          const payload = await fetchRfLatest();
          const items = payload.items || [];
          const last = items[items.length - 1];
          const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
          if (sig !== appData.rfLastSig) {
            appData.rfLastSig = sig;
            appData.rfPackets = items;
            document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
            renderRfList();
          }
          if (!appData.rfSelected && appData.rfPackets.length) {
            appData.rfSelected = appData.rfPackets[appData.rfPackets.length - 1];
            renderRfDetail();
          }
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserver = document.body.classList.contains("view-observer");
        if (!activeObserver) return;
        try {
          const data = await fetchObservers();
          updateObserversData(data);
          renderObserverMap(data);
          renderObserverList(data);
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        try {
          setObserverRankLoading(true);
          await refreshObserverRankSummary();
          const data = await fetchObserverRank();
          appData.observerRank = data;
          renderObserverRank(data);
          renderObserverRankMap(data);
        } catch {}
        finally {
          setObserverRankLoading(false);
        }
      }, 15 * 60 * 1000);
    }

    updateVisitorDisplay();
    boot();
    window.addEventListener("popstate", handleShareRoute);
    document.addEventListener("DOMContentLoaded", () => {
      initShareUi();
      handleShareRoute();
    });

    let rankMap;
    let rankLayer;
    let rankMarkers = new Map();
    let meshRangeDays = 7;
    let nodeRankMap;
    let nodeRankLayer;
    let nodeRankMarkers = new Map();
    let observerMap;
    let observerLayer;
    let observerRankMap;
    let observerRankLayer;
    let observerRankRadiusLayer;

    function initRankMap() {
      rankMap = L.map("rankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rankMap);
      rankLayer = L.layerGroup().addTo(rankMap);
    }

    function initNodeRankMap() {
      nodeRankMap = L.map("nodeRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(nodeRankMap);
      nodeRankLayer = L.layerGroup().addTo(nodeRankMap);
    }

    function initObserverMap() {
      const el = document.getElementById("observerMap");
      if (!el) return;
      observerMap = L.map("observerMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerMap);
      observerLayer = L.layerGroup().addTo(observerMap);
    }

    function initObserverRankMap() {
      const el = document.getElementById("observerRankMap");
      if (!el) return;
      observerRankMap = L.map("observerRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerRankMap);
      observerRankLayer = L.layerGroup().addTo(observerRankMap);
      observerRankRadiusLayer = L.layerGroup().addTo(observerRankMap);
    }

    async function fetchObservers() {
      const res = await fetch("/api/observers?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRank() {
      const res = await fetch(`/api/observer-rank?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRankSummary() {
      const res = await fetch(`/api/observer-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshObserverRankSummary() {
      try {
        const summary = await fetchObserverRankSummary();
        appData.observerRankSummary = summary;
        renderObserverRankSummary(summary);
      } catch {}
    }

    function updateObserversData(data) {
      const byId = data?.byId || {};
      appData.observersById = byId;
      appData.observersByIdUpper = {};
      appData.observersByName = {};
      appData.observersByNameLower = {};
      Object.entries(byId).forEach(([rawKey, entry]) => {
        if (!entry) return;
        const idKey = String(entry.id || rawKey || "").trim();
        if (idKey) appData.observersByIdUpper[idKey.toUpperCase()] = entry;
        const name = String(entry.name || "").trim();
        if (name) {
          appData.observersByName[name] = entry;
          appData.observersByNameLower[name.toLowerCase()] = entry;
        }
      });
      appData.observersUpdatedAt = Date.now();
    }

    async function ensureObservers(force) {
      if (!force && Date.now() - appData.observersUpdatedAt < 60000) return;
      const data = await fetchObservers();
      updateObserversData(data);
    }

    function observerColor(ageHours) {
      if (ageHours <= 1) return "#34c759";
      if (ageHours <= 24) return "#ff9500";
      if (ageHours <= 48) return "#ff3b30";
      return null;
    }

    function renderObserverMap(data) {
      if (!observerLayer) initObserverMap();
      if (!observerLayer || !data) return;
      observerLayer.clearLayers();
      const entries = Object.values(data.byId || {});
      const now = Date.now();
      const points = [];
        entries.forEach((entry) => {
          const gps = entry.gps || null;
          if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
          if (gps.lat === 0 && gps.lon === 0) return;
          const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
          const ageHours = ts ? (now - ts) / 3600000 : 999;
          const color = observerColor(ageHours);
          if (!color) return;
          const circle = L.circle([gps.lat, gps.lon], {
            radius: 5000,
            color,
            fillColor: color,
            fillOpacity: 0.35,
            weight: 2
          });
          const name = entry.name || entry.id || "Observer";
          circle.bindTooltip(name, { direction: "top", opacity: 0.9 });
          circle.addTo(observerLayer);
          points.push([gps.lat, gps.lon]);
        });
      if (points.length) {
        observerMap.fitBounds(points, { padding: [20, 20], maxZoom: 6 });
      } else {
        observerMap.setView([54.0, -2.5], 6);
      }
      if (observerMap) {
        observerMap.invalidateSize();
      }
    }

    function renderObserverList(data) {
      const list = document.getElementById("observerList");
      if (!list || !data) return;
        const entries = Object.values(data.byId || {}).filter((entry) => {
          const gps = entry?.gps;
          if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return true;
          return gps.lat === 0 && gps.lon === 0;
        });
      if (!entries.length) {
        list.innerHTML = "<div class='rf-row'>No pending observers.</div>";
        return;
      }
      const now = Date.now();
      entries.sort((a, b) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
      list.innerHTML = entries.map((entry) => {
        const name = entry.name || entry.id || "Observer";
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        let status = "Active";
        if (ageHours > 24) status = "Idle 24h+";
        else if (ageHours > 1) status = "Idle 1h+";
          const location = "Location pending";
        const source = entry.locSource ? ` | ${entry.locSource}` : "";
        return `<div class="rf-row">
          <div class="rf-head">${name}</div>
          <div class="rf-meta">${status} | ${location}${source}</div>
          <div><button class="observer-location-button" type="button" data-observer-locate="${entry.id}">Set location</button></div>
        </div>`;
      }).join("");
    }

    function renderObserverRank(data) {
      const list = document.getElementById("observerRankList");
      if (!list || !data?.items) return;
      const query = (document.getElementById("observerRankSearch")?.value || "").trim().toLowerCase();
      const items = data.items.filter((o) => !query || String(o.name || o.id).toLowerCase().includes(query));
      list.innerHTML = items.length
        ? items.map((o) => {
              const scoreBadge = String(Math.round(o.score || 0)).padStart(2, "0");
              return `
                <div class="rank-item${o.stale ? " hidden" : ""}">
                  <div class="score">
                    <span class="rank-dot" style="background:${o.scoreColor}">${scoreBadge}</span>
                    <div class="rank-main">
                      <strong>${o.name || o.id}</strong>
                      <div class="rank-meta">Uptime: ${o.uptimeHours.toFixed(1)}h | Packets (24h): ${(o.packets24h ?? o.packetsToday ?? 0).toLocaleString()}${o.offline && Number.isFinite(o.lastSeenAgoMinutes) ? ` | Last heard ${formatRelativeMinutes(o.lastSeenAgoMinutes)}` : ""}${Number.isFinite(o.lastSeenAgoMinutes) && o.lastSeenAgoMinutes >= 60 && o.lastPacketAt ? ` | Last packet: ${formatDateTime(o.lastPacketAt)}` : ""}</div>
                      <div class="rank-meta">Coverage: ${o.coverageKm.toFixed(1)}km | Repeaters: ${o.coverageCount}</div>
                      <div class="rank-meta">Nearest repeater: ${o.nearestRepeaterName || "--"}${Number.isFinite(o.nearestRepeaterKm) ? ` (${o.nearestRepeaterKm}km)` : ""}</div>
                      ${o.lowPacketRate ? "<div class=\"rank-meta\" style=\"color:#f2c88b;\">Low packet rate - try moving observer closer to repeater.</div>" : ""}
                      ${badgeHtml(buildObserverBadges(o))}
                    </div>
                  </div>
                </div>
              `;
            }).join("")
          : "<div class='rank-item'>No observers yet.</div>";


      document.getElementById("observerRankUpdated").textContent = data.updatedAt
        ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = data.items.length;
      document.getElementById("observerRankActive").textContent = data.items.filter((o) => o.ageHours < 24).length;
      const listPacketsTotal = data.items.reduce((sum, o) => sum + (o.packets24h ?? o.packetsToday ?? 0), 0);
      // Only overwrite header total from list if list has packet data; else keep summary total
      const el = document.getElementById("observerRankPackets");
      if (listPacketsTotal > 0 || !appData.observerRankSummary?.totals) {
        el.textContent = listPacketsTotal.toLocaleString();
      }
    }

    function renderObserverRankSummary(summary) {
      if (!summary) return;
      document.getElementById("observerRankUpdated").textContent = summary.updatedAt
        ? new Date(summary.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = summary.count ?? 0;
      document.getElementById("observerRankActive").textContent = summary.totals?.active ?? 0;
      const p = summary.totals?.packets24h ?? summary.totals?.packetsToday ?? 0;
      document.getElementById("observerRankPackets").textContent = Number(p).toLocaleString();
    }

    function renderObserverRankMap(data) {
      if (isMobile()) return;
      if (!observerRankMap || !observerRankLayer || !observerRankRadiusLayer || !data?.items) return;
      observerRankLayer.clearLayers();
      observerRankRadiusLayer.clearLayers();
      const points = [];
      data.items.forEach((o) => {
        if (!o.gps) return;
        const latlng = [o.gps.lat, o.gps.lon];
        points.push(latlng);
        const marker = L.circleMarker(latlng, {
          radius: 7,
          weight: 2,
          color: o.scoreColor,
          fillColor: o.scoreColor,
          fillOpacity: 0.9
        }).bindPopup(`${o.name || o.id} | ${(o.packets24h ?? o.packetsToday ?? 0).toLocaleString()} pkts (24h)`);
        marker.addTo(observerRankLayer);
        if (o.coverageKm > 0) {
          const circle = L.circle(latlng, {
            radius: o.coverageKm * 1000,
            color: o.scoreColor,
            weight: 1,
            fillColor: o.scoreColor,
            fillOpacity: 0.08,
            interactive: false
          });
          circle.addTo(observerRankRadiusLayer);
        }
      });
      if (observerRankMap) observerRankMap.setView([54.0, -2.5], 6);
    }

    let observerLocationMap;
    let observerLocationMarker;
    let observerLocationTarget = null;
    let observerLocationCoords = null;
    let repeaterLocationMap;
    let repeaterLocationMarker;
    let repeaterLocationTarget = null;
    let repeaterLocationCoords = null;
    let neighborMap;
    let neighborMapLayer;

    function openObserverLocationModal(entry) {
      const modal = document.getElementById("observerLocationModal");
      const label = document.getElementById("observerLocationLabel");
      const coords = document.getElementById("observerLocationCoords");
      if (!modal) return;
      observerLocationTarget = entry;
      observerLocationCoords = null;
      label.textContent = `Observer: ${entry?.name || entry?.id || "--"}`;
      coords.textContent = "Lat/Lon: --";
      modal.classList.add("open");

      if (!observerLocationMap) {
        observerLocationMap = L.map("observerLocationMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(observerLocationMap);
        observerLocationMap.on("click", (ev) => {
          observerLocationCoords = ev.latlng;
          coords.textContent = `Lat/Lon: ${ev.latlng.lat.toFixed(5)}, ${ev.latlng.lng.toFixed(5)}`;
          if (observerLocationMarker) observerLocationMarker.remove();
          observerLocationMarker = L.circleMarker(ev.latlng, {
            radius: 6,
            color: "#007aff",
            fillColor: "#007aff",
            fillOpacity: 0.9,
            weight: 2
          }).addTo(observerLocationMap);
        });
      }

      const gps = entry?.gps || null;
      if (gps && Number.isFinite(gps.lat) && Number.isFinite(gps.lon)) {
        observerLocationMap.setView([gps.lat, gps.lon], 10);
        observerLocationCoords = { lat: gps.lat, lng: gps.lon };
        coords.textContent = `Lat/Lon: ${gps.lat.toFixed(5)}, ${gps.lon.toFixed(5)}`;
        if (observerLocationMarker) observerLocationMarker.remove();
        observerLocationMarker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).addTo(observerLocationMap);
      } else {
        observerLocationMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => observerLocationMap.invalidateSize(), 80);
    }

    function closeObserverLocationModal() {
      const modal = document.getElementById("observerLocationModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    function openRepeaterLocationModal(entry) {
      const modal = document.getElementById("repeaterLocationModal");
      const label = document.getElementById("repeaterLocationLabel");
      const coords = document.getElementById("repeaterLocationCoords");
      if (!modal) return;
      repeaterLocationTarget = entry;
      repeaterLocationCoords = null;
      label.textContent = `Repeater: ${entry?.name || entry?.pub || "--"}`;
      coords.textContent = "Lat/Lon: --";
      modal.classList.add("open");

      if (!repeaterLocationMap) {
        repeaterLocationMap = L.map("repeaterLocationMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(repeaterLocationMap);
        repeaterLocationMap.on("click", (ev) => {
          repeaterLocationCoords = ev.latlng;
          coords.textContent = `Lat/Lon: ${ev.latlng.lat.toFixed(5)}, ${ev.latlng.lng.toFixed(5)}`;
          if (repeaterLocationMarker) repeaterLocationMarker.remove();
          repeaterLocationMarker = L.circleMarker(ev.latlng, {
            radius: 6,
            color: "#007aff",
            fillColor: "#007aff",
            fillOpacity: 0.9,
            weight: 2
          }).addTo(repeaterLocationMap);
        });
      }

      const gps = entry?.gps || null;
      if (gps && Number.isFinite(gps.lat) && Number.isFinite(gps.lon)) {
        repeaterLocationMap.setView([gps.lat, gps.lon], 10);
        repeaterLocationCoords = { lat: gps.lat, lng: gps.lon };
        coords.textContent = `Lat/Lon: ${gps.lat.toFixed(5)}, ${gps.lon.toFixed(5)}`;
        if (repeaterLocationMarker) repeaterLocationMarker.remove();
        repeaterLocationMarker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).addTo(repeaterLocationMap);
      } else {
        repeaterLocationMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => repeaterLocationMap.invalidateSize(), 80);
    }

    function closeRepeaterLocationModal() {
      const modal = document.getElementById("repeaterLocationModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    let routeShareBtn;
    let shareLanding;
    let shareStatus;
    let shareError;
    let shareMessageKey;
    let shareChannel;
    let shareSender;
    let sharePackets;
    let shareDepth;
    let sharePathList;
    let shareObservers;
    let shareCloseBtn;
    let shareViewMessagesBtn;
    let shareActiveCode = null;
    let shareButtonLabel = "Share";

    function isFixedChannel(channelName) {
      const normalized = normalizeChannelName(channelName || "#public");
      if (!normalized) return false;
      return FIXED_CHANNELS.some((fixed) => normalizeChannelName(fixed) === normalized);
    }

    async function shareRoutePath() {
      if (!routeShareBtn || !appData.routeActiveId) {
        showToast("Open a route before sharing it.");
        return;
      }
      const channelName = appData.routeActiveMsg?.channelName || appData.routeActiveMsg?.channelId || null;
      if (!isFixedChannel(channelName)) {
        showToast("Share links can only be created from #public, #test, or #meshranksuggestions.");
        return;
      }
      routeShareBtn.disabled = true;
      routeShareBtn.textContent = "Creating";
      try {
        const res = await fetch(`/api/routes/${encodeURIComponent(appData.routeActiveId)}/share`, { method: "POST" });
        const rawBody = await res.text();
        let payload = null;
        try {
          payload = rawBody ? JSON.parse(rawBody) : null;
        } catch {}
        if (!res.ok || !payload?.ok || !payload.url) {
          throw new Error(payload?.error || rawBody || "Unable to create share link.");
        }
        const url = payload.url;
        const copied = await copyTextToClipboard(url);
        if (!copied) {
          window.prompt("Copy share link (valid for 24h)", url);
        }
        showToast("Link copied  valid for 24 hours");
        if (payload.code) {
          const targetPath = `/msg/${payload.code}`;
          if (window.location.pathname !== targetPath) {
            window.history.pushState({}, "", targetPath);
          }
          loadSharedRoute(payload.code, { showOverlay: false, preventAutoClose: true });
        }
      } catch (err) {
        showToast(`Share failed: ${err?.message || "unknown error"}`);
      } finally {
        routeShareBtn.disabled = false;
        routeShareBtn.textContent = shareButtonLabel;
      }
    }

    function initShareUi() {
      routeShareBtn = document.getElementById("routeShareBtn");
      shareLanding = document.getElementById("shareLanding");
      shareStatus = document.getElementById("shareStatus");
      shareError = document.getElementById("shareError");
      shareMessageKey = document.getElementById("shareMessageKey");
      shareChannel = document.getElementById("shareChannel");
      shareSender = document.getElementById("shareSender");
      sharePackets = document.getElementById("sharePackets");
      shareDepth = document.getElementById("shareDepth");
      sharePathList = document.getElementById("sharePathList");
      shareObservers = document.getElementById("shareObservers");
      shareCloseBtn = document.getElementById("shareCloseBtn");
      shareViewMessagesBtn = document.getElementById("shareViewMessagesBtn");
      shareButtonLabel = routeShareBtn?.textContent?.trim() || "Share";
      routeShareBtn?.addEventListener("click", shareRoutePath);
      shareCloseBtn?.addEventListener("click", () => closeShareLanding());
      shareViewMessagesBtn?.addEventListener("click", () => closeShareLanding(false));
    }

    async function copyTextToClipboard(text) {
      if (!text) return false;
      if (navigator.clipboard?.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch {}
      }
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      textarea.setSelectionRange(0, textarea.value.length);
      let success = false;
      try {
        success = document.execCommand("copy");
      } catch {}
      document.body.removeChild(textarea);
      return success;
    }

    let preventRouteAutoClose = false;
    function holdRouteOpen(duration = 600) {
      preventRouteAutoClose = true;
      setTimeout(() => { preventRouteAutoClose = false; }, duration);
    }

    async function loadSharedRoute(code, options = {}) {
      const { showOverlay = true, preventAutoClose = false } = options;
      if (preventAutoClose) holdRouteOpen();
      if (!shareStatus || !sharePathList || !shareObservers) return;
      shareStatus.textContent = "Loading shared route";
      shareError.textContent = "";
      shareMessageKey.textContent = "";
      shareChannel.textContent = "";
      shareSender.textContent = "";
      sharePackets.textContent = "0";
      shareDepth.textContent = "0 hops";
      sharePathList.innerHTML = "";
      shareObservers.innerHTML = "";
      if (showOverlay && shareLanding) {
        document.body.classList.add("share-active");
      }
      try {
        const res = await fetch(`/api/share/${encodeURIComponent(code)}`);
        const rawBody = await res.text();
        let payload = null;
        try {
          payload = rawBody ? JSON.parse(rawBody) : null;
        } catch {}
        if (!res.ok || !payload?.ok) {
          throw new Error(payload?.error || rawBody || "Invalid share link.");
        }
        const msg = payload.message || {};
        shareMessageKey.textContent = msg.id || "";
        shareChannel.textContent = msg.channelName || "";
        shareSender.textContent = msg.sender || "";
        sharePackets.textContent = String(payload.route?.packetsHeard || 0);
        const depth = payload.route?.pathDepth ?? (payload.route?.path?.length || 0);
        shareDepth.textContent = `${depth || 0} hops`;
        if (payload.expiresAt) {
          const until = new Date(payload.expiresAt * 1000);
          shareStatus.textContent = `Link expires ${until.toLocaleString()}`;
        } else {
          shareStatus.textContent = "Valid for 24 hours";
        }
        const nodes = payload.route?.pathPoints || [];
        if (!nodes.length) {
          sharePathList.innerHTML = `<div class="share-path-item muted">No route path recorded for this message.</div>`;
        } else {
          sharePathList.innerHTML = nodes.map((node, idx) => `
            <div class="share-path-item">
              <div><strong>${idx + 1}. ${node.name}</strong></div>
              <div class="muted">${node.hash}${node.gps ? `  ${node.gps.lat.toFixed(4)}, ${node.gps.lon.toFixed(4)}` : ""}</div>
            </div>
          `).join("");
        }
        const observers = payload.observers || [];
        if (!observers.length) {
          shareObservers.innerHTML = `<div class="muted">No observers recorded.</div>`;
        } else {
          shareObservers.innerHTML = [
            `<div class="share-observer"><strong>${observers.length} observer${observers.length === 1 ? "" : "s"}</strong></div>`,
            ...observers.slice(0, 6).map((text) => `<div class="share-observer">${text}</div>`)
          ].join("");
        }
        const channelName = msg.channelName || shareChannel.textContent || "#public";
        setActiveChannelByName(channelName);
        const shareEntry = {
          id: msg.id || msg.messageHash || msg.frameHash || code,
          frameHash: msg.frameHash || null,
          messageHash: msg.messageHash || null,
          channelId: normalizeChannelId(channelName),
          channelName: normalizeChannelName(channelName),
          sender: msg.sender || null,
          body: msg.body || null,
          tsRaw: msg.ts || new Date().toISOString(),
          repeats: msg.repeats || payload.route?.packetsHeard || 0,
          path: Array.isArray(payload.route?.path) ? payload.route.path : [],
          pathNames: Array.isArray(payload.route?.pathNames) ? payload.route.pathNames : [],
          pathPoints: Array.isArray(payload.route?.pathPoints) ? payload.route.pathPoints : [],
          observerHits: Array.isArray(payload.observers) ? payload.observers : [],
          observerCount: (payload.observers || []).length
        };
        upsertSharedMessage(shareEntry);
        showRoute(shareEntry.id);
        if (!showOverlay) {
          closeShareLanding(false);
        }
      } catch (err) {
        shareError.textContent = err?.message || "Unable to load this share link.";
        shareStatus.textContent = "";
        sharePathList.innerHTML = `<div class="share-path-item muted">Route data unavailable.</div>`;
        shareObservers.innerHTML = "";
      }
    }

    function openShareLanding(code) {
      if (!shareLanding) return;
      shareActiveCode = code;
      document.body.classList.add("share-active");
      loadSharedRoute(code);
    }

    function closeShareLanding(clearHistory = true) {
      if (!shareLanding) return;
      shareLanding.classList.remove("error");
      document.body.classList.remove("share-active");
      shareActiveCode = null;
      if (clearHistory) {
        window.history.replaceState({}, "", "/");
      }
    }

    function handleShareRoute() {
      const match = window.location.pathname.match(/^\/(?:s|msg)\/([0-9]{5})$/);
      if (match) {
        loadSharedRoute(match[1], { showOverlay: false, preventAutoClose: true });
      }
    }

    function rssiTone(rssi, relation) {
      const label = Number.isFinite(rssi) ? `${rssi} dBm` : "RSSI n/a";
      const color = relation === "reciprocal" ? "#34c759" : "#ffcc00";
      return { color, label };
    }

    function neighborRelationBadge(relation) {
      if (!relation) return "";
      const normalized = String(relation).toLowerCase();
      if (normalized === "reciprocal") {
        return `<span class="neighbor-badge reciprocal">Reciprocal</span>`;
      }
      if (normalized.includes("incoming")) {
        return `<span class="neighbor-badge incoming">Incoming only</span>`;
      }
      if (normalized.includes("outgoing") || normalized === "handoff") {
        return `<span class="neighbor-badge outgoing">Outgoing only</span>`;
      }
      return "";
    }

    function openNeighborMapModal(entry) {
      const modal = document.getElementById("neighborMapModal");
      const title = document.getElementById("neighborMapTitle");
      const meta = document.getElementById("neighborMapMeta");
      if (!modal) return;
      closeRankDetail();
      appData.neighborEditActiveEntry = entry;
      if (neighborEditToggle) {
        neighborEditToggle.textContent = appData.neighborEditMode ? "Done editing" : "Something not right?";
      }
      const repeaterName = entry?.name || entry?.pub || "Repeater";
      const suppressedReason = entry?.zeroHopUnavailableReason;
      if (suppressedReason) {
        const explanation = suppressedReason === "hidden"
          ? "Local neighbour stats are not available for repeaters hidden from the map (names containing  or GPS flags). Remove the emoji / reset the flagged GPS and publish a new advert to restore coverage within 24 hours."
          : "Local neighbour stats are currently unavailable.";
        if (title) title.textContent = "Local neighbours unavailable";
        if (meta) meta.textContent = explanation;
        if (neighborMapLayer) neighborMapLayer.clearLayers();
        const list = document.getElementById("neighborMapList");
        if (list) list.innerHTML = `<div class="neighbor-map-item">${explanation}</div>`;
        modal.classList.add("open");
        return;
      }
      if (title) title.textContent = `Local neighbours: ${repeaterName}`;
      if (meta) meta.textContent = "Lines show likely local neighbours matched using AI-inspired geo intelligence that blends route codes with nearby repeater clusters.";
      modal.classList.add("open");

      if (!neighborMap) {
        neighborMap = L.map("neighborMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(neighborMap);
        neighborMapLayer = L.layerGroup().addTo(neighborMap);
      }
      if (neighborMapLayer) neighborMapLayer.clearLayers();

      const repeaterGps = entry?.gps;
      const neighbors = Array.isArray(entry?.zeroHopNeighborDetails) ? [...entry.zeroHopNeighborDetails] : [];
      neighbors.sort((a, b) => {
        const aVal = Number.isFinite(a?.rssiAvg) ? a.rssiAvg : -Infinity;
        const bVal = Number.isFinite(b?.rssiAvg) ? b.rssiAvg : -Infinity;
        return bVal - aVal;
      });
      const visibleNeighbors = neighbors.filter((neighbor) => !isNeighborHidden(neighbor));
      const list = document.getElementById("neighborMapList");
        if (!visibleNeighbors.length) {
          const explanation = "Local neighbour stats are not available for repeaters hidden from the map (names containing  or GPS flags). Remove the emoji / reset the flagged GPS and publish a new advert to restore coverage within 24 hours.";
          if (title) title.textContent = "Local neighbours unavailable";
          if (meta) meta.textContent = explanation;
          if (neighborMapLayer) neighborMapLayer.clearLayers();
          if (list) list.innerHTML = `<div class="neighbor-map-item">${explanation}</div>`;
          modal.classList.add("open");
          return;
        }
      const byHash = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const points = [];
      appData.neighborOverrideOptions = new Map();
      appData.neighborOverrideTargetPub = entry?.pub || entry?.publicKey || entry?.pubKey || null;

      if (repeaterGps && Number.isFinite(repeaterGps.lat) && Number.isFinite(repeaterGps.lon)) {
        const root = L.circleMarker([repeaterGps.lat, repeaterGps.lon], {
          radius: 7,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).bindPopup(repeaterName).addTo(neighborMapLayer);
        points.push([repeaterGps.lat, repeaterGps.lon]);
      }

      visibleNeighbors.forEach((n) => {
        const candidates = byHash.get(String(n.hash || "").toUpperCase()) || [];
        const target = candidates.find((c) => c?.gps && Number.isFinite(c.gps.lat) && Number.isFinite(c.gps.lon)) || null;
        const gps = n.gps || target?.gps || null;
        if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
        const tone = rssiTone(n.rssiAvg, n.relation);
        const label = n.name || n.hash || "Neighbor";
        const marker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: tone.color,
          fillColor: tone.color,
          fillOpacity: 0.85,
          weight: 2
        }).bindPopup(`${label} | ${tone.label}`).addTo(neighborMapLayer);
        if (repeaterGps && Number.isFinite(repeaterGps.lat) && Number.isFinite(repeaterGps.lon)) {
          const relationText = n.relation === "reciprocal"
            ? "Reciprocal neighbour"
            : "Mesh packet passed between these nodes";
          const line = L.polyline([[repeaterGps.lat, repeaterGps.lon], [gps.lat, gps.lon]], {
            color: tone.color,
            weight: 2,
            opacity: 0.8
          }).addTo(neighborMapLayer);
          line.bindTooltip(`${label} (${relationText})`, { sticky: true });
        }
        points.push([gps.lat, gps.lon]);
      });

      if (list) {
        if (!visibleNeighbors.length) {
          list.innerHTML = "<div class='neighbor-map-item'>No strong local neighbours yet.</div>";
        } else {
          // Group neighbors by hash byte to detect duplicates
          const neighborsByHash = new Map();
          visibleNeighbors.forEach((n) => {
            const hash = String(n.hash || "").toUpperCase();
            if (!neighborsByHash.has(hash)) {
              neighborsByHash.set(hash, []);
            }
            neighborsByHash.get(hash).push(n);
          });
          
          list.innerHTML = Array.from(neighborsByHash.entries()).map(([hash, neighbors]) => {
            const n = neighbors[0]; // Use first neighbor (should be the selected one)
            const rssi = Number.isFinite(n.rssiAvg) ? `${n.rssiAvg} dBm` : "--";
            const distance = n.distanceKm !== null && Number.isFinite(n.distanceKm) ? `${n.distanceKm} km` : "";
            const status = n.relation === "reciprocal"
              ? "Reciprocal neighbour"
              : "Mesh packet passed between these nodes";
            
            // Show dropdown if multiple neighbors share same hash byte
            const hasMultipleOptions = neighbors.length > 1 || (Array.isArray(n.options) && n.options.length > 1);
            const canEdit = !!appData.authUser?.isAdmin && appData.neighborEditMode && hasMultipleOptions;
            
            if (hasMultipleOptions && Array.isArray(n.options)) {
              appData.neighborOverrideOptions.set(String(n.hash || ""), n.options);
            }
            
            const relationBadge = neighborRelationBadge(n.relation);
            const distanceText = distance ? `  ${distance}` : "";
            
            return `
              <div class="neighbor-map-item" data-neighbor-hash="${n.hash || ""}">
                <div>
                  <div class="neighbor-title-row">
                    <strong>${n.name || n.hash || "Neighbor"}</strong>
                    ${hasMultipleOptions ? `<span style="color:var(--muted);font-size:0.9em;">(${neighbors.length} options)</span>` : `<span style="color:var(--muted);font-size:0.9em;">(no other repeaters share this key)</span>`}
                  </div>
                  <div class="neighbor-meta">${status}  Avg RSSI: ${rssi}${distanceText}</div>
                  ${canEdit && Array.isArray(n.options) && n.options.length > 1 ? `
                    <select class="neighbor-select" data-neighbor-hash="${n.hash || ""}" data-target-pub="${entry?.pub || ""}" style="margin-top:8px;width:100%;padding:4px;">
                      ${n.options.map((opt) => {
                        const optDistance = opt.distanceKm !== null && Number.isFinite(opt.distanceKm) ? ` (${opt.distanceKm} km)` : "";
                        const isSelected = opt.pub === n.pub;
                        return `<option value="${opt.pub}" ${isSelected ? "selected" : ""}>${opt.name || opt.hash || "Unknown"}${optDistance}</option>`;
                      }).join("")}
                    </select>
                  ` : ""}
                </div>
                <div class="neighbor-actions">
                  ${relationBadge ? `<div class="neighbor-badge-wrap">${relationBadge}</div>` : ""}
                  ${canEdit && !Array.isArray(n.options) ? `<button class="btn btn-ghost" type="button" data-neighbor-change="${n.hash || ""}" data-neighbor-pub="${n.pub || ""}">Change</button>` : ""}
                </div>
              </div>
            `;
          }).join("");
          
          // Add event listeners for dropdown changes
          list.querySelectorAll(".neighbor-select").forEach((select) => {
            select.addEventListener("change", async (e) => {
              const hash = select.getAttribute("data-neighbor-hash");
              const targetPub = select.getAttribute("data-target-pub");
              const pub = select.value;
              if (!targetPub || !hash || !pub) return;
              try {
                await fetch("/api/zero-hop-override", {
                  method: "POST",
                  headers: { "Content-Type": "application/json", ...authHeaders() },
                  body: JSON.stringify({ targetPub, hash, pub })
                });
                // Reload rank to show updated selection
                await loadRankDefault();
                fetchRankSummary().then(renderRankSummary).catch(() => {});
                // Reopen modal with updated data
                const entry = appData.rankPayload?.items?.find((r) => r.pub === targetPub);
                if (entry) {
                  openNeighborMapModal(entry);
                }
              } catch (err) {
                console.error("Failed to save neighbor override:", err);
              }
            });
          });
        }
      }

      if (points.length) {
        neighborMap.fitBounds(points, { padding: [20, 20] });
      } else {
        neighborMap.setView([52.2, -1.5], 6);
      }
      setTimeout(() => neighborMap.invalidateSize(), 80);
    }

    function closeNeighborMapModal() {
      const modal = document.getElementById("neighborMapModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    let observerCoveragePopup;
    let coveragePopupTitle;
    let coveragePopupBody;

    function openObserverCoveragePopup(repeater, coverageCount) {
      if (!observerCoveragePopup) return;
      const name = repeater?.name || "This repeater";
      if (coveragePopupTitle) {
        coveragePopupTitle.textContent = coverageCount > 0
          ? `${name} has observer coverage`
          : `No observer coverage yet for ${name}`;
      }
      if (coveragePopupBody) {
        if (coverageCount > 0) {
          coveragePopupBody.innerHTML = `
            ${name} is covered by ${coverageCount} observer${coverageCount === 1 ? "" : "s"}. Thanks for keeping the mesh connected.
          `;
        } else {
          coveragePopupBody.innerHTML = `
            We're sorry to hear that you're not covered yet and can't enjoy the same experience as others.
            If you'd like to become an observer please visit the Become an Observer section.
            If you don't have a spare Heltec V3, email <strong>stu.stoke@gmail.com</strong>  I have some available free of charge.
          `;
        }
      }
      observerCoveragePopup.classList.add("open");
    }

    function closeObserverCoveragePopup() {
      observerCoveragePopup?.classList.remove("open");
    }

    function initObserverCoveragePopup() {
      observerCoveragePopup = document.getElementById("observerCoveragePopup");
      coveragePopupTitle = document.getElementById("coveragePopupTitle");
      coveragePopupBody = document.getElementById("coveragePopupBody");
      const closeBtn = observerCoveragePopup?.querySelector("[data-coverage-close]");
      closeBtn?.addEventListener("click", closeObserverCoveragePopup);
      observerCoveragePopup?.addEventListener("click", (event) => {
        if (event.target === observerCoveragePopup) {
          closeObserverCoveragePopup();
        }
      });
      const becomeBtn = document.getElementById("coverageBecomeBtn");
      becomeBtn?.addEventListener("click", () => {
        closeObserverCoveragePopup();
        setView("observer");
      });
    }

    let rotmMap;
    let rotmMapLayer;
    let rotmRefreshTimer = null;
    let rotmTimerTick = null;
    const ROTM_QSO_WINDOW_MS = 120 * 60 * 1000; // 120 minutes - keep CQ calls open for 2 hours
    const ROTM_REFRESH_MS = 5000;

    function formatRotmTime(ts) {
      if (!ts) return "--";
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return "--";
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    async function fetchRotmData() {
      const res = await fetch(`/api/rotm?_ts=${Date.now()}`, { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    async function fetchRotmConfig() {
      const res = await fetch("/api/rotm-config", { headers: authHeaders(), cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    function initRotmMap() {
      if (rotmMap) return;
      rotmMap = L.map("rotmQsoMap", { zoomControl: true });
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rotmMap);
      rotmMapLayer = L.layerGroup().addTo(rotmMap);
      rotmMap.setView([54.0, -2.5], 6);
    }

    function renderRotmFeed(feed) {
      const el = document.getElementById("rotmFeed");
      if (!el) return;
      if (!Array.isArray(feed) || feed.length === 0) {
        el.innerHTML = "<div class='rotm-feed-row'>No #rotm activity yet.</div>";
        return;
      }
      el.innerHTML = feed.map((item) => {
        const badgeClass = item.tone ? `rotm-badge ${item.tone}` : "rotm-badge";
        const viaName = item.viaRepeater || "Unknown";
        const isCq = item.tone === "cq" && !item.confirmed;
        const timer = isCq ? `<span class="rotm-cq-timer" data-ts="${item.ts || ""}">--</span>` : "";
        const showDetails = !!item.confirmed;
        const responseTitle = item.responseSender ? "@"+item.responseSender : null;
        const responseVia = item.responseViaRepeater || null;
        const cqLabel = showDetails ? `@${item.sender || "unknown"}` : "LIVE CQ CALL";
        const observerCount = item.observerCount ?? 0;
        
        return `
          <div class="rotm-feed-row-compact">
            <div class="rotm-feed-time">${formatRotmTime(item.ts)}</div>
            <div class="rotm-feed-content">
              <div class="rotm-feed-line">
                <span class="rotm-feed-cq">(${cqLabel})</span>
                <span class="${badgeClass}">${item.badge || "CQ"}</span>
              </div>
              <div class="rotm-feed-line">
                <span class="rotm-feed-repeater">(${viaName})</span>
                <span class="rotm-repeater-badge ${showDetails ? "ok" : ""}">${viaName}</span>
              </div>
              ${showDetails && responseTitle ? `
              <div class="rotm-feed-line">
                <span class="rotm-feed-response">(@${responseTitle})</span>
                ${responseVia ? `<span class="rotm-repeater-badge ok">${responseVia}</span>` : ""}
              </div>
              ` : ""}
              <div class="rotm-feed-stats-compact">Observers: ${observerCount}</div>
              ${timer ? `<div class="rotm-feed-timer-compact">${timer}</div>` : ""}
            </div>
          </div>
        `;
      }).join("");
      updateRotmTimers();
    }

    function renderRotmLeaderboard(leaderboard) {
      const el = document.getElementById("rotmLeaderboard");
      if (!el) return;
      if (!Array.isArray(leaderboard) || leaderboard.length === 0) {
        el.innerHTML = "<div class='rotm-feed-row'>No confirmed QSOs yet.</div>";
        return;
      }
      const header = `
        <div class="rotm-leader-row rotm-leader-header">
          <div>Rank</div>
          <div>Node</div>
          <div>QSOs</div>
          <div>Activations</div>
          <div>Last activity</div>
        </div>
      `;
      const rows = leaderboard.map((row, idx) => {
        const last = row.lastActivity ? formatDateTime(row.lastActivity) : "--";
        const isActive = appData.rotmSelectedNodeKey === row.nodeKey;
        return `
          <div class="rotm-leader-row${isActive ? " active" : ""}" data-rotm-node="${row.nodeKey}">
            <div class="rotm-leader-rank">${idx + 1}</div>
            <div>
              <div class="rotm-leader-node">${row.node || row.nodeKey}</div>
              <div class="rotm-leader-meta">${row.nodeKey || ""}</div>
            </div>
            <div>
              <div class="rotm-leader-node">${row.qsos || 0}</div>
              <div class="rotm-leader-meta">QSOs</div>
            </div>
            <div>
              <div class="rotm-leader-node">${row.uniqueRepeaters || 0}</div>
              <div class="rotm-leader-meta">Activations</div>
            </div>
            <div class="rotm-leader-meta">${last}</div>
          </div>
        `;
      }).join("");
      el.innerHTML = header + rows;
    }

    function renderRotmMap(node) {
      const title = document.getElementById("rotmQsoMapTitle");
      const list = document.getElementById("rotmQsoClaimList");
      if (!title || !list) return;
      if (!node) {
        title.textContent = "Activated repeaters";
        list.innerHTML = "";
        if (rotmMapLayer) rotmMapLayer.clearLayers();
        return;
      }
      title.textContent = `Activated repeaters for ${node.node || node.nodeKey}`;
      const repeaters = Array.isArray(node.repeaters) ? node.repeaters : [];
      list.innerHTML = repeaters.length
        ? repeaters.map((r) => `<span class="rotm-claim-chip">${r.name || r.hash || "Unknown"}</span>`).join("")
        : "<span class='rotm-claim-chip'>No repeater claims yet.</span>";

      if (!rotmMap) initRotmMap();
      if (rotmMapLayer) rotmMapLayer.clearLayers();
      const points = [];
      repeaters.forEach((r) => {
        if (!r.gps || !Number.isFinite(r.gps.lat) || !Number.isFinite(r.gps.lon)) return;
        const marker = L.circleMarker([r.gps.lat, r.gps.lon], {
          radius: 7,
          color: "#34c759",
          fillColor: "#34c759",
          fillOpacity: 0.85,
          weight: 2
        }).bindPopup(r.name || r.hash || "Repeater");
        rotmMapLayer.addLayer(marker);
        points.push([r.gps.lat, r.gps.lon]);
      });
      if (points.length) {
        rotmMap.fitBounds(points, { padding: [20, 20] });
      } else {
        rotmMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => rotmMap.invalidateSize(), 80);
    }

    function renderRotmQsoLog(node) {
      const title = document.getElementById("rotmQsoTitle");
      const log = document.getElementById("rotmQsoLog");
      if (!title || !log) return;
      if (!node) {
        title.textContent = "ROTM QSO log";
        log.innerHTML = "<div class='rotm-qso-msg'>No node selected.</div>";
        return;
      }
      title.textContent = `QSO log: ${node.node || node.nodeKey}`;
      const items = Array.isArray(node.qsoLog) ? node.qsoLog : [];
      if (!items.length) {
        log.innerHTML = "<div class='rotm-qso-msg'>No QSOs logged yet.</div>";
        return;
      }
      const allowOverride = !!appData.authUser?.isAdmin;
      const rows = items.map((qso) => `
        <tr data-qso-detail="1"
            data-qso-date="${formatDateTime(qso.ts)}"
            data-qso-repeater="${qso.repeater || "Unknown"}"
            data-qso-cq="@${qso.cqSender || "unknown"}"
            data-qso-cq-body="${qso.cqBody || ""}"
            data-qso-response="@${qso.responseSender || "unknown"}"
            data-qso-response-body="${qso.responseBody || ""}">
          <td>${formatDateTime(qso.ts)}</td>
          <td>
            ${qso.repeater || "Unknown"}
            ${allowOverride && Array.isArray(qso.repeaterOptions) && qso.repeaterOptions.length > 1 ? `
              <div class="rotm-qso-override" data-cq-id="${qso.cqId}" data-hash="${qso.repeaterHash || ""}">
                <select class="rotm-qso-select">
                  ${qso.repeaterOptions.map((opt) => `
                    <option value="${opt.pub}" ${opt.pub === qso.repeaterPub ? "selected" : ""}>${opt.name || opt.hash || opt.pub}</option>
                  `).join("")}
                </select>
                <button class="btn btn-ghost rotm-qso-save" type="button">Save</button>
                <span class="rotm-qso-note">Ambiguous hash</span>
              </div>
            ` : ""}
          </td>
          <td>@${qso.responseSender || "unknown"}</td>
        </tr>
      `).join("");
      log.innerHTML = `
        <table class="rotm-qso-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Repeater</th>
              <th>Confirmed by</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function selectRotmNode(nodeKey) {
      appData.rotmSelectedNodeKey = nodeKey;
      const node = (appData.rotmData?.leaderboard || []).find((n) => n.nodeKey === nodeKey) || null;
      renderRotmLeaderboard(appData.rotmData?.leaderboard || []);
      renderRotmMap(node);
    }

    function applyRotmPayload(data) {
      if (!data) return;
      appData.rotmData = data;
      const updated = document.getElementById("rotmUpdated");
      if (updated) updated.textContent = data.updatedAt ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "--";
      renderRotmFeed(data.feed || []);
      renderRotmLeaderboard(data.leaderboard || []);
      if (!appData.rotmSelectedNodeKey && data.leaderboard?.length) {
        appData.rotmSelectedNodeKey = data.leaderboard[0].nodeKey;
      }
      if (appData.rotmSelectedNodeKey) {
        selectRotmNode(appData.rotmSelectedNodeKey);
      } else {
        renderRotmMap(null);
      }
    }

    async function loadRotm() {
      if (!appData.rotmConfigLoaded && appData.authUser?.isAdmin) {
        try {
          const cfg = await fetchRotmConfig();
          const channelInput = document.getElementById("rotmChannelName");
          if (channelInput && cfg?.channel) channelInput.value = cfg.channel;
          if (cfg?.channel) appData.rotmChannelName = cfg.channel;
          const status = document.getElementById("rotmChannelStatus");
          if (status) status.textContent = "Secret is stored until you update it.";
          appData.rotmConfigLoaded = true;
        } catch {
          const status = document.getElementById("rotmChannelStatus");
          if (status) status.textContent = "Unable to load channel settings.";
        }
      }
      try {
        const data = await fetchRotmData();
        applyRotmPayload(data);
      } catch (err) {
        const el = document.getElementById("rotmFeed");
        if (el) el.innerHTML = "<div class='rotm-feed-row'>Unable to load #rotm data.</div>";
      }
    }

    function startRotmRefresh() {
      if (rotmRefreshTimer) clearInterval(rotmRefreshTimer);
      rotmRefreshTimer = setInterval(() => {
        if (document.hidden) return;
        if (appData.messageStream?.connected) return;
        loadRotm();
      }, ROTM_REFRESH_MS);
    }

    function stopRotmRefresh() {
      if (!rotmRefreshTimer) return;
      clearInterval(rotmRefreshTimer);
      rotmRefreshTimer = null;
    }

    function updateRotmTimers() {
      const timers = document.querySelectorAll(".rotm-cq-timer");
      if (!timers.length) return;
      const now = Date.now();
      timers.forEach((el) => {
        const ts = new Date(el.getAttribute("data-ts") || "").getTime();
        if (!Number.isFinite(ts)) {
          el.textContent = "--";
          return;
        }
        const remaining = Math.max(0, ROTM_QSO_WINDOW_MS - (now - ts));
        const mins = Math.floor(remaining / 60000);
        const secs = Math.floor((remaining % 60000) / 1000);
        el.textContent = `QSO window: ${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
      });
    }

    function startRotmTimers() {
      if (rotmTimerTick) clearInterval(rotmTimerTick);
      rotmTimerTick = setInterval(() => {
        if (document.hidden) return;
        updateRotmTimers();
      }, 1000);
    }

    function stopRotmTimers() {
      if (!rotmTimerTick) return;
      clearInterval(rotmTimerTick);
      rotmTimerTick = null;
    }

    function formatDateTime(value) {
      const d = new Date(value);
      if (!Number.isFinite(d.getTime())) return "unknown";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
    }

    function distanceKm(a, b) {
      const toRad = (v) => (v * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const val = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(val), Math.sqrt(1 - val));
    }

    function badgeHtml(badges) {
      if (!badges.length) return "";
      return `<div class="badge-row">${badges.map((b) => {
        const coverageAttrs = b.meta?.coverage
          ? ` data-coverage-count="${b.meta.coverageCount ?? 0}" data-coverage-label="${(b.label || "").replace(/"/g, "&quot;")}"`
          : "";
        const coverageClass = b.meta?.coverage ? " badge-coverage" : "";
        return `<span class="badge badge-${b.tone}${coverageClass}"${coverageAttrs}>${b.label}</span>`;
      }).join("")}</div>`;
    }

    function formatDriftMinutes(minutes) {
      if (!Number.isFinite(minutes)) return null;
      const sign = minutes < 0 ? "-" : "+";
      const abs = Math.abs(minutes);
      if (abs < 60) return `${sign}${Math.round(abs)}m`;
      if (abs < 60 * 24) return `${sign}${Math.round(abs / 60)}h`;
      if (abs < 60 * 24 * 365) return `${sign}${Math.round(abs / (60 * 24))}d`;
      return `${sign}${Math.round(abs / (60 * 24 * 365))}y`;
    }


    function showRankDetail(repeater) {
      const overlay = document.getElementById("rankDetailOverlay");
      const content = document.getElementById("rankDetailContent");
      if (!overlay || !content || !repeater) return;
      const drift = repeater.clockDriftMinutes;
      const driftLabel = Number.isFinite(drift)
        ? formatDriftMinutes(drift)
        : "Clock drift data unavailable";
      const gpsLabel = repeater.gpsImplausible
        ? (repeater.hiddenOnMap ? "Implausible (hidden)" : "Implausible")
        : (repeater.gpsEstimated ? "Estimated" : "Confirmed");
      content.innerHTML = `
        <div class="rank-detail-close">
          <button type="button" onclick="closeRankDetail()"></button>
        </div>
        <div class="rank-detail-row"><span>Repeater</span><strong>${repeater.name}</strong></div>
        <div class="rank-detail-row"><span>Pub</span><strong>${repeater.pub}</strong></div>
        <div class="rank-detail-row"><span>Location</span><strong>${gpsLabel}</strong></div>
        <div class="rank-detail-row"><span>Score</span><strong>${repeater.score}</strong></div>
        <div class="rank-detail-row"><span>Throughput (24h)</span><strong>${repeater.total24h}</strong></div>
        <div class="rank-detail-row"><span>Zero-hop neighbours</span><strong>${repeater.zeroHopNeighbors24h}</strong></div>
        <div class="rank-detail-row"><span>Avg repeats</span><strong>${repeater.avgRepeats}</strong></div>
        <div class="rank-detail-row"><span>Clock drift</span><strong>${driftLabel}</strong></div>
      `;
      overlay.classList.add("open");
    }

    function closeRankDetail() {
      const overlay = document.getElementById("rankDetailOverlay");
      if (overlay) overlay.classList.remove("open");
    }

    async function fetchFlaggedRepeaters() {
      const url = new URL("/api/repeater-rank-excluded", window.location.origin);
      url.searchParams.set("_ts", Date.now().toString());
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    function wrapImplausibleContent(body) {
      return `
        <div class="rank-detail-close">
          <button type="button" onclick="closeImplausibleList()"></button>
        </div>
        ${body}
      `;
    }

    function buildImplausibleSkeleton(message) {
      return wrapImplausibleContent(`
        <div class="implausible-placeholder">${message}</div>
      `);
    }

    function buildImplausibleList(rows) {
      const items = rows.map((row) => {
        const name = row.name || row.pub || "Unknown repeater";
        const hashLabel = row.hashByte ? ` <span class="chip chip-strong">${row.hashByte}</span>` : "";
        const reasons = Array.isArray(row.excludedReasons)
          ? row.excludedReasons.filter(Boolean)
          : [];
        const reasonLabel = reasons.length
          ? reasons.join(", ")
          : (Array.isArray(row.qualityReasons) ? row.qualityReasons.filter(Boolean).join(", ") : row.quality || "Flagged");
        const lastSeen = row.lastAdvertIngestIso ? formatDateTime(row.lastAdvertIngestIso) : "unknown";
        const hoursAgo = Number.isFinite(row.lastAdvertAgeHours)
          ? `${Math.round(row.lastAdvertAgeHours)}h ago`
          : null;
        return `
          <div class="implausible-row">
            <div class="implausible-title">
              <strong>${name}</strong>${hashLabel}
            </div>
            <div class="implausible-meta">
              <span>Pub: ${row.pub || "--"}</span>
              <span>Last seen: ${lastSeen}${hoursAgo ? `  ${hoursAgo}` : ""}</span>
            </div>
            <div class="implausible-reason">Reasons: ${reasonLabel}</div>
          </div>
        `;
      }).join("");
      return wrapImplausibleContent(`<div class="implausible-list">${items}</div>`);
    }

    async function openImplausibleList() {
      const overlay = document.getElementById("repeaterFlaggedOverlay");
      const content = document.getElementById("repeaterFlaggedContent");
      if (!overlay || !content) return;
      overlay.classList.add("open");
      content.innerHTML = buildImplausibleSkeleton("Loading flagged GPS repeaters...");
      try {
        const data = await fetchFlaggedRepeaters();
        const rows = Array.isArray(data.excluded) ? data.excluded : [];
        const flagged = rows.filter((row) => {
          if (!row) return false;
          if (row.gpsImplausible || row.gpsFlagged) return true;
          if (!Array.isArray(row.excludedReasons)) return false;
          return row.excludedReasons.some((reason) => typeof reason === "string" && reason.toLowerCase().includes("gps"));
        }).sort((a, b) => (b.lastAdvertIngestMs || 0) - (a.lastAdvertIngestMs || 0)).slice(0, 40);
        if (!flagged.length) {
          content.innerHTML = buildImplausibleSkeleton("No flagged GPS repeaters right now.");
          return;
        }
        content.innerHTML = buildImplausibleList(flagged);
      } catch (err) {
        content.innerHTML = buildImplausibleSkeleton(`Unable to load flagged repeaters: ${err?.message || err}`);
      }
    }
    function closeImplausibleList() {
      const overlay = document.getElementById("repeaterFlaggedOverlay");
      if (overlay) overlay.classList.remove("open");
    }

    function openRankExplain() {
      const overlay = document.getElementById("rankExplainOverlay");
      const content = document.getElementById("rankExplainContent");
      if (!overlay || !content) return;
      overlay.classList.add("open");
      content.innerHTML = `
        <div class="rank-detail-close">
          <button type="button" onclick="closeRankExplain()"></button>
        </div>
        <div class="rank-detail-title">How repeater scores are calculated</div>
        <p>Rankers combine live RF events, decoded MeshCORE packets, and AI-assisted path validation to reward real-world contribution.</p>
        <p>Each packet contributes toward a score for the candidate repeater, weighted by repeat density, confidence from multiple observers, and hop consistency. The AI helps decide whether those paths look like genuine mesh propagation or just isolated broadcasts.</p>
        <p>This overlay is designed to be transparent: the AI does not guess your repeater's ability  it learns from observer hits, decoded traffic, and neighbor density, with a human-curated quality check.</p>
        <p>We don't sell the info or route traffic through the internet; we just help you understand how the mesh sees your node.</p>
      `;
    }

    function closeRankExplain() {
      const overlay = document.getElementById("rankExplainOverlay");
      if (overlay) overlay.classList.remove("open");
    }

    async function fetchMessageRoutes(hash, hours = 24) {
      const url = new URL("/api/message-routes", window.location.origin);
      url.searchParams.set("hash", hash);
      url.searchParams.set("hours", String(hours));
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    async function fetchConfidenceHistory(sender, channel, hours = 168, limit = 400) {
      const url = new URL("/api/confidence-history", window.location.origin);
      if (sender) url.searchParams.set("sender", sender);
      if (channel) url.searchParams.set("channel", channel);
      url.searchParams.set("hours", String(hours));
      url.searchParams.set("limit", String(limit));
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    }

    function resetConfidenceMap() {
      if (confidenceTimer) {
        clearTimeout(confidenceTimer);
        confidenceTimer = null;
      }
      if (confidenceMap) {
        confidenceMap.remove();
        confidenceMap = null;
      }
      confidenceLayers = [];
    }

    function initConfidenceMap(paths, extraPoints) {
      const mapEl = document.getElementById("confidenceMap");
      if (!mapEl || !window.L) return;
      confidenceMap = L.map(mapEl, { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(confidenceMap);

      const bounds = [];
      paths.forEach((path) => {
        (path.pathPoints || []).forEach((pt) => {
          if (Number.isFinite(pt.lat) && Number.isFinite(pt.lon)) bounds.push([pt.lat, pt.lon]);
        });
      });
      (extraPoints || []).forEach((pt) => {
        if (Number.isFinite(pt.lat) && Number.isFinite(pt.lon)) bounds.push([pt.lat, pt.lon]);
      });
      if (bounds.length) {
        confidenceMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    function animateConfidencePaths(paths) {
      if (!confidenceMap) return;
      let idx = 0;
      const list = Array.isArray(paths) ? paths : [];
      const total = list.length;
      const step = () => {
        if (idx >= total) return;
        const entry = list[idx];
        const points = (entry.pathPoints || [])
          .filter((pt) => Number.isFinite(pt.lat) && Number.isFinite(pt.lon))
          .map((pt) => [pt.lat, pt.lon]);
        if (points.length >= 2) {
          const routeColor = entry.observed ? "#34c759" : "#ff3b30";
          const line = L.polyline(points, {
            color: routeColor,
            weight: 2,
            opacity: 0.8
          }).addTo(confidenceMap);
          confidenceLayers.push(line);
        }
        idx += 1;
        confidenceTimer = setTimeout(step, 120);
      };
      step();
    }

    function formatRoutePath(route) {
      const names = Array.isArray(route?.pathNames) ? route.pathNames : [];
      if (names.length) return names.join(" > ");
      const hashes = Array.isArray(route?.path) ? route.path : [];
      if (hashes.length) return hashes.join(" > ");
      return "Direct";
    }

    function formatRouteTime(ts) {
      if (!ts) return "--";
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return "--";
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function openMessageRouteOverlay(messageId) {
      const overlay = document.getElementById("messageRouteOverlay");
      const content = document.getElementById("messageRouteContent");
      if (!overlay || !content) return;
      const msg = (appData.messages || []).find((m) =>
        m.id === messageId || m.frameHash === messageId || m.messageHash === messageId
      );
      const sender = msg?.sender || "Unknown";
      const channelName = msg?.channelName || "";
      overlay.classList.add("open");
      resetConfidenceMap();
      content.innerHTML = `
        <div class="rank-detail-close">
          <button type="button" onclick="closeMessageRouteOverlay()">x</button>
        </div>
        <div class="confidence-title">MeshRank Confidence (7 days)</div>
        <div class="confidence-meta" id="confidenceMeta">Sender: ${sender}${channelName ? ` | Channel: ${channelName}` : ""}</div>
        <div class="confidence-meta" id="confidenceStatus">Loading path history...</div>
        <div class="confidence-map"><div id="confidenceMap"></div></div>
        <div class="confidence-meta" style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn" type="button" id="confidenceViewSuccess">Successful routes</button>
          <button class="btn" type="button" id="confidenceViewFailed">Failed routes</button>
        </div>
        <div class="confidence-meta" id="confidenceExplain"></div>
        <div class="confidence-title">Dead ends</div>
        <div class="confidence-deadends" id="confidenceDeadEnds"></div>
      `;

      fetchConfidenceHistory(sender, channelName || null, 168, 400)
        .then((data) => {
          if (!data?.ok) throw new Error(data?.error || "History lookup failed");
          const paths = Array.isArray(data.paths) ? data.paths : [];
          const deadEnds = Array.isArray(data.deadEnds) ? data.deadEnds : [];
          const meta = document.getElementById("confidenceMeta");
          const status = document.getElementById("confidenceStatus");
          const deadEl = document.getElementById("confidenceDeadEnds");
          const explain = document.getElementById("confidenceExplain");
          const btnSuccess = document.getElementById("confidenceViewSuccess");
          const btnFailed = document.getElementById("confidenceViewFailed");
          if (meta) {
            const channelLabel = data.channel ? ` | Channel: ${data.channel}` : "";
            meta.textContent = `Sender: ${data.sender}${channelLabel} ? Messages: ${data.total || 0}`;
          }
          const renderDeadEnds = () => {
            if (!deadEl) return;
            deadEl.innerHTML = deadEnds.length
              ? deadEnds.map((stop) => `
                  <div class="confidence-deadend">
                    <strong>${stop.name || stop.hash}</strong>
                    <span>${stop.count || 0}</span>
                  </div>
                `).join("")
              : "<div class='confidence-meta'>No dead ends detected.</div>";
          };
          const renderMode = (mode) => {
            const successOnly = mode === "success";
            const filtered = successOnly ? paths.filter((p) => p.observed) : paths.filter((p) => !p.observed);
            const points = deadEnds
              .map((d) => ({ lat: d.gps?.lat, lon: d.gps?.lon }))
              .filter((p) => Number.isFinite(p.lat) && Number.isFinite(p.lon));
            resetConfidenceMap();
            initConfidenceMap(filtered, successOnly ? [] : points);
            if (status) {
              status.textContent = filtered.length
                ? `Animating ${filtered.length} ${successOnly ? "successful" : "failed"} routes from the last ${data.hours || 168} hours.`
                : `No ${successOnly ? "successful" : "failed"} routes found in the last ${data.hours || 168} hours.`;
            }
            if (explain) {
              explain.textContent = successOnly
                ? "Successful routes are messages observed by the MeshRank observer network."
                : "Failed routes end before we see the final hop. This can be observer coverage gaps or a repeater failing to forward.";
            }
            if (!successOnly && confidenceMap && points.length) {
              points.forEach((pt) => {
                const dot = L.circleMarker([pt.lat, pt.lon], {
                  radius: 5,
                  color: "#ff9500",
                  fillColor: "#ff9500",
                  fillOpacity: 0.9,
                  weight: 2
                }).addTo(confidenceMap);
                confidenceLayers.push(dot);
              });
            }
            animateConfidencePaths(filtered);
          };
          renderDeadEnds();
          if (btnSuccess) btnSuccess.onclick = () => renderMode("success");
          if (btnFailed) btnFailed.onclick = () => renderMode("failed");
          renderMode("success");
        })
        .catch((err) => {
          content.innerHTML = `
            <div class="rank-detail-close">
              <button type="button" onclick="closeMessageRouteOverlay()">x</button>
            </div>
            <div class="confidence-title">MeshRank Confidence (7 days)</div>
            <div class="confidence-meta">Unable to load confidence data: ${err?.message || err}</div>
          `;
        });
    }

    function closeMessageRouteOverlay() {
      const overlay = document.getElementById("messageRouteOverlay");
      if (overlay) overlay.classList.remove("open");
      resetConfidenceMap();
    }

    function buildObserverBadges(o) {
      const badges = [];
      if (Number.isFinite(o.ageHours)) {
        const ageMinutes = o.ageHours * 60;
        if (ageMinutes <= 15) {
          badges.push({ label: "Live", tone: "green" });
        } else if (o.lowPacketRate || o.ageHours <= 24) {
          badges.push({ label: "Low packet rate", tone: "amber" });
        } else {
          badges.push({ label: "Offline", tone: "gray" });
        }
      }
      if (o.stale) badges.push({ label: "Stale observer", tone: "gray" });
      if (Number.isFinite(o.ageHours) && o.ageHours <= 1 && Number(o.uptimeHours || 0) >= 48) {
        badges.push({ label: "Great Uptime", tone: "green" });
      }
      if (Number(o.packets24h ?? o.packetsToday ?? 0) >= 200) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(o.coverageCount || 0) >= 5) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(o.coverageKm || 0) >= 20) badges.push({ label: "Wide Coverage", tone: "amber" });
      if (Number(o.nearestRepeaterKm || 999) <= 5) badges.push({ label: "Close to Repeater", tone: "green" });
      return badges;
    }

    const STREAM_PAGE_SIZE_MOBILE = 50;
    const STREAM_PAGE_SIZE_DESKTOP = 220;
    const STREAM_YIELD_MS = 25;

    async function fetchRank(opts = {}) {
      const params = new URLSearchParams();
      params.set("_ts", Date.now().toString());
      if (Number.isFinite(opts.limit) && opts.limit > 0) params.set("_limit", opts.limit);
      if (Number.isFinite(opts.skip) && opts.skip > 0) params.set("_skip", opts.skip);
      const res = await fetch(`/api/repeater-rank?${params.toString()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function setRankStatus(text) {
      const el = document.getElementById("rankStatus");
      if (!el) return;
      el.textContent = text || "";
      el.classList.toggle("active", !!text);
    }

    function clearRankStatus() {
      setRankStatus("");
    }

    function cancelRankLoad() {
      appData.rankLoadToken = Symbol("rank-load-cancel");
      appData.rankRenderToken = null;
      appData.rankMarkerToken = null;
      appData.rankLoadComplete = false;
      appData.rankMarkersQueued = false;
      appData.rankMarkersDrawn = false;
      clearRankStatus();
    }

    function showRankSkeleton(count = 15) {
      const list = document.getElementById("rankList");
      if (!list) return;
      list.innerHTML = "";
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i += 1) {
        const skeleton = document.createElement("div");
        skeleton.className = "rank-skeleton";
        skeleton.innerHTML = `
          <div class="rank-skeleton-dot"></div>
          <div class="rank-skeleton-lines">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        frag.appendChild(skeleton);
      }
      list.appendChild(frag);
      setRankStatus("Loading rank");
    }

    function formatMs(value) {
      if (!Number.isFinite(value)) return "--";
      return `${Math.round(value)}ms`;
    }

    function resetRankRenderState() {
      appData.rankData = [];
      appData.rankPayload = { items: [] };
      appData.rankRenderedCount = 0;
      appData.rankMarkerNextIndex = 0;
      appData.rankMarkerCount = 0;
      appData.rankPerf.first100Ms = null;
      appData.rankPerf.renderMs = null;
      appData.rankPerf.markerCount = 0;
      appData.rankPerf.loadedCount = 0;
      appData.rankLoadComplete = false;
      appData.rankMarkersQueued = false;
      appData.rankMarkersDrawn = false;
      appData.rankTotalExpected = null;
      if (rankLayer) rankLayer.clearLayers();
      rankMarkers = new Map();
    }

    async function loadRankDefault() {
      setRankLoading(true);
      const token = Symbol("rank-load");
      appData.rankLoadToken = token;
      resetRankRenderState();
      const pageSize = isMobile() ? STREAM_PAGE_SIZE_MOBILE : STREAM_PAGE_SIZE_DESKTOP;
      try {
        await refreshRankSummary().catch(() => {});
        if (appData.rankLoadToken !== token) return;
        appData.rankTotalExpected = appData.rankSummary?.count ?? null;
        const completed = await loadRankAutoChunks(token, pageSize);
        if (!completed || appData.rankLoadToken !== token) return;
        appData.rankLoadComplete = true;
        const total = appData.rankTotalExpected ?? appData.rankData.length;
        const loaded = appData.rankData.length;
        const totalLabel = total ? ` / ${total}` : "";
        setRankStatus(`Loaded ${loaded}${totalLabel}`);
        const visible = appData.rankVisibleItems || buildVisibleRankItems(appData.rankData);
        queueRankMarkers(visible, { reset: true, limitMarkers: Infinity });
        setTimeout(() => {
          if (appData.rankLoadComplete) clearRankStatus();
        }, 800);
      } finally {
        if (appData.rankLoadToken === token) {
          setRankLoading(false);
        }
      }
    }

    async function loadRankAutoChunks(token, pageSize) {
      let skip = 0;
      let append = false;
      let finished = false;
      while (appData.rankLoadToken === token) {
        let data;
        try {
          const fetchStart = performance.now();
          data = await fetchRank({ limit: pageSize, skip });
          const fetchMs = performance.now() - fetchStart;
          console.log("[perf] rank:fetch", fetchMs, { items: (data?.items || []).length, skip });
          appData.rankPerf.fetchMs = fetchMs;
        } catch (err) {
          console.warn(err);
          break;
        }
        if (appData.rankLoadToken !== token) break;
        const items = Array.isArray(data?.items) ? data.items : [];
        if (!items.length) {
          finished = true;
          break;
        }
        skip += items.length;
        appData.rankData = appData.rankData.concat(items);
        if (!appData.rankTotalExpected && Number.isFinite(data?.count)) {
          appData.rankTotalExpected = data.count;
        }
        appData.rankPayload = { ...data, items: appData.rankData };
        appData.rankPerf.loadedCount = appData.rankData.length;
        renderRankWithOptions(appData.rankPayload, { preserveView: true, append });
        append = true;
        const loaded = appData.rankData.length;
        const total = appData.rankTotalExpected ?? null;
        const badge = total ? ` / ${total}` : "";
        setRankStatus(`Loading ${loaded}${badge}`);
        if (total && loaded >= total) {
          finished = true;
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, STREAM_YIELD_MS));
      }
      return finished;
    }

    function buildVisibleRankItems(items) {
      const needle = (appData.rankFilter || "").toLowerCase();
      const codeFilter = appData.rankCodeFilter ? String(appData.rankCodeFilter).toUpperCase() : null;
      const sorted = [...(items || [])]
        .sort((a, b) => (b.score || 0) - (a.score || 0))
        .filter((r) => {
          const name = String(r.name || "").toLowerCase();
          const pub = String(r.pub || "").toLowerCase();
          const code = String(r.hashByte || "").toLowerCase();
          const matchesText = !needle || name.includes(needle) || pub.includes(needle) || code.includes(needle);
          if (!matchesText) return false;
          if (!codeFilter) return true;
          const hash = String(r.hashByte || "").toUpperCase();
          const pubPrefix = String(r.pub || "").toUpperCase().slice(0, 2);
          return hash.startsWith(codeFilter) || pubPrefix === codeFilter;
        });
      const hiddenSet = new Set();
      sorted.forEach((item) => {
        if (isRepeaterHidden(item) || hasMapHideEmoji(item)) {
          const key = String(item.hashByte || "").toUpperCase();
          if (key) hiddenSet.add(key);
        }
      });
      appData.hiddenRepeaterHashes = hiddenSet;
      return sorted;
    }

    function buildRepeaterBadges(r) {
      const badges = [];
      if (r.stale) {
        const offlineHours = Number.isFinite(r.lastAdvertAgeHours)
          ? Math.ceil(r.lastAdvertAgeHours)
          : null;
        const offlineLabel = offlineHours
          ? `No advert in ${offlineHours}h`
          : "No advert in 24h";
        badges.push({ label: offlineLabel, tone: "gray" });
      }
      if (r.gpsImplausible) badges.push({ label: "GPS implausible", tone: "amber" });
      if (r.gpsEstimated) badges.push({ label: "Location estimated", tone: "blue" });
      if (Number(r.total24h || 0) >= 10) badges.push({ label: "Great TX", tone: "green" });
      if (Number.isFinite(r.avgRssi) && r.avgRssi >= -75) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(r.avgRepeats || 0) >= 3 && Number(r.total24h || 0) >= 10) {
        badges.push({ label: "Great Throughput", tone: "amber" });
      }
      if (Number.isFinite(r.clockDriftMinutes) && Math.abs(r.clockDriftMinutes) >= 60) {
        const driftLabel = formatDriftMinutes(r.clockDriftMinutes);
        if (driftLabel) badges.push({ label: `Clock drift ${driftLabel}`, tone: "amber" });
      }
      return badges;
    }

    function buildRankRowElement(r) {
      const item = document.createElement("div");
      const isHidden = isRepeaterHidden(r);
      const hiddenLabel = r.gpsImplausible ? "GPS implausible" : "GPS unreliable";
      const badges = buildRepeaterBadges(r);
      const scoreBadge = String(Math.round(r.score || 0)).padStart(2, "0");
      const code = r.hashByte ? `<span class="chip" style="margin-left:6px;">${r.hashByte}</span>` : "";
      const observerBadge = r.isObserver ? `<div class="row"><span class="badge">Observer</span></div>` : "";
      const adminControls = `
        <div class="row repeater-location-controls" data-repeater-controls="${r.pub || ""}">
          <span class="admin-only">
            <button class="btn" type="button" data-repeater-locate="${r.pub || ""}">Set location</button>
          </span>
        </div>
      `;
      // Check if name contains  - if so, hide neighbor link to protect privacy
      const nameHasHideEmoji = r.name && String(r.name).includes("");
      const neighborLink = nameHasHideEmoji 
        ? `<span style="color:var(--muted);">Neighbours unavailable</span>`
        : `<a class="link-btn" href="#" data-repeater-neighbors="${r.pub || ""}">View neighbours</a>`;
      item.className = "rank-item" + (isHidden ? " hidden" : "");
      item.dataset.pub = (r.pub || "").toUpperCase();
      item.innerHTML = `
        <div class="score">
          <span class="rank-dot" style="background:${r.color}">${scoreBadge}</span>
          ${r.name} ${code}
        </div>
        <div class="row">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
        <div class="row">Adverts 72h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
        <div class="row">
          ${neighborLink}
          <span style="color:var(--muted);">|</span>
          <a class="link-btn" href="#" data-repeater-pub="${r.pub || ""}">Public key</a>
        </div>
        <div class="row">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
        <div class="row">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
        ${badgeHtml(badges)}
        ${isHidden ? `<div class="row"><span class="badge">${hiddenLabel}</span></div>` : ""}
        ${observerBadge}
        ${adminControls}
      `;
      item.addEventListener("click", () => {
        openRankPopup(r, false);
      });
      return item;
    }

    function renderRankWithOptions(data, opts = {}) {
      const { preserveView = true, append = false } = opts;
      const list = document.getElementById("rankList");
      if (!list) return;
      const items = Array.isArray(data?.items) ? data.items : [];
      appData.rankPayload = data;
      const visible = buildVisibleRankItems(items);
      if (!append) {
        appData.rankPerf.first100Ms = null;
      }
      appData.rankVisibleItems = visible;
      const onMobile = isMobile();
      const total = visible.length;
      if (!append) {
        list.innerHTML = "";
        appData.rankRenderedCount = 0;
        if (rankLayer) rankLayer.clearLayers();
        rankMarkers = new Map();
        appData.rankMarkerNextIndex = 0;
        appData.rankMarkerCount = 0;
        appData.rankPerf.markerCount = 0;
      }
      const startIndex = append ? (appData.rankRenderedCount || 0) : 0;
      const renderToken = Symbol("rank-render");
      appData.rankRenderToken = renderToken;
      let currentIndex = startIndex;
      const batchSize = 40;
      const renderStart = performance.now();
      function renderBatch() {
        if (appData.rankRenderToken !== renderToken) return;
        const frag = document.createDocumentFragment();
        const end = Math.min(currentIndex + batchSize, total);
        for (let i = currentIndex; i < end; i += 1) {
          frag.appendChild(buildRankRowElement(visible[i]));
        }
        list.appendChild(frag);
        currentIndex = end;
        appData.rankRenderedCount = currentIndex;
        if (!appData.rankPerf.first100Ms && currentIndex >= 100) {
          appData.rankPerf.first100Ms = performance.now() - renderStart;
        }
        if (currentIndex < total) {
          requestAnimationFrame(renderBatch);
        } else {
          const renderMs = performance.now() - renderStart;
          console.log("[perf] rank:render", renderMs, { rendered: total });
          appData.rankPerf.renderMs = renderMs;
          appData.rankPerf.rendered = total;
          updateRankDebugOverlay();
          if (!onMobile && rankMap && !preserveView && total) {
            const bounds = visible
              .filter((r) => {
                if (isRepeaterHidden(r) || hasMapHideEmoji(r)) return false;
                return r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon);
              })
              .map((r) => [r.gps.lat, r.gps.lon]);
            if (bounds.length) rankMap.fitBounds(bounds, { padding: [30, 30] });
          }
          if (appData.rankLoadComplete) {
            queueRankMarkers(visible, { reset: true, limitMarkers: Infinity });
          }
        }
      }
      requestAnimationFrame(renderBatch);
    }

    function scheduleRankMarkers(visible, opts = {}) {
      const onComplete = typeof opts.onComplete === "function" ? opts.onComplete : null;
      if (!window.L || !rankLayer || !rankMap) {
        onComplete?.();
        return;
      }
      if (!appData.rankLoadComplete) {
        onComplete?.();
        return;
      }
      const reset = opts.reset ?? false;
      const limitMarkers = Number.isFinite(opts.limitMarkers) ? opts.limitMarkers : Infinity;
      if (reset) {
        rankLayer.clearLayers();
        rankMarkers = new Map();
        appData.rankMarkerNextIndex = 0;
        appData.rankMarkerCount = 0;
        appData.rankPerf.markerCount = 0;
      }
      if (!Array.isArray(visible) || !visible.length) {
        updateRankDebugOverlay();
        onComplete?.();
        return;
      }
      if (limitMarkers <= 0) {
        updateRankDebugOverlay();
        onComplete?.();
        return;
      }
      const token = Symbol("rank-markers");
      appData.rankMarkerToken = token;
      let markerIndex = appData.rankMarkerNextIndex || 0;
      const batchSize = 25;
      function renderMarkerBatch() {
        if (appData.rankMarkerToken !== token) {
          onComplete?.();
          return;
        }
        let added = 0;
        while (markerIndex < visible.length && added < batchSize) {
          if (rankMarkers.size >= limitMarkers) {
            break;
          }
          const r = visible[markerIndex++];
          const shouldHideFromMap = isRepeaterHidden(r) || hasMapHideEmoji(r) || r.stale;
          if (shouldHideFromMap) continue;
          const lat = Number(r.gps?.lat);
          const lon = Number(r.gps?.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          const marker = L.circleMarker([lat, lon], {
            radius: 8,
            color: r.color,
            fillColor: r.color,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(buildRankPopupHtml(r)).addTo(rankLayer)
            .on("click", () => openRankPopup(r, true));
          if (r.pub) rankMarkers.set(r.pub, marker);
          added += 1;
          appData.rankMarkerCount = rankMarkers.size;
          appData.rankPerf.markerCount = rankMarkers.size;
        }
        appData.rankMarkerNextIndex = markerIndex;
        updateRankDebugOverlay();
        if (markerIndex < visible.length && rankMarkers.size < limitMarkers) {
          requestAnimationFrame(renderMarkerBatch);
        } else {
          onComplete?.();
        }
      }
      requestAnimationFrame(renderMarkerBatch);
    }

    function queueRankMarkers(visible, opts = {}) {
      if (!appData.rankLoadComplete) return;
      if (appData.rankMarkersQueued) return;
      if (!window.L || !rankLayer || !rankMap) {
        setTimeout(() => queueRankMarkers(visible, opts), 250);
        return;
      }
      const reset = opts.reset ?? true;
      const limitMarkers = Number.isFinite(opts.limitMarkers) ? opts.limitMarkers : Infinity;
      appData.rankMarkersQueued = true;
      scheduleRankMarkers(visible, {
        reset,
        limitMarkers,
        onComplete: () => {
          appData.rankMarkersQueued = false;
          appData.rankMarkersDrawn = true;
          appData.rankPerf.markerCount = rankMarkers.size;
          updateRankDebugOverlay();
        }
      });
    }

    function updateRankDebugOverlay() {
      if (!rankDebugMode) return;
      if (!rankDebugOverlay) {
        rankDebugOverlay = document.getElementById("rankDebugOverlay");
      }
      if (!rankDebugOverlay) return;
      rankDebugOverlay.style.display = "block";
      const perf = appData.rankPerf || {};
      const loaded = (appData.rankData || []).length;
      rankDebugOverlay.innerHTML = `
        <div>UI paint: ${formatMs(perf.uiPaintMs)}</div>
        <div>First 100: ${formatMs(perf.first100Ms)}</div>
        <div>Loaded: ${loaded}</div>
        <div>Markers: ${perf.markerCount ?? 0}</div>
      `;
    }


    async function fetchNodeRank() {
      const res = await fetch(`/api/node-rank?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRankSummary() {
      const res = await fetch(`/api/repeater-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshRankSummary() {
      try {
        const summary = await fetchRankSummary();
        appData.rankSummary = summary;
        renderRankSummary(summary);
      } catch {}
    }

    async function fetchNodeRankSummary() {
      const res = await fetch(`/api/node-rank-summary?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function refreshNodeRankSummary() {
      try {
        const summary = await fetchNodeRankSummary();
        appData.nodeRankSummary = summary;
        renderNodeRankSummary(summary);
      } catch {}
    }

    async function fetchMeshScore() {
      const res = await fetch("/api/meshscore", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRfLatest() {
      const res = await fetch("/api/rf-latest?limit=100", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRouteSuggestions() {
      const res = await fetch(`/api/route-suggestions?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function shortHex(value, len) {
      if (!value) return "--";
      const s = String(value);
      if (s.length <= len) return s;
      return s.slice(0, len);
    }

    function getHopCount(msg) {
      const pathLen = Array.isArray(msg.path) ? msg.path.length : 0;
      const pathLength = Number.isFinite(msg.pathLength) ? msg.pathLength : 0;
      const uniqueHop = Number.isFinite(msg.uniqueHopCount) ? msg.uniqueHopCount : 0;
      const repeats = Number.isFinite(msg.repeats) ? msg.repeats : 0;
      return Math.max(pathLen, pathLength, uniqueHop, repeats);
    }

    function buildRepeatersByCode(data) {
      const map = new Map();
      const items = data?.items || [];
      for (const item of items) {
        const code = String(item.hashByte || "").toUpperCase();
        if (!code) continue;
        if (!map.has(code)) map.set(code, []);
        map.get(code).push({
          pub: item.pub,
          name: item.name || code,
          gps: item.gps || null
        });
      }
      return map;
    }

    async function ensureRouteSuggestions() {
      if (appData.routeSuggestions) return;
      try {
        appData.routeSuggestions = await fetchRouteSuggestions();
      } catch {
        appData.routeSuggestions = { byCode: {} };
      }
    }

    const routeOverrides = (() => {
      try {
        return JSON.parse(localStorage.getItem("routeOverrides") || "{}");
      } catch {
        return {};
      }
    })();

    function saveRouteOverrides() {
      try {
        localStorage.setItem("routeOverrides", JSON.stringify(routeOverrides));
      } catch {}
    }

    function overrideRouteName(hash, name) {
      const key = String(hash || "").toUpperCase();
      if (!key) return;
      if (!name) {
        delete routeOverrides[key];
      } else {
        routeOverrides[key] = name;
      }
      saveRouteOverrides();
    }

    function resolveRouteName(hash, fallback) {
      const key = String(hash || "").toUpperCase();
      if (key && routeOverrides[key]) return routeOverrides[key];
      const suggestion = appData.routeSuggestions?.byCode?.[key];
      if (suggestion?.accepted && suggestion.name) return suggestion.name;
      return fallback || hash || "#unknown";
    }

    function formatPathLabel(p) {
      const names = Array.isArray(p.pathNames) ? p.pathNames : [];
      const codes = Array.isArray(p.path) ? p.path : [];
      if (names.length) {
        const merged = names.map((name, idx) => {
          const code = codes[idx] || "";
          if (name === "#unknown") return resolveRouteName(code, code || "#unknown");
          const resolved = resolveRouteName(code, name);
          return code ? `${resolved} (${code})` : resolved;
        });
        return merged.join(" > ");
      }
      if (codes.length) return codes.join(" > ");
      return "--";
    }

    function renderRfList() {
      const list = document.getElementById("rfList");
      if (!list) return;
      const search = document.getElementById("rfSearch")?.value?.trim().toLowerCase() || "";
      const typeFilter = document.getElementById("rfTypeFilter")?.value || "";
      const filtered = appData.rfPackets.filter((p) => {
        if (typeFilter && p.payloadType !== typeFilter) return false;
        if (!search) return true;
        const hay = [
          p.hash,
          p.fp,
          p.senderPublicKey,
          p.destinationHash,
          p.channelHash,
          p.channelName,
          p.routeTypeName,
          ...(p.path || []),
          ...(p.pathNames || [])
        ].filter(Boolean).join(" ").toLowerCase();
        return hay.includes(search);
      });
      list.innerHTML = "";
      document.getElementById("rfCount").textContent = `${filtered.length} packets`;
      const total = appData.rfPackets.length;
      const ok = appData.rfPackets.filter((p) => p.crc === true).length;
      const bad = appData.rfPackets.filter((p) => p.crc === false).length;
      const typeCounts = {};
      appData.rfPackets.forEach((p) => {
        const t = p.payloadType || "Unknown";
        typeCounts[t] = (typeCounts[t] || 0) + 1;
      });
      const topType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "--";
      document.getElementById("rfTotal").textContent = total;
      document.getElementById("rfOk").textContent = ok;
      document.getElementById("rfBad").textContent = bad;
      document.getElementById("rfTopType").textContent = topType;
      const slice = filtered.slice(-150).reverse();
      const frag = document.createDocumentFragment();
      const header = document.createElement("div");
      header.className = "rf-row rf-header";
      header.innerHTML = `
          <div>Time</div>
          <div>Type</div>
          <div>Route</div>
          <div>Hash</div>
          <div>Hops</div>
          <div>Sender</div>
          <div>Observers</div>
          <div>RSSI</div>
          <div>SNR</div>
          <div>Len</div>
          <div>CRC</div>
          <div>Edit</div>
        `;
      frag.appendChild(header);
      slice.forEach((p) => {
        const row = document.createElement("div");
        row.className = "rf-row";
        row.dataset.key = String(p.hash || p.fp || "--");
        const time = p.ts ? new Date(p.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" }) : "--";
        const hash = shortHex(p.hash || p.fp || "--", 10);
        const route = p.routeTypeName || "--";
        const pathLabel = formatPathLabel(p);
        const hopCount = Number.isFinite(p.hopCount) ? p.hopCount : (p.pathLength ?? 0);
        const sender = p.senderName || (p.senderPublicKey ? shortHex(p.senderPublicKey, 12) : "--");
        const entries = Array.isArray(p.observerEntries) ? p.observerEntries : [];
        const toggle = entries.length
          ? `<button class="rf-toggle" data-rf-toggle="${row.dataset.key}">+</button> ${p.observerCount ?? 1}`
          : `${p.observerCount ?? 1}`;
        row.innerHTML = `
          <div>${time}</div>
          <div><span class="rf-type">${p.payloadType || "Unknown"}</span></div>
          <div>${route}</div>
          <div>${hash}</div>
          <div title="${pathLabel}">${hopCount}</div>
          <div>${sender}</div>
          <div>${toggle}</div>
          <div>${Number.isFinite(p.rssi) ? p.rssi : "--"}</div>
          <div>${Number.isFinite(p.snr) ? p.snr : "--"}</div>
          <div>${p.len ?? "--"}</div>
          <div>${p.crc === true ? "CRC" : p.crc === false ? "BAD" : "--"}</div>
          <div><button class="link-btn rf-edit" type="button">Edit</button></div>
        `;
        row.addEventListener("click", () => {
          appData.rfSelected = p;
          renderRfDetail();
        });
        row.querySelector(".rf-edit")?.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          appData.routeActiveId = p.hash || null;
          appData.routeActiveMsg = {
            id: p.hash || "--",
            path: Array.isArray(p.path) ? p.path : [],
            pathNames: Array.isArray(p.pathNames) ? p.pathNames : []
          };
          appData.routeActivePathCodes = Array.isArray(p.path) ? p.path.slice() : [];
          appData.routeActivePathPoints = [];
          await ensureRouteSuggestions();
          openRouteOverrideModal();
        });
        frag.appendChild(row);
        entries.forEach((entry) => {
          const child = document.createElement("div");
          child.className = "rf-row rf-child is-hidden";
          child.dataset.parentKey = row.dataset.key;
          const childTime = entry.ts
            ? new Date(entry.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" })
            : "--";
          const childPath = formatPathLabel(entry);
          const childObserver = entry.observerName || entry.observerId || "--";
          child.innerHTML = `
            <div>${childTime}</div>
            <div><span class="rf-type">Obs</span></div>
            <div>via</div>
            <div>--</div>
            <div title="${childPath}">${childPath}</div>
            <div>${childObserver}</div>
            <div>1</div>
            <div>${Number.isFinite(entry.rssi) ? entry.rssi : "--"}</div>
            <div>${Number.isFinite(entry.snr) ? entry.snr : "--"}</div>
            <div>${entry.len ?? "--"}</div>
            <div>--</div>
          `;
          frag.appendChild(child);
        });
      });
      list.appendChild(frag);
    }

    function renderRfDetail() {
      const detail = document.getElementById("rfDetail");
      if (!detail) return;
      const p = appData.rfSelected;
      if (!p) {
        detail.innerHTML = `<div class="rf-kv">Select a packet to inspect its payload.</div>`;
        return;
      }
      const pathLabel = formatPathLabel(p);
      const sender = p.senderName || p.senderPublicKey || "--";
      const channelLabel = p.channelName ? `${p.channelName} (${p.channelHash || "--"})` : (p.channelHash || "--");
      const appFlags = Number.isFinite(p.appFlags) ? `0x${p.appFlags.toString(16).toUpperCase().padStart(2, "0")}` : "--";
      const observerNames = Array.isArray(p.observerHits) && p.observerHits.length
        ? p.observerHits.join(", ")
        : (p.observerName || "--");
      detail.innerHTML = `
        <div class="rf-kv"><strong>Packet</strong></div>
        <div class="rf-kv">Type: ${p.payloadType || "Unknown"}</div>
        <div class="rf-kv">Route: ${p.routeTypeName || "--"}</div>
        <div class="rf-kv">Hash: ${(p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Full hash: ${(p.frameHash || p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Time: ${p.ts ? new Date(p.ts).toLocaleString() : "--"}</div>
        <div class="rf-kv">RSSI/SNR: ${Number.isFinite(p.rssi) ? p.rssi : "--"} / ${Number.isFinite(p.snr) ? p.snr : "--"}</div>
        <div class="rf-kv">CRC: ${p.crc === true ? "ok" : p.crc === false ? "fail" : "unknown"}</div>
        <div class="rf-kv">Length: ${p.len ?? "--"}</div>
        <div class="rf-kv">Observers: ${observerNames}</div>
        <div class="rf-kv">Fingerprint: ${p.fp || "--"}</div>
        <div class="rf-kv">Sender: ${sender}</div>
        <div class="rf-kv">Destination: ${p.destinationHash || "--"}</div>
        <div class="rf-kv">Channel: ${channelLabel}</div>
        <div class="rf-kv">Path (${p.pathLength ?? 0} hops): ${pathLabel}</div>
        <div class="rf-kv">Advert name: ${p.advertName || "--"}</div>
        <div class="rf-kv">App flags: ${appFlags}</div>
        <div class="rf-kv">Payload bytes: ${p.payloadBytes ?? "--"}</div>
        <div class="rf-kv">Decrypted: ${p.decrypted === true ? "yes" : "no"}</div>
        <div class="rf-kv">Valid: ${p.isValid === true ? "yes" : p.isValid === false ? "no" : "unknown"}</div>
      `;
    }

    function renderMeshScore(data, rangeDays) {
      if (!data) return;
      appData.meshScore = data;
      document.getElementById("meshUpdated").textContent = new Date(data.updatedAt).toLocaleTimeString();
      document.getElementById("meshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("meshYesterday").textContent = data.scores?.yesterday ?? 0;
      document.getElementById("meshDelta").textContent = data.scores?.delta ?? 0;
      document.getElementById("meshMessages").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshDevices").textContent = data.totals?.devices ?? 0;
      document.getElementById("meshRepeaters").textContent = data.totals?.activeRepeaters ?? 0;
      document.getElementById("meshRooms").textContent = data.totals?.roomServers ?? 0;
      document.getElementById("meshChat").textContent = data.totals?.chatNodes ?? 0;
      document.getElementById("meshCompanions").textContent = data.totals?.companions ?? 0;
      document.getElementById("meshMsgsToday").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshMsgsObserver").textContent = data.messages?.observerToday ?? 0;

      const series = data.series || [];
      const days = rangeDays || 7;
      const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const filtered = series.filter((s) => new Date(s.date) >= cutoff);
      const points = filtered.map((s, idx) => {
        const x = (idx / Math.max(1, filtered.length - 1)) * 580 + 10;
        const y = 200 - (Math.max(0, Math.min(100, s.score)) / 100) * 160;
        return `${x},${y}`;
      });
      const line = document.getElementById("meshLine");
      const area = document.getElementById("meshArea");
      if (points.length) {
        line.setAttribute("points", points.join(" "));
        const areaPoints = [`10,200`, ...points, `590,200`];
        area.setAttribute("points", areaPoints.join(" "));
      } else {
        line.setAttribute("points", "");
        area.setAttribute("points", "");
      }

      document.getElementById("rankMeshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("rankMeshYesterday").textContent = data.scores?.yesterday ?? 0;
    }

    function renderRank(data) {
      if (!data?.items) return;
      appData.rankData = data.items.slice();
      appData.rankPayload = data;
      renderRankWithOptions({ ...data, items: appData.rankData }, { preserveView: true });
    }

    function hideFlaggedRepeater(pub) {
      const key = String(pub || "").trim().toUpperCase();
      if (!key) return false;
      const entries = appData.rankData || [];
      let updated = false;
      entries.forEach((entry) => {
        if (!entry || String(entry.pub || "").toUpperCase() !== key) return;
        entry.hiddenOnMap = true;
        entry.gpsFlagged = true;
        entry.gpsImplausible = true;
        updated = true;
      });
      if (!updated) return false;
      const payload = {
        ...(appData.rankPayload || {}),
        items: entries.slice()
      };
      renderRankWithOptions(payload, { preserveView: true });
      return true;
    }

    function renderRankSummary(summary) {
      if (!summary) return;
      document.getElementById("rankUpdated").textContent = summary.updatedAt
        ? formatDateTime(summary.updatedAt)
        : "--";
      document.getElementById("rankTotal").textContent = summary.count ?? 0;
      document.getElementById("rankActive").textContent = summary.totals?.active ?? 0;
    }


    function renderNodeRankSummary(summary) {
      if (!summary) return;
      document.getElementById("nodeRankUpdated").textContent = summary.updatedAt
        ? formatDateTime(summary.updatedAt)
        : "--";
      document.getElementById("nodeRankTotal").textContent = summary.count ?? 0;
      document.getElementById("nodeRankActive").textContent = summary.totals?.active ?? 0;
      document.getElementById("nodeRankMessages").textContent = summary.totals?.messages24h ?? 0;
    }

    function renderNodeRank(data) {
      if (!data?.items) return;
      appData.nodeRank = data;
      const list = document.getElementById("nodeRankList");
      list.innerHTML = "";
      if (nodeRankLayer) nodeRankLayer.clearLayers();
      nodeRankMarkers = new Map();

      const needle = (document.getElementById("nodeRankSearch")?.value || "").trim().toLowerCase();
      const onMobile = isMobile();
      const visible = data.items.filter((n) => {
        if (!needle) return true;
        const name = String(n.name || "").toLowerCase();
        const pub = String(n.pub || "").toLowerCase();
        const model = String(n.model || "").toLowerCase();
        return name.includes(needle) || pub.includes(needle) || model.includes(needle);
      });

      visible.forEach((n) => {
        const scoreBadge = String(Math.round(n.score || 0)).padStart(2, "0");
        const lastMsg = n.lastMessageAt ? formatDateTime(n.lastMessageAt) : "unknown";
        const lastSeen = n.lastSeen ? formatDateTime(n.lastSeen) : "unknown";
        const model = n.model || "--";
        const item = document.createElement("div");
        item.className = "rank-item";
        item.innerHTML = `
          <div class="score">
            <span class="rank-dot" style="background:${n.scoreColor}">${scoreBadge}</span>
            <div class="rank-main">
              <strong>${n.name || n.pub || "Unknown"}</strong>
              <div class="rank-meta">Messages 24h: ${n.messages24h ?? 0} | Unique: ${n.uniqueMessages24h ?? 0}</div>
              <div class="rank-meta">Last message: ${lastMsg}</div>
              <div class="rank-meta">Last seen: ${lastSeen}</div>
              <div class="rank-meta">Model: ${model}</div>
            </div>
          </div>
        `;
        list.appendChild(item);

        if (!onMobile && n.gps && Number.isFinite(n.gps.lat) && Number.isFinite(n.gps.lon)) {
          const marker = L.circleMarker([n.gps.lat, n.gps.lon], {
            radius: 7,
            color: n.scoreColor,
            fillColor: n.scoreColor,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(`${n.name || n.pub} | ${n.messages24h ?? 0} msgs`);
          marker.addTo(nodeRankLayer);
          if (n.pub) nodeRankMarkers.set(n.pub, marker);
        }
      });

      if (!onMobile && nodeRankMap && visible.length) {
        const bounds = visible
          .filter((n) => n.gps && Number.isFinite(n.gps.lat) && Number.isFinite(n.gps.lon))
          .map((n) => [n.gps.lat, n.gps.lon]);
        if (bounds.length) nodeRankMap.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    function scrollRankItemToTop(pub) {
      if (!pub) return;
      const list = document.getElementById("rankList");
      const scroll = document.getElementById("rankScroll");
      const item = document.querySelector(`.rank-item[data-pub="${String(pub).toUpperCase()}"]`);
      if (!list || !scroll || !item) return;
      scroll.scrollTop = item.offsetTop - scroll.offsetTop;
    }

    function buildRankPopupHtml(r) {
      const impact = Math.min(100, Math.max(0, r.score || 0));
      const code = r.hashByte ? ` <span class="chip chip-strong">${r.hashByte}</span>` : "";
      const isAdmin = !!appData.authUser?.isAdmin;
      const flaggedNote = r.gpsImplausible
        ? `<div style="font-size:12px;color:#9a5b00;margin-top:4px;">GPS implausible${r.hiddenOnMap ? " - hidden from map" : ""}</div>`
        : "";
      const estimatedNote = r.gpsEstimated
        ? `<div style="font-size:12px;color:#356">Location estimated (${r.gpsEstimateNeighbors || "?"} neighbors)</div>`
        : "";
      const zeroHopPopupLine = r.zeroHopUnavailableReason
        ? "Local neighbours stats are unavailable for repeaters hidden from the map."
        : "View neighbours for more details.";
      const actionButtons = `
        <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn" type="button" data-repeater-flag="${r.pub}">Flag wrong location</button>
          ${isAdmin ? `<button class="btn" type="button" data-repeater-correct="${r.pub}">Correct location</button>` : ""}
        </div>
        ${isAdmin ? "" : `<div style="margin-top:6px;font-size:12px;color:rgba(60,60,67,0.6);">Admin login required to correct location.</div>`}
      `;
      const offlineHours = Number.isFinite(r.lastAdvertAgeHours)
        ? Math.ceil(r.lastAdvertAgeHours)
        : null;
      const statusLabel = r.stale
        ? `Offline (${offlineHours ? `${offlineHours}h` : "24h+"})`
        : "Active";
      const locationNote = `${flaggedNote}${estimatedNote}${actionButtons}`;
      return `
        <div style="min-width:220px;font-family:'Space Grotesk',system-ui,sans-serif;">
          <div style="font-weight:700;margin-bottom:6px;">${r.name}${code}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);">Score: <strong>${r.score}</strong> | ${statusLabel}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Adverts 72h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">${zeroHopPopupLine}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
          ${locationNote}
          <div style="margin-top:8px;font-size:12px;color:rgba(60,60,67,0.6);">Network impact</div>
          <div style="height:8px;border-radius:999px;background:rgba(0,122,255,0.12);overflow:hidden;">
            <div style="height:100%;width:${impact}%;background:linear-gradient(90deg,#34c759,#007aff);"></div>
          </div>
        </div>
      `;
    }

    function openRankPopup(r, skipPan) {
      if (!r) return;
      if (isRepeaterHidden(r) || hasMapHideEmoji(r)) {
        showToast("Hidden repeaters remain off the map for safety; you can tap the repeater name for more info but the map popup is suppressed.");
        return;
      }
      const list = document.getElementById("rankList");
      const listItem = document.querySelector(`.rank-item[data-pub="${(r.pub || "").toUpperCase()}"]`);
      document.querySelectorAll(".rank-item.focused").forEach((el) => el.classList.remove("focused"));
      if (listItem) {
        listItem.classList.add("focused");
        if (list && list.firstChild !== listItem) {
          list.prepend(listItem);
        }
        listItem.scrollIntoView({ block: "start", behavior: "smooth" });
      }
      const lat = r.gps?.lat;
      const lon = r.gps?.lon;
      const hasGps = Number.isFinite(lat) && Number.isFinite(lon);
      const marker = r.pub ? rankMarkers.get(r.pub) : null;
      const html = buildRankPopupHtml(r);

      if (marker) {
        marker.setPopupContent(html);
        marker.openPopup();
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView(marker.getLatLng(), targetZoom, { animate: true });
        }
        return;
      }

      if (hasGps) {
        const popup = L.popup({ closeButton: true, autoClose: true })
          .setLatLng([lat, lon])
          .setContent(html)
          .openOn(rankMap);
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView([lat, lon], targetZoom, { animate: true });
        }
      }
    }


    const navLinks = document.querySelectorAll(".nav a, .mobile-nav a, .mobile-menu a");
    const authLinks = document.querySelectorAll(".auth-links [data-view]");
    const menuToggle = document.getElementById("menuToggle");
    const menuBackdrop = document.getElementById("menuBackdrop");
    const channelToggles = document.querySelectorAll("[data-channels-toggle]");
    const closeMenu = () => {
      document.body.classList.remove("menu-open-left", "menu-open-right");
    };
    menuToggle?.addEventListener("click", () => {
      document.body.classList.toggle("menu-open-right");
      document.body.classList.remove("menu-open-left");
    });
    menuBackdrop?.addEventListener("click", closeMenu);
    channelToggles.forEach((toggle) => {
      toggle.addEventListener("click", () => {
        document.body.classList.toggle("menu-open-left");
        document.body.classList.remove("menu-open-right");
      });
    });
    navLinks.forEach((link) => {
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          document.body.classList.remove("route-open");
          let view = link.dataset.view;
          if (view === "account" && !appData.authUser) {
            showToast("Log in to access your account.");
            setView("auth");
            closeMenu();
            return;
          }
          closeMenu();
          setView(view);

        if (view === "rank") {
          if (!rankMap) setTimeout(() => initRankMap(), 0);
          const clickStart = performance.now();
          cancelRankLoad();
          showRankSkeleton();
          appData.rankPerf.uiPaintMs = performance.now() - clickStart;
          console.log("[perf] rank:click->ui", appData.rankPerf.uiPaintMs);
          updateRankDebugOverlay();
          requestAnimationFrame(() => {
            loadRankDefault().catch((err) => {
              console.warn(err);
              const list = document.getElementById("rankList");
              if (list) list.innerHTML = "<div class='rank-item'>No repeaters yet.</div>";
            });
            setTimeout(async () => {
              try {
                const mesh = await fetchMeshScore();
                renderMeshScore(mesh, meshRangeDays);
              } catch {}
            }, 0);
          });
        }

        if (view === "channel-directory") {
          await loadChannelDirectory();
        }

        if (view === "node-rank") {
          if (!appData.authUser) {
            setView("channels");
            return;
          }
          if (!isMobile() && !nodeRankMap) initNodeRankMap();
          try {
            await refreshNodeRankSummary();
            const data = await fetchNodeRank();
            renderNodeRank(data);
            if (nodeRankMap) {
              setTimeout(() => nodeRankMap.invalidateSize(), 80);
            }
          } catch (err) {
            const list = document.getElementById("nodeRankList");
            list.innerHTML = "<div class='rank-item'>No nodes yet.</div>";
          }
        }

        if (view === "meshscore") {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        }

        if (view === "rf") {
          try {
            const payload = await fetchRfLatest();
            const items = payload.items || [];
            const last = items[items.length - 1];
            const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
            if (sig !== appData.rfLastSig) {
              appData.rfLastSig = sig;
              appData.rfPackets = items;
              document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
              renderRfList();
            }
          } catch {}
        }

        if (view === "observer") {
          if (!observerMap) initObserverMap();
          if (observerMap) {
            setTimeout(() => observerMap.invalidateSize(), 80);
          }
        }
        if (view === "rotm") {
          if (!rotmMap) initRotmMap();
          await loadRotm();
          startRotmRefresh();
          startRotmTimers();
        } else {
          stopRotmRefresh();
          stopRotmTimers();
        }

        if (view === "observer-rank") {
          if (!observerRankMap) initObserverRankMap();
          if (observerRankMap) {
            setTimeout(() => observerRankMap.invalidateSize(), 80);
          }
          try {
            setObserverRankLoading(true);
            await refreshObserverRankSummary();
            const data = await fetchObserverRank();
            appData.observerRank = data;
            renderObserverRank(data);
            renderObserverRankMap(data);
          } catch {}
          finally {
            setObserverRankLoading(false);
          }
        }
        if (view === "why") {
          // static content
        }
      });
    });
    const sidebarViewLinks = document.querySelectorAll("[data-sidebar-view]");
    sidebarViewLinks.forEach((link) => {
      link.addEventListener("click", (ev) => {
        ev.preventDefault();
        const view = link.dataset.sidebarView;
        if (!view) return;
        document.body.classList.remove("route-open");
        closeMenu();
        setView(view);
      });
    });
    authLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const view = link.dataset.view;
        if (view) setView(view);
      });
    });

    const loginBtn = document.getElementById("loginBtn");
    const authPanel = document.getElementById("authPanel");
    const authCloseBtn = document.getElementById("authCloseBtn");
    const authFlowEmail = document.getElementById("authFlowEmail");
    const authFlowName = document.getElementById("authFlowName");
    const authFlowPassword = document.getElementById("authFlowPassword");
    const authFlowNameField = document.getElementById("authFlowNameField");
    const authFlowPasswordField = document.getElementById("authFlowPasswordField");
    const authFlowSubmit = document.getElementById("authFlowSubmit");
    const authFlowError = document.getElementById("authFlowError");
    const authFlowHint = document.getElementById("authFlowHint");
    const accountCloseBtn = document.getElementById("accountCloseBtn");
    const accountLogoutBtn = document.getElementById("accountLogoutBtn");
    const accountManageChannels = document.getElementById("accountManageChannels");
    const accountClaimBtn = document.getElementById("accountClaimBtn");
    const accountNodeId = document.getElementById("accountNodeId");
    const accountClaimStatus = document.getElementById("accountClaimStatus");
    const changesModal = document.getElementById("changesModal");
    const changesClose = document.getElementById("changesClose");

    loginBtn?.addEventListener("click", async () => {
      if (appData.authUser) {
        setView("account");
        await loadAccountData();
      } else {
        setView("auth");
        setAuthFlowMode("email");
      }
    });
    authCloseBtn?.addEventListener("click", () => {
      setView("channels");
    });
    accountCloseBtn?.addEventListener("click", () => {
      setView("channels");
    });
    accountPanel?.addEventListener("click", (e) => {
      const card = accountPanel.querySelector(".account-modal");
      if (card && !card.contains(e.target)) {
        setView("channels");
      }
    });

    document.querySelectorAll("[data-toggle-password]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const target = btn.getAttribute("data-toggle-password");
        const input = target ? document.querySelector(target) : null;
        if (!input) return;
        input.type = input.type === "password" ? "text" : "password";
        btn.textContent = input.type === "password" ? "Show" : "Hide";
      });
    });

    const forgotPasswordLink = document.getElementById("forgotPasswordLink");
    forgotPasswordLink?.addEventListener("click", (event) => {
      event.preventDefault();
      showToast("Forgot password is not available yet. Please email support.");
    });

    let authFlowMode = "email";
    function setAuthFlowMode(mode) {
      authFlowMode = mode;
      if (!authFlowNameField || !authFlowPasswordField || !authFlowSubmit) return;
      if (authFlowError) authFlowError.textContent = "";
      if (authFlowHint) authFlowHint.style.display = "none";
      if (mode === "email") {
        authFlowNameField.style.display = "none";
        authFlowPasswordField.style.display = "none";
        authFlowSubmit.textContent = "Continue";
        return;
      }
      if (mode === "login") {
        authFlowNameField.style.display = "none";
        authFlowPasswordField.style.display = "block";
        authFlowSubmit.textContent = "Log in";
        return;
      }
      authFlowNameField.style.display = "block";
      authFlowPasswordField.style.display = "block";
      authFlowSubmit.textContent = "Create account";
      if (authFlowHint) authFlowHint.style.display = "block";
    }

    authFlowEmail?.addEventListener("input", () => {
      setAuthFlowMode("email");
    });

    setAuthFlowMode("email");

    authFlowSubmit?.addEventListener("click", async () => {
      if (authFlowError) authFlowError.textContent = "";
      const email = authFlowEmail?.value?.trim() || "";
      if (!email) {
        if (authFlowError) authFlowError.textContent = "Enter your email address.";
        return;
      }
      if (authFlowMode === "email") {
        try {
          const res = await fetch(`/api/auth/exists?email=${encodeURIComponent(email)}`);
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) throw new Error(data.error || "Unable to check account.");
          setAuthFlowMode(data.exists ? "login" : "register");
        } catch (err) {
          if (authFlowError) authFlowError.textContent = err?.message || String(err);
        }
        return;
      }
      const password = authFlowPassword?.value || "";
      if (!password) {
        if (authFlowError) authFlowError.textContent = "Enter your password.";
        return;
      }
      if (authFlowMode === "login") {
        const res = await fetch("/api/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: email, password })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) {
          if (authFlowError) authFlowError.textContent = data.error || "Login failed.";
          return;
        }
        appData.authToken = data.token || null;
        saveAuthToken(appData.authToken);
        setAuthUser(data.user || null);
        await loadChannels();
        setView("channels");
        setAuthFlowMode("email");
        return;
      }
      const displayName = authFlowName?.value?.trim() || "";
      if (!displayName) {
        if (authFlowError) authFlowError.textContent = "Enter your name to create an account.";
        return;
      }
      if (password.length < 8) {
        if (authFlowError) authFlowError.textContent = "Password must be at least 8 characters.";
        return;
      }
      const res = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password, displayName })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.ok) {
        if (authFlowError) authFlowError.textContent = data.error || "Registration failed.";
        return;
      }
      appData.authToken = data.token || null;
      saveAuthToken(appData.authToken);
      setAuthUser(data.user || null);
      await loadChannels();
      setView("channels");
      setAuthFlowMode("email");
    });

    accountLogoutBtn?.addEventListener("click", async () => {
      await fetch("/api/auth/logout", { method: "POST", headers: authHeaders() }).catch(() => {});
      appData.authToken = null;
      saveAuthToken(null);
      setAuthUser(null);
      setView("channels");
      await loadChannels();
    });

    accountManageChannels?.addEventListener("click", async () => {
      setView("channel-directory");
      await loadChannelDirectory();
    });

    accountClaimBtn?.addEventListener("click", async () => {
      if (!appData.authUser) {
        showToast("Please log in to claim a node.");
        setView("auth");
        return;
      }
      const publicNodeId = accountNodeId?.value?.trim() || "";
      if (!publicNodeId) {
        if (accountClaimStatus) accountClaimStatus.textContent = "Enter a public node ID.";
        return;
      }
      try {
        const res = await fetch("/api/user/nodes/claim", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ publicNodeId })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) throw new Error(data.error || "Claim failed.");
        appData.userNodes = data.nodes || [];
        renderAccountNodes();
        if (accountClaimStatus) accountClaimStatus.textContent = "Node claimed successfully.";
        if (accountNodeId) accountNodeId.value = "";
      } catch (err) {
        if (accountClaimStatus) accountClaimStatus.textContent = err?.message || String(err);
      }
    });

    changesClose?.addEventListener("click", () => changesModal?.classList.remove("open"));
    changesModal?.addEventListener("click", (e) => {
      if (e.target === changesModal) changesModal.classList.remove("open");
    });

    document.getElementById("observerRankSearch")?.addEventListener("input", () => {
      if (!appData.observerRank) return;
      renderObserverRank(appData.observerRank);
      renderObserverRankMap(appData.observerRank);
    });

    document.getElementById("nodeRankSearch")?.addEventListener("input", () => {
      if (!appData.nodeRank) return;
      renderNodeRank(appData.nodeRank);
    });

    function buildObserverEnvSnippet() {
      const ssid = (document.getElementById("observerWifi")?.value || "").trim();
      const pass = (document.getElementById("observerPass")?.value || "").trim();
      const name = (document.getElementById("observerName")?.value || "").trim();
      const lines = [
        `wifi.ssid ${ssid || "YOUR_WIFI_SSID"}`,
        `wifi.pass ${pass || "YOUR_WIFI_PASSWORD"}`,
        `observer.name ${name || "Observer"}`,
        "status"
      ];
      return lines.join("\n");
    }

    function copyText(text) {
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          alert("Config copied to clipboard.");
        }).catch(() => {
          alert(text);
        });
        return;
      }
      alert(text);
    }

    function setObserverStatus(text, isError) {
      const el = document.getElementById("observerStatus");
      if (!el) return;
      el.textContent = text;
      el.style.color = isError ? "#ff3b30" : "var(--muted)";
    }

    let observerAutoConfig = false;

    function concatUint8(chunks) {
      const total = chunks.reduce((sum, c) => sum + c.length, 0);
      const out = new Uint8Array(total);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.length;
      }
      return out;
    }

    async function readSerialOnce(port, timeoutMs) {
      if (!port.readable) return "";
      const reader = port.readable.getReader();
      const chunks = [];
      let timedOut = false;
      const timer = setTimeout(() => {
        timedOut = true;
        reader.cancel().catch(() => {});
      }, timeoutMs);
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) chunks.push(value);
        }
      } catch {
      } finally {
        clearTimeout(timer);
        reader.releaseLock();
      }
      if (!chunks.length) return timedOut ? "" : "";
      const bytes = concatUint8(chunks);
      return new TextDecoder().decode(bytes);
    }

      async function sendObserverConfig() {
        if (!navigator.serial) {
          setObserverStatus("WebSerial not available in this browser.", true);
          alert("WebSerial not available. Use Chrome/Edge over HTTPS.");
          return;
        }
        const ssidValue = (document.getElementById("observerWifi")?.value || "").trim();
        if (!ssidValue) {
          const msg = "Wi-Fi SSID is required before sending config.";
          setObserverStatus(msg, true);
          alert(msg);
          return;
        }
        const payloadLines = buildObserverEnvSnippet().split("\n").filter(Boolean);
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Select the observer serial port to send Wi-Fi config...";
          logEl.classList.add("active");
        }
        setObserverStatus("Waiting for serial port selection...", false);
        let port;
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          const writer = port.writable.getWriter();
          for (const line of payloadLines) {
            await writer.write(new TextEncoder().encode(line + "\r\n"));
            await new Promise((r) => setTimeout(r, 40));
          }
          writer.releaseLock();
          const reply = await readSerialOnce(port, 2000);
          if (reply && logEl) {
            logEl.textContent += "\nDevice replied:\n" + reply.trim();
          } else if (logEl) {
            logEl.textContent += "\nNo device reply detected. Check the serial port and power.";
          }
          await port.close();
          if (logEl) {
            logEl.textContent += "\nWi-Fi config sent. Device will reconnect using new settings.";
          }
        setObserverStatus("Wi-Fi config sent. Device will reconnect using new settings.", false);
        alert("Wi-Fi config sent.");
      } catch (err) {
        if (port && port.readable) {
          try { await port.close(); } catch {}
        }
        const msg = "Failed to send config: " + (err?.message || err);
        if (logEl) {
          logEl.textContent += "\n" + msg;
          logEl.classList.add("active");
        }
        setObserverStatus(msg, true);
        alert(msg);
      }
    }

    const observerSendBtn = document.getElementById("observerSendConfig");
    if (observerSendBtn) {
      observerSendBtn.addEventListener("click", () => {
        sendObserverConfig();
      });
    }

    function wireInstallLogging(button, verbose) {
      if (!button) return;
      const logEl = document.getElementById("installLog");
      const append = (msg) => {
        if (!logEl) return;
        logEl.classList.toggle("active", !!verbose);
        if (!verbose) return;
        const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logEl.textContent = (logEl.textContent || "").trim();
        logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + line;
        logEl.scrollTop = logEl.scrollHeight;
      };

      button.addEventListener("state-changed", (ev) => {
        const rawState = ev.detail?.state || "unknown";
        append(`state ${rawState}`);
        const state = String(rawState).toLowerCase();
        const isDone = ["finished", "installed", "done"].includes(state);
        if (observerAutoConfig && isDone) {
          observerAutoConfig = false;
          sendObserverConfig();
        }
      });
      button.addEventListener("log", (ev) => {
        append(ev.detail?.message || "log event");
      });
      button.addEventListener("error", (ev) => {
        append(`error ${ev.detail?.message || "unknown"}`);
      });
      button.addEventListener("click", () => {
        observerAutoConfig = true;
        if (logEl) {
          logEl.textContent = verbose ? "Verbose install log started..." : "Verbose install log ready.";
          logEl.classList.toggle("active", !!verbose);
        }
      });
    }

    wireInstallLogging(document.getElementById("observerFlash"), false);
    wireInstallLogging(document.getElementById("observerFlashVerbose"), true);

    const FLASH_BIN_URL = "/observer-merged-1.1.8.bin";
    const flashOpen = document.getElementById("observerFlashLink");
    const flashHide = document.getElementById("flashHide");
    const flashStart = document.getElementById("flashStart");
    const flashLog = document.getElementById("flashLog");
    const flashPanel = document.getElementById("flashPanel");

    function setFlashLog(msg) {
      flashLog.textContent = msg;
    }

    function appendFlashLog(line) {
      flashLog.textContent += `\n${line}`;
      flashLog.scrollTop = flashLog.scrollHeight;
    }

    function openFlashPanel() {
      flashPanel.classList.add("open");
      setFlashLog("Ready to flash.");
    }

    function closeFlashPanel() {
      flashPanel.classList.remove("open");
    }

    flashOpen?.addEventListener("click", openFlashPanel);
    flashHide?.addEventListener("click", closeFlashPanel);

    flashStart?.addEventListener("click", async () => {
      if (!navigator.serial) {
        setFlashLog("WebSerial is not supported in this browser. Use Chrome or Edge.");
        return;
      }

      flashStart.disabled = true;
      flashHide.disabled = true;
      setFlashLog("Downloading firmware...");

      try {
        const res = await fetch(FLASH_BIN_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`download failed (${res.status})`);
        const bin = new Uint8Array(await res.arrayBuffer());
        appendFlashLog(`Downloaded ${bin.byteLength} bytes.`);
        appendFlashLog("Preparing firmware...");
        appendFlashLog(`Firmware header: 0x${bin[0]?.toString(16).padStart(2, "0")}`);
        if (bin[0] === 0xe9) {
          const oldMode = bin[2];
          const oldFreqSize = bin[3];
          const newMode = 0x02; // DIO
          const newFreqSize = (oldFreqSize & 0xf0) | 0x00; // 40MHz
          if (oldMode !== newMode || oldFreqSize !== newFreqSize) {
            bin[2] = newMode;
            bin[3] = newFreqSize;
            appendFlashLog(`Patched header: mode 0x${oldMode.toString(16)}->0x${newMode.toString(16)}, freq 0x${oldFreqSize.toString(16)}->0x${newFreqSize.toString(16)}`);
          } else {
            appendFlashLog("Header already set for DIO/40MHz.");
          }
        }
        let binStr = "";
        for (let i = 0; i < bin.length; i++) {
          binStr += String.fromCharCode(bin[i]);
        }

        appendFlashLog("Requesting serial port...");
        const port = await navigator.serial.requestPort();
        appendFlashLog("Connecting to device...");

        let esptool;
        try {
          esptool = await import("/esp32.js");
        } catch (err) {
          try {
            esptool = await import("https://unpkg.com/esptool-js@0.5.4/bundle.js");
          } catch (err2) {
            esptool = await import("https://cdn.jsdelivr.net/npm/esptool-js@0.5.4/bundle.js");
          }
        }
        const transport = new esptool.Transport(port, true);
        const flashOptions = {
          transport,
          baudrate: 115200,
          romBaudrate: 115200,
          terminal: {
            clean: () => {},
            writeLine: appendFlashLog,
            write: (data) => appendFlashLog(String(data || "").trimEnd())
          },
          fileArray: [{ data: binStr, address: 0x0 }],
          flashSize: "keep",
          flashMode: "keep",
          flashFreq: "keep",
          compress: true
        };
        const loader = new esptool.ESPLoader(flashOptions);
        try {
          loader.hr = new esptool.HardReset(transport);
        } catch {}

        await loader.main();
        try {
          await loader.flashId?.();
        } catch {}
        try {
          if (typeof loader.chipName === "function") {
            appendFlashLog(`Chip: ${loader.chipName()}`);
          }
        } catch {}
        appendFlashLog("Erasing flash...");
        await loader.eraseFlash();
        appendFlashLog("Writing firmware...");

        await loader.writeFlash(flashOptions);

        appendFlashLog("Verifying header...");
        try {
          const verify = await loader.readFlash(0x0, 16);
          let ok = verify.length === 16;
          let mismatchAt = -1;
          for (let i = 0; i < 16 && ok; i++) {
            if (verify[i] !== bin[i]) {
              ok = false;
              mismatchAt = i;
            }
          }
          if (ok) {
            appendFlashLog("Header verify OK.");
          } else {
            const got = Array.from(verify).map((b) => b.toString(16).padStart(2, "0")).join("");
            const want = Array.from(bin.slice(0, 16)).map((b) => b.toString(16).padStart(2, "0")).join("");
            appendFlashLog(`Header verify mismatch at byte ${mismatchAt}: got 0x${got}, expected 0x${want}`);
          }
        } catch (err) {
          appendFlashLog(`Header verify failed: ${err?.message || err}`);
        }

        appendFlashLog("Flash complete. Rebooting...");
        try {
          await loader.after?.("hard_reset");
        } catch {}
        try {
          await transport.setRTS(true);
          await new Promise((resolve) => setTimeout(resolve, 100));
          await transport.setRTS(false);
        } catch {}
        await transport.disconnect();
        appendFlashLog("Done. You can now send Wi-Fi config.");
      } catch (err) {
        appendFlashLog(`Error: ${err?.message || err}`);
      } finally {
        flashStart.disabled = false;
        flashHide.disabled = false;
      }
    });

    const observerFlashBtn = document.getElementById("observerFlashBtn");
    const observerFlashVerboseBtn = document.getElementById("observerFlashVerboseBtn");
    const observerFlash = document.getElementById("observerFlash");
    const observerFlashVerbose = document.getElementById("observerFlashVerbose");

    if (observerFlashBtn && observerFlash) {
      observerFlashBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) logEl.classList.remove("active");
        observerFlash.click();
      });
    }

    if (observerFlashVerboseBtn && observerFlashVerbose) {
      observerFlashVerboseBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Verbose install log started...";
          logEl.classList.add("active");
        }
        observerFlashVerbose.click();
      });
    }

    const rangeTabs = document.getElementById("meshRangeTabs");
    if (rangeTabs) {
      rangeTabs.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-range]");
        if (!btn) return;
        rangeTabs.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        meshRangeDays = Number(btn.dataset.range || 7);
        if (!appData.meshScore) {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        } else {
          renderMeshScore(appData.meshScore, meshRangeDays);
        }
      });
    }

    function setServerStatus(ok) {
      const dot = document.getElementById("serverStatus");
      if (!dot) return;
      dot.classList.toggle("ok", !!ok);
    }

    const themeToggle = document.getElementById("themeToggle");
    const themeKey = "meshrank.theme";
    function applyTheme(theme) {
      const isDark = theme === "dark";
      document.body.classList.toggle("theme-dark", isDark);
      if (themeToggle) {
        themeToggle.setAttribute("aria-pressed", String(isDark));
        themeToggle.textContent = isDark ? "Light mode" : "Dark mode";
      }
    }
    const storedTheme = localStorage.getItem(themeKey);
    const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;
    applyTheme(storedTheme || (prefersDark ? "dark" : "light"));
    themeToggle?.addEventListener("click", () => {
      const nextTheme = document.body.classList.contains("theme-dark") ? "light" : "dark";
      localStorage.setItem(themeKey, nextTheme);
      applyTheme(nextTheme);
    });

    loadReadState();
    appData.channelHistoryLimit = loadChannelHistoryLimit();
    initChannelHistoryControl();
    initNodeSerialControls();
    initObserverCoveragePopup();
    const rankSearch = document.getElementById("rankSearch");
    const rankSearchHint = document.getElementById("rankSearchHint");
    function parseRankSearchInput(value = "") {
      const raw = String(value || "");
      const cleaned = raw.replace(/\[([^\]]*)$/, "");
      const codeMatch = raw.match(/\[(\d{2})\]/);
      const code = codeMatch ? codeMatch[1] : null;
      const text = cleaned.replace(codeMatch?.[0] || "", "").trim();
      return { text, code };
    }
    function updateRankSearchHint(code) {
      if (!rankSearchHint) return;
      rankSearchHint.textContent = code ? `Filtering by code [${code}]` : "";
    }
    if (rankSearch) {
      rankSearch.addEventListener("input", () => {
        const { text, code } = parseRankSearchInput(rankSearch.value);
        appData.rankFilter = text;
        appData.rankCodeFilter = code ? String(code).toUpperCase() : null;
        updateRankSearchHint(appData.rankCodeFilter);
        if (appData.rankData) {
          const payload = appData.rankPayload || { items: appData.rankData };
          renderRankWithOptions({ ...payload, items: appData.rankData }, { preserveView: true });
        }
      });
    }

    rankDebugOverlay = document.getElementById("rankDebugOverlay");

    const rankList = document.getElementById("rankList");
    if (rankList) {
      rankList.addEventListener("click", async (event) => {
        const btn = event.target.closest("[data-repeater-locate]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-locate") || "").trim().toUpperCase();
        if (!pub) return;
        const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
        if (!entry) return;
        openRepeaterLocationModal(entry);
      });
    }

    const showZeroHopPlaceholder = () => {
      showToast("Zero-hop neighbour stats are being refreshed; this view will return soon.");
    };
    if (rankList) {
      rankList.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-repeater-neighbors]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-neighbors") || "").trim().toUpperCase();
        if (!pub) {
          showZeroHopPlaceholder();
          return;
        }
        const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
        if (!entry) {
          showZeroHopPlaceholder();
          return;
        }
        openNeighborMapModal(entry);
      });
    }

    if (rankList) {
      rankList.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-repeater-pub]");
        if (!btn) return;
        event.preventDefault();
        event.stopPropagation();
        const pub = String(btn.getAttribute("data-repeater-pub") || "").trim().toUpperCase();
        if (!pub) return;
        window.prompt("Public key", pub);
      });
    }

    const rotmLeaderboard = document.getElementById("rotmLeaderboard");
    if (rotmLeaderboard) {
      rotmLeaderboard.addEventListener("click", (event) => {
        const row = event.target.closest("[data-rotm-node]");
        if (!row) return;
        event.preventDefault();
        event.stopPropagation();
        const nodeKey = row.getAttribute("data-rotm-node");
        if (!nodeKey) return;
        selectRotmNode(nodeKey);
        const node = (appData.rotmData?.leaderboard || []).find((n) => n.nodeKey === nodeKey) || null;
        renderRotmQsoLog(node);
        document.getElementById("rotmQsoModal")?.classList.add("open");
      });
    }

    const rotmQsoLog = document.getElementById("rotmQsoLog");
    if (rotmQsoLog) {
      rotmQsoLog.addEventListener("click", async (event) => {
        const row = event.target.closest("[data-qso-detail]");
        if (row && !event.target.closest(".rotm-qso-save")) {
          const detailTitle = document.getElementById("rotmQsoDetailTitle");
          const detailBody = document.getElementById("rotmQsoDetailBody");
          if (detailTitle) detailTitle.textContent = "QSO details";
          if (detailBody) {
            const date = row.getAttribute("data-qso-date") || "--";
            const repeater = row.getAttribute("data-qso-repeater") || "Unknown";
            const cq = row.getAttribute("data-qso-cq") || "--";
            const cqBody = row.getAttribute("data-qso-cq-body") || "";
            const response = row.getAttribute("data-qso-response") || "--";
            const responseBody = row.getAttribute("data-qso-response-body") || "";
            detailBody.innerHTML = `
              <div class="rotm-qso-msg"><strong>Date:</strong> ${date}</div>
              <div class="rotm-qso-msg"><strong>Repeater:</strong> ${repeater}</div>
              <div class="rotm-qso-msg"><strong>CQ:</strong> ${cq}</div>
              <div class="rotm-qso-msg">${cqBody}</div>
              <div class="rotm-qso-msg"><strong>Confirmed by:</strong> ${response}</div>
              <div class="rotm-qso-msg">${responseBody}</div>
            `;
          }
          rotmQsoDetailModal?.classList.add("open");
          return;
        }
        const btn = event.target.closest(".rotm-qso-save");
        if (!btn) return;
        if (!appData.authUser?.isAdmin) return;
        event.preventDefault();
        const wrap = btn.closest(".rotm-qso-override");
        const select = wrap?.querySelector(".rotm-qso-select");
        const cqId = Number(wrap?.getAttribute("data-cq-id"));
        const hash = String(wrap?.getAttribute("data-hash") || "").toUpperCase();
        const pub = String(select?.value || "").toUpperCase();
        if (!Number.isFinite(cqId) || !hash || !pub) return;
        try {
          await fetch("/api/rotm-override", {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ cqId, hash, pub })
          });
          await loadRotm();
        } catch {
          // ignore, UI will refresh on next poll
        }
      });
    }
    const rotmChannelSave = document.getElementById("rotmChannelSave");
    if (rotmChannelSave) {
      rotmChannelSave.addEventListener("click", async () => {
        const channelInput = document.getElementById("rotmChannelName");
        const secretInput = document.getElementById("rotmChannelSecret");
        const status = document.getElementById("rotmChannelStatus");
        const channel = channelInput?.value?.trim() || "";
        const secretHex = secretInput?.value?.trim() || "";
        if (!channel) {
          if (status) status.textContent = "Channel name is required.";
          return;
        }
        if (status) status.textContent = "Saving...";
        try {
          const res = await fetch("/api/rotm-config", {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ channel, secretHex })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) throw new Error(data.error || `HTTP ${res.status}`);
          if (status) status.textContent = `Saved: ${data.channel || channel}. Secret is stored until you update it.`;
          if (secretInput) secretInput.value = "";
          appData.rotmConfigLoaded = true;
          if (data.channel) appData.rotmChannelName = data.channel;
          await loadRotm();
        } catch (err) {
          if (status) status.textContent = `Save failed: ${err?.message || err}`;
        }
      });
    }

    document.addEventListener("click", async (event) => {
      const flagBtn = event.target.closest("[data-repeater-flag]");
      if (flagBtn) {
        event.preventDefault();
        event.stopPropagation();
        const pub = String(flagBtn.getAttribute("data-repeater-flag") || "").trim().toUpperCase();
        if (!pub) return;
        const confirmed = window.confirm("Flag this repeater as wrong location?\n\nIt will be removed from the map and reviewed over the next 24 hours.");
        if (!confirmed) return;
        try {
          const res = await fetch("/api/repeater-flag", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ pub, flagged: true })
          });
          const payload = await res.json().catch(() => ({}));
          if (!res.ok || !payload.ok) {
            throw new Error(payload.error || `HTTP ${res.status}`);
          }
          if (rankMap) rankMap.closePopup();
          hideFlaggedRepeater(pub);
          fetchRankSummary().then(renderRankSummary).catch(() => {});
          setTimeout(() => showToast("Hidden from the mapnew GPS will restore it when available."), 100);
        } catch (err) {
          alert("Unable to flag location: " + (err?.message || err));
        }
        return;
      }
      const correctBtn = event.target.closest("[data-repeater-correct]");
      if (!correctBtn) return;
      event.preventDefault();
      event.stopPropagation();
      const pub = String(correctBtn.getAttribute("data-repeater-correct") || "").trim().toUpperCase();
      if (!pub) return;
      const entry = (appData.rankData || []).find((r) => String(r.pub || "").toUpperCase() === pub);
      if (!entry) return;
      try {
        await fetch("/api/repeater-flag", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pub, flagged: true })
        });
        await loadRankDefault();
        fetchRankSummary().then(renderRankSummary).catch(() => {});
      } catch {}
      openRepeaterLocationModal(entry);
    });

    const rfSearch = document.getElementById("rfSearch");
    const rfTypeFilter = document.getElementById("rfTypeFilter");
    if (rfSearch) rfSearch.addEventListener("input", renderRfList);
    if (rfTypeFilter) rfTypeFilter.addEventListener("change", renderRfList);
    if (document.getElementById("rfList")) {
      document.getElementById("rfList").addEventListener("click", (event) => {
        const toggle = event.target.closest("[data-rf-toggle]");
        if (!toggle) return;
        event.preventDefault();
        event.stopPropagation();
        const key = toggle.getAttribute("data-rf-toggle");
        if (!key) return;
        const children = document.querySelectorAll(`.rf-row.rf-child[data-parent-key="${CSS.escape(key)}"]`);
        if (!children.length) return;
        const isHidden = children[0].classList.contains("is-hidden");
        children.forEach((child) => child.classList.toggle("is-hidden", !isHidden));
        toggle.textContent = isHidden ? "" : "+";
      });
    }

    window.addEventListener("resize", () => {
      if (observerMap) observerMap.invalidateSize();
      if (rankMap) rankMap.invalidateSize();
    });
  </script>
  <script async defer src="https://accounts.google.com/gsi/client"></script>
  <div id="shareLanding" class="share-landing">
    <div class="share-card">
      <div class="share-header">
        <div>
          <div class="share-title">Shared route path</div>
          <div class="share-subtitle" id="shareSubtitle">Valid for 24 hours</div>
        </div>
        <button class="share-close" id="shareCloseBtn" type="button" aria-label="Close shared route view"></button>
      </div>
      <div class="share-status" id="shareStatus">Loading shared route</div>
      <div class="share-error" id="shareError"></div>
      <div class="share-details">
        <div class="share-row">
          <span>Message key</span>
          <strong id="shareMessageKey"></strong>
        </div>
        <div class="share-row">
          <span>Channel</span>
          <strong id="shareChannel"></strong>
        </div>
        <div class="share-row">
          <span>Sender</span>
          <strong id="shareSender"></strong>
        </div>
        <div class="share-row">
          <span>Packets heard</span>
          <strong id="sharePackets">0</strong>
        </div>
        <div class="share-row">
          <span>Path depth</span>
          <strong id="shareDepth">0 hops</strong>
        </div>
      </div>
      <div class="share-path" id="sharePathList"></div>
      <div class="share-observers" id="shareObservers"></div>
      <div class="share-actions">
        <a href="/messages?channel=public" class="btn" id="shareViewMessagesBtn">View more messages</a>
      </div>
    </div>
  </div>
  <div id="rankExplainOverlay" class="rank-detail-overlay" onclick="closeRankExplain()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="rankExplainContent"></div>
    </div>
  </div>
  <div id="repeaterFlaggedOverlay" class="rank-detail-overlay" onclick="closeImplausibleList()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="repeaterFlaggedContent"></div>
    </div>
  </div>
  <div id="messageRouteOverlay" class="rank-detail-overlay" onclick="closeMessageRouteOverlay()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="messageRouteContent"></div>
    </div>
  </div>
  <div id="rankDetailOverlay" class="rank-detail-overlay" onclick="closeRankDetail()">
    <div class="rank-detail-card" onclick="event.stopPropagation()">
      <div id="rankDetailContent"></div>
    </div>
  </div>
  <div id="observerCoveragePopup" class="coverage-popup">
    <div class="coverage-card">
      <button class="coverage-close" type="button" data-coverage-close></button>
      <h3 id="coveragePopupTitle">Observer coverage information</h3>
      <p id="coveragePopupBody">Observer coverage details will appear here.</p>
      <div class="coverage-actions">
        <button class="btn" type="button" id="coverageBecomeBtn">Become an observer</button>
        <a class="btn btn-ghost" id="coverageEmailLink" href="mailto:stu.stoke@gmail.com">Email for Heltec V3</a>
      </div>
    </div>
  </div>
  <script>
    const updateCacheBadge = () => {
      const badge = document.getElementById("rankCacheBadge");
      const updatedAt = document.getElementById("rankUpdated")?.textContent;
      if (badge && updatedAt && updatedAt !== "--") {
        badge.style.display = "inline-block";
        badge.textContent = `Cached ${updatedAt}`;
      } else if (badge) {
        badge.style.display = "none";
      }
    };
    document.addEventListener("DOMContentLoaded", () => updateCacheBadge());
    const originalRenderRankSummary = window.renderRankSummary;
    window.renderRankSummary = function(summary) {
      if (typeof originalRenderRankSummary === "function") {
        originalRenderRankSummary(summary);
        updateCacheBadge();
      }
    };
  </script>
</body>
</html>
