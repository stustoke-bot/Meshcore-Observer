<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <meta http-equiv="cache-control" content="no-store, no-cache, must-revalidate, max-age=0"/>
  <meta http-equiv="pragma" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <title>MeshRank</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --ink: #0a0b0e;
      --paper: #f2f2f7;
      --panel: #ffffff;
      --line: rgba(60, 60, 67, 0.12);
      --blue: #007aff;
      --blue-dark: #0a60d1;
      --green: #34c759;
      --green-dark: #248a3d;
      --muted: rgba(60, 60, 67, 0.6);
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }
    body.theme-dark {
      --ink: #e8eef9;
      --paper: #0b0f15;
      --panel: #131a24;
      --line: rgba(231, 238, 251, 0.08);
      --blue: #63a2ff;
      --blue-dark: #2f6bd6;
      --green: #48d06a;
      --green-dark: #2aa24a;
      --muted: rgba(231, 238, 251, 0.62);
      --shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", system-ui, sans-serif;
      background:
        radial-gradient(1000px 520px at 85% -10%, rgba(0, 122, 255, 0.14) 0%, rgba(0, 122, 255, 0) 60%),
        radial-gradient(900px 520px at -10% 15%, rgba(52, 199, 89, 0.12) 0%, rgba(52, 199, 89, 0) 60%),
        var(--paper);
      color: var(--ink);
      height: 100vh;
      overflow: hidden;
    }
    body.theme-dark {
      background:
        radial-gradient(900px 520px at 85% -10%, rgba(99, 162, 255, 0.18) 0%, rgba(11, 15, 21, 0) 60%),
        radial-gradient(800px 520px at -10% 20%, rgba(72, 208, 106, 0.16) 0%, rgba(11, 15, 21, 0) 60%),
        var(--paper);
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 280px 1fr 420px;
      gap: 16px;
      padding: 16px;
      height: 100vh;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .topbar {
      grid-column: 1 / -1;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      padding: 2px 12px;
      gap: 12px;
      min-height: 48px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      flex: 0 0 auto;
    }

    .brand-logo {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: block;
      overflow: hidden;
      border: none;
    }

    .brand-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display: block;
      min-width: 0;
    }

    .brand-text {
      display: grid;
      gap: 2px;
      line-height: 1.1;
    }

    .brand-text strong {
      font-size: 16px;
    }

    .brand-text span {
      font-size: 12px;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      background: #ff3b30;
      box-shadow: 0 0 0 4px rgba(255, 59, 48, 0.15);
    }

    .status-dot.ok {
      background: #34c759;
      box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.15);
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-weight: 600;
      color: var(--muted);
      margin-left: auto;
    }

    .nav a {
      color: inherit;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .nav a.active {
      color: var(--ink);
      background: rgba(0, 122, 255, 0.12);
    }
    .menu-toggle {
      display: none;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 10px;
      padding: 0;
      width: 38px;
      height: 34px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }
    .menu-toggle .burger {
      width: 18px;
      height: 12px;
      display: inline-flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .menu-toggle .burger span {
      display: block;
      height: 2px;
      border-radius: 999px;
      background: var(--ink);
    }
    .menu-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 900;
    }
    .mobile-menu {
      display: none;
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 12px;
      width: min(86vw, 320px);
      z-index: 950;
      border: 1px solid var(--line);
      border-radius: 12px 0 0 12px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 10px;
      gap: 6px;
      flex-direction: column;
      align-items: stretch;
      transform: translateX(110%);
      transition: transform 0.2s ease;
      overflow: auto;
    }
    .mobile-menu a {
      display: block;
      padding: 8px 10px;
      border-radius: 10px;
      text-decoration: none;
      color: var(--ink);
      font-weight: 600;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-menu a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .mobile-nav {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
    }
    .mobile-nav a {
      color: var(--ink);
      text-decoration: none;
      font-weight: 600;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0, 122, 255, 0.08);
    }
    .mobile-nav a.active {
      background: rgba(0, 122, 255, 0.18);
    }
    .theme-toggle {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .theme-toggle:hover { color: var(--blue); border-color: var(--blue); }
    .theme-toggle:focus-visible { outline: 2px solid var(--blue); outline-offset: 2px; }

    .sidebar {
      padding: 14px 12px;
      gap: 10px;
    }

    .title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .content .title {
      position: sticky;
      top: 0;
      z-index: 4;
      background: var(--panel);
    }
    .channel-title {
      justify-content: space-between;
      gap: 8px;
    }
    .channel-title-label {
      font-weight: 700;
    }

    .title.column {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }

    .chip {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      font-weight: 600;
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(0, 122, 255, 0.18);
    }

    .channel {
      display: grid;
      grid-template-columns: 44px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
    }

    .channel.active {
      background: #e8f0ff;
      border-color: rgba(11, 95, 255, 0.2);
    }
    body.theme-dark .channel.active {
      background: rgba(99, 162, 255, 0.16);
      border-color: rgba(99, 162, 255, 0.4);
    }

    .channel.unread .name {
      font-weight: 800;
    }

    .badge-bubble {
      min-width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #007aff;
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
    }

    .channel .name {
      font-weight: 700;
    }

    .channel .snippet {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .content {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .channel-selector {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }
    @media (min-width: 861px) {
      .channel-selector { display: none; }
    }
    @media (max-width: 860px) {
      .channel-title-label { display: none; }
    }
    .channel-selector .badge-bubble {
      min-width: 18px;
      height: 18px;
      border-radius: 999px;
      background: var(--blue);
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
    }
    .channels-rail {
      display: none;
      position: fixed;
      left: 6px;
      top: 120px;
      z-index: 9;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      gap: 6px;
      align-items: center;
      font-weight: 700;
      cursor: pointer;
    }
    .channels-rail .badge-bubble { display: inline-flex; }

    .messages {
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow: auto;
    }

    .message {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      animation: slideIn 400ms ease-out;
      min-width: 0;
    }

    .message .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .bubble {
      padding: 10px 14px;
      border-radius: 14px;
      max-width: 520px;
      color: #fff;
      font-weight: 500;
      line-height: 1.35;
      box-shadow: 0 10px 24px rgba(10, 11, 14, 0.16);
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .bubble.mesh {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
    }

    .bubble.observer {
      background: linear-gradient(135deg, var(--green), var(--green-dark));
    }

    .bubble.mixed {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
      outline: 2px solid var(--green);
    }

    .msg-footer {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .observer-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 200, 83, 0.35);
      background: rgba(0, 200, 83, 0.12);
      color: #00a849;
      font-size: 11px;
      font-weight: 700;
    }
    .repeater-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0, 122, 255, 0.35);
      background: rgba(0, 122, 255, 0.12);
      color: #007aff;
      font-size: 11px;
      font-weight: 700;
    }

    .analyze {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
    }

    .analyze:hover { text-decoration: underline; }

    .analysis {
      display: grid;
      grid-template-rows: 240px 1fr;
      min-height: 0;
    }
    .route-close {
      display: none;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--muted);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .route-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      z-index: 9;
    }

    .rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rank-body {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rank-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
    }

    .summary-card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #ffffff;
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .summary-card strong {
      font-size: 16px;
      color: var(--ink);
    }

    .rank-map {
      border-radius: 16px;
      border: 1px solid var(--line);
      overflow: hidden;
      min-height: 360px;
    }

    #rankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    #observerRankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    .rank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      height: 100%;
    }

    .rank-search {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
      outline: none;
      box-shadow: 0 6px 16px rgba(10, 11, 14, 0.06);
      margin-bottom: 6px;
    }

    .rank-scroll {
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      flex: 1;
    }

    .rank-search::placeholder {
      color: rgba(60, 60, 67, 0.45);
    }

    .rank-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
      background: #fafafa;
    }


    .rank-item.hidden {
      opacity: 0.45;
      filter: grayscale(0.4);
    }

    .rank-item.focused {
      border-color: rgba(0, 122, 255, 0.4);
      background: rgba(0, 122, 255, 0.1);
      box-shadow: 0 10px 24px rgba(0, 122, 255, 0.18);
    }

    .rank-item .row {
      font-size: 12px;
      color: var(--muted);
    }

    .rank-item .score {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .rank-dot {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: #fff;
    }

    .meshscore-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-body {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rf-table {
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .rf-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #ffffff;
    }

    .rf-input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      font-family: "IBM Plex Mono", monospace;
      background: var(--panel);
      color: var(--ink);
    }

    .rf-list {
      overflow: auto;
      min-height: 0;
    }

    .rf-row {
      display: grid;
      grid-template-columns: 90px 110px 90px 140px minmax(160px, 2fr) 140px 60px 60px 60px 60px 70px;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 12px;
      cursor: pointer;
      align-items: center;
    }

    .rf-row:hover {
      background: #f7f7f7;
    }

    .rf-row.rf-header {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f4f6fb;
      font-weight: 700;
      color: #5b6b84;
      cursor: default;
    }

    .rf-type {
      font-weight: 700;
      color: #fff;
      border-radius: 8px;
      padding: 2px 6px;
      display: inline-flex;
      justify-content: center;
      background: #007aff;
      font-size: 11px;
    }

    .rf-detail {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      overflow: auto;
      min-height: 0;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .rf-summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
      font-size: 12px;
      color: var(--muted);
    }

    .rf-summary strong {
      display: block;
      color: var(--ink);
      font-size: 14px;
      margin-top: 2px;
    }

    .rf-hex {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      background: #f7f7f7;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      word-break: break-all;
    }

    .rf-kv {
      font-size: 12px;
      color: var(--muted);
      display: grid;
      gap: 4px;
    }

    .meshscore-body {
      padding: 16px;
      display: grid;
      gap: 16px;
      overflow: auto;
    }

    .meshscore-hero {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px 16px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .meshscore-cards {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .meshscore-chart {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .range-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .range-tabs button {
      border: 1px solid var(--line);
      background: #f7f7f7;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .range-tabs button.active {
      background: rgba(0, 122, 255, 0.12);
      color: var(--blue);
    }

    .meshscore-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    #routeMap {
      height: 100%;
      width: 100%;
      background: repeating-linear-gradient(
        135deg,
        rgba(10, 11, 14, 0.04),
        rgba(10, 11, 14, 0.04) 14px,
        transparent 14px,
        transparent 28px
      );
    }

    .analysis-body {
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }

    .modal.open {
      display: flex;
    }

    .modal-card {
      width: min(420px, 100%);
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 18px;
      display: grid;
      gap: 12px;
    }

    .route-modal-card {
      width: min(760px, 100%);
    }

    .flash-panel {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .flash-panel.open {
      display: flex;
    }

    .flash-log {
      background: #0c111b;
      color: #d2d9e6;
      border-radius: 12px;
      padding: 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      min-height: 180px;
      max-height: 280px;
      overflow: auto;
      white-space: pre-wrap;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .flash-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .flash-row strong {
      color: var(--ink);
    }

    .route-override-list {
      display: grid;
      gap: 10px;
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
    }

    .route-override-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 8px;
    }

    .route-override-label {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .route-override-label strong {
      font-size: 13px;
      color: var(--ink);
    }

    .route-override-select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
    }

    .route-override-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .route-override-empty {
      font-size: 13px;
      color: var(--muted);
      padding: 12px 0;
    }

    .field {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .field input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 13px;
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel {
      background: var(--panel);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .route-override-row {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .range-tabs button {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
    }
    body.theme-dark .route-override-select,
    body.theme-dark .rf-input {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-controls,
    body.theme-dark .rf-detail,
    body.theme-dark .rf-summary,
    body.theme-dark .rf-hex,
    body.theme-dark .meshscore-hero,
    body.theme-dark .meshscore-chart,
    body.theme-dark .flash-panel,
    body.theme-dark .route-override-row,
    body.theme-dark .route-override-select,
    body.theme-dark .field input,
    body.theme-dark .observer-grid input,
    body.theme-dark .observer-grid select,
    body.theme-dark .rank-body,
    body.theme-dark .rank-map,
    body.theme-dark .observer-rank-body,
    body.theme-dark .observer-rank-map,
    body.theme-dark .observer-map,
    body.theme-dark .analysis-body,
    body.theme-dark .meshscore-body,
    body.theme-dark .rank-body,
    body.theme-dark .rf-body,
    body.theme-dark .rf-table,
    body.theme-dark .rf-row,
    body.theme-dark .route-override-list,
    body.theme-dark .modal-card {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rf-row.rf-header {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }
    body.theme-dark .rf-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .range-tabs button.active {
      background: rgba(99, 162, 255, 0.16);
      color: var(--blue);
    }
    body.theme-dark .modal {
      background: rgba(0, 0, 0, 0.6);
    }
    body.theme-dark #meshChart {
      background: rgba(255, 255, 255, 0.04) !important;
    }
    body.theme-dark .rank-summary {
      background: rgba(255, 255, 255, 0.03);
    }
    body.theme-dark .summary-card {
      background: var(--panel);
      color: var(--muted);
    }
    body.theme-dark .rank-search {
      background: var(--panel);
      color: var(--ink);
      box-shadow: none;
    }
    body.theme-dark .rank-item {
      background: rgba(255, 255, 255, 0.04);
    }
    body.theme-dark .rank-summary,
    body.theme-dark .summary-card,
    body.theme-dark .rank-search,
    body.theme-dark .rank-item {
      background: var(--panel);
      color: var(--ink);
    }
    body.theme-dark .rank-item .row,
    body.theme-dark .rank-search::placeholder {
      color: var(--muted);
    }
    body.theme-dark .summary-card,
    body.theme-dark .observer-card,
    body.theme-dark .why-card {
      background: var(--panel) !important;
      color: var(--ink);
      border-color: var(--line);
    }
    body.theme-dark .summary-card strong,
    body.theme-dark .observer-card strong,
    body.theme-dark .why-card h3 {
      color: var(--ink);
    }
    body.theme-dark .badge,
    body.theme-dark .chip,
    body.theme-dark .list-item {
      background: rgba(255, 255, 255, 0.04) !important;
      color: var(--ink);
      border-color: var(--line);
    }
    body.theme-dark .badge.badge-green { color: #7bdc98; }
    body.theme-dark .badge.badge-blue { color: #8bb6ff; }
    body.theme-dark .badge.badge-amber { color: #f2c88b; }
    body.theme-dark .badge.badge-purple { color: #b5a9ff; }
    body.theme-dark .badge.badge-gray { color: #c7c7cc; }
    body.theme-dark .observer-step {
      background: rgba(255, 255, 255, 0.04);
      color: var(--ink);
      border-color: var(--line);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    body.view-channels .rank-panel,
    body.view-channels .meshscore-panel { display: none; }
    body.view-channels .sidebar-panel,
    body.view-channels .content,
    body.view-channels .analysis-panel { display: flex; }

    body.view-rank .sidebar-panel,
    body.view-rank .content,
    body.view-rank .analysis-panel,
    body.view-rank .meshscore-panel { display: none; }
    body.view-rank .rank-panel { display: flex; }

    body.view-meshscore .sidebar-panel,
    body.view-meshscore .content,
    body.view-meshscore .analysis-panel,
    body.view-meshscore .rank-panel { display: none; }
    body.view-meshscore .meshscore-panel { display: flex; }

    body.view-rf .sidebar-panel,
    body.view-rf .content,
    body.view-rf .analysis-panel,
    body.view-rf .rank-panel,
    body.view-rf .meshscore-panel { display: none; }
    body.view-rf .rf-panel { display: flex; }

    body.view-observer .sidebar-panel,
    body.view-observer .content,
    body.view-observer .analysis-panel,
    body.view-observer .rank-panel,
    body.view-observer .meshscore-panel,
    body.view-observer .rf-panel,
    body.view-observer .observer-rank-panel,
    body.view-observer .repeater-panel { display: none; }
    body.view-observer .observer-panel { display: flex; }
    body.view-why .sidebar-panel,
    body.view-why .content,
    body.view-why .analysis-panel,
    body.view-why .rank-panel,
    body.view-why .meshscore-panel,
    body.view-why .rf-panel,
    body.view-why .observer-panel,
    body.view-why .observer-rank-panel,
    body.view-why .repeater-panel { display: none; }
    body.view-why .why-panel { display: flex; }

    body.view-observer-rank .sidebar-panel,
    body.view-observer-rank .content,
    body.view-observer-rank .analysis-panel,
    body.view-observer-rank .rank-panel,
    body.view-observer-rank .meshscore-panel,
    body.view-observer-rank .rf-panel,
    body.view-observer-rank .observer-panel,
    body.view-observer-rank .repeater-panel { display: none; }
    body.view-observer-rank .observer-rank-panel { display: flex; }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .badge {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-weight: 600;
      color: var(--ink);
      background: #f7f7f7;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .badge.badge-green { background: rgba(52, 199, 89, 0.16); border-color: rgba(52, 199, 89, 0.28); color: #1b6b35; }
    .badge.badge-blue { background: rgba(0, 122, 255, 0.16); border-color: rgba(0, 122, 255, 0.28); color: #0a60d1; }
    .badge.badge-amber { background: rgba(255, 149, 0, 0.18); border-color: rgba(255, 149, 0, 0.28); color: #9a5b00; }
    .badge.badge-purple { background: rgba(88, 86, 214, 0.18); border-color: rgba(88, 86, 214, 0.28); color: #3b39a5; }
    .badge.badge-gray { background: rgba(142, 142, 147, 0.18); border-color: rgba(142, 142, 147, 0.28); color: #4a4a4f; }
    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .list-item {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #fafafa;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .channel-remove {
      border: 0;
      background: transparent;
      color: #ff3b30;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .slider {
      width: 100%;
    }

    .observer-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }
    .observer-location-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .observer-location-modal.open { display: flex; }
    .observer-location-card {
      width: min(92vw, 560px);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      padding: 14px;
    }
    .observer-location-map {
      height: 260px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--line);
    }
    .observer-location-meta {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .observer-location-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .observer-location-button {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 11px;
    }

    .observer-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .why-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .why-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .why-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 18px;
      background: #ffffff;
      display: grid;
      gap: 14px;
      align-content: start;
    }

    .why-card h3 {
      margin: 0;
      font-size: 16px;
    }

    .why-card p {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--ink);
    }

    .faq-item strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .faq-item p {
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }

    .observer-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .observer-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px 14px;
      background: #ffffff;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .observer-right {
      display: grid;
      gap: 16px;
      align-content: start;
    }

    .observer-log {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .observer-steps {
      display: grid;
      gap: 8px;
    }

    .observer-step {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 4px;
    }

    .observer-step strong {
      font-size: 13px;
    }

    .observer-grid {
      display: grid;
      gap: 8px;
    }

    .observer-grid label {
      font-size: 12px;
      color: var(--muted);
    }

    .observer-grid input,
    .observer-grid select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
    }

    .observer-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .observer-map {
      width: 100%;
      height: 360px;
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }

    .observer-map .leaflet-container {
      width: 100%;
      height: 100%;
    }

    .observer-legend {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .observer-legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .observer-legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #34c759;
    }

    .observer-legend i.warn { background: #ff9500; }
    .observer-legend i.bad { background: #ff3b30; }

    .observer-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .link-btn {
      border: 0;
      background: transparent;
      color: var(--blue-dark);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .install-log {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #0b1120;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .install-log.active {
      display: block;
    }

    @keyframes slideIn {
      from { transform: translateY(8px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @media (max-width: 1200px) {
      .app { grid-template-columns: 240px 1fr; }
      .analysis-panel { display: none; }
    }

    @media (max-width: 860px) {
      body { height: 100vh; overflow: hidden; }
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height: 100vh;
        padding: 8px;
      }
      .topbar {
        gap: 6px;
        padding: 6px 8px;
        min-height: 40px;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      .brand-logo { width: 32px; height: 32px; }
      .brand-text span { display: none; }
      .nav { display: none; }
      .menu-toggle { display: inline-flex; }
      .theme-toggle { margin-left: auto; }
      .menu-toggle { margin-left: 6px; }
      .nav a[data-view="observer"] { display: none; }
      .sidebar-panel {
        display: flex;
        position: fixed;
        top: 52px;
        left: 8px;
        bottom: 8px;
        width: min(86vw, 360px);
        z-index: 960;
        transform: translateX(-110%);
        transition: transform 0.2s ease;
      }
      body.view-channels.menu-open-left .sidebar-panel { transform: translateX(0); }
      body.menu-open-left .menu-backdrop,
      body.menu-open-right .menu-backdrop { display: block; }
      body.menu-open-right .mobile-menu { display: flex; transform: translateX(0); }
      .mobile-nav { display: flex; }
      .sidebar { padding: 8px; gap: 8px; }
      .channel { padding: 8px; grid-template-columns: 36px 1fr auto; gap: 8px; }
      .channel .snippet { font-size: 11px; }
      .panel { min-height: 0; }
      .content { min-height: 0; height: 100%; padding-bottom: env(safe-area-inset-bottom); }
      .channel-selector { display: inline-flex; }
      body.view-channels .channels-rail { display: inline-flex; }
      .messages {
        padding: 10px 12px;
        gap: 10px;
        flex: 1;
        overflow: auto;
        padding-bottom: calc(120px + env(safe-area-inset-bottom));
        scroll-padding-bottom: calc(120px + env(safe-area-inset-bottom));
        overflow-x: hidden;
      }
      .message { grid-template-columns: 36px 1fr; gap: 10px; min-width: 0; }
      .avatar { width: 32px; height: 32px; font-size: 12px; }
      .bubble { padding: 8px 12px; border-radius: 12px; max-width: 85%; }
      .message .meta { font-size: 11px; }
      .msg-footer { font-size: 11px; gap: 8px; }
      .analysis-panel {
        position: fixed;
        left: 8px;
        right: 8px;
        bottom: max(8px, env(safe-area-inset-bottom));
        height: 60vh;
        max-width: calc(100vw - 16px);
        z-index: 10;
        display: none;
      }
      .analysis-panel .title {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .analysis-panel .title .route-close {
        margin-left: auto;
      }
      body.view-channels .analysis-panel { display: none; }
      body.route-open.view-channels .analysis-panel { display: flex; }
      body.route-open .route-backdrop { display: block; }
      .analysis { grid-template-rows: 1fr auto; }
      #routeMap { min-height: 200px; }
      .route-close { display: inline-flex; }
      .rank-body { grid-template-columns: 1fr; }
      .rank-summary { padding: 8px 10px; gap: 8px; }
      .summary-card { padding: 8px 10px; }
      .summary-card strong { font-size: 14px; }
      .rank-body { height: auto; }
      .rank-map { min-height: 200px; }
      #rankMap { min-height: 200px; }
      #observerRankMap { min-height: 200px; }
      .rf-body { grid-template-columns: 1fr; }
      .rf-table { overflow-x: auto; }
      body.view-rf .rf-row { min-width: 0; grid-template-columns: 70px 70px 1fr 70px 60px 60px; }
      body.view-rf .rf-row > div:nth-child(3),
      body.view-rf .rf-row > div:nth-child(4),
      body.view-rf .rf-row > div:nth-child(5),
      body.view-rf .rf-row > div:nth-child(10),
      body.view-rf .rf-row > div:nth-child(11),
      body.view-rf .rf-row > div:nth-child(12) { display: none; }
      .observer-body { grid-template-columns: 1fr; }
      .observer-map { height: 260px; }
      .observer-rank-body { grid-template-columns: 1fr; }
      .observer-rank-map { height: 220px; min-height: 220px; }
      #observerRankMap { height: 100%; min-height: 0; }
      .why-body { grid-template-columns: 1fr; }
      .meshscore-panel { min-height: 0; overflow: hidden; }
      .meshscore-body { min-height: 0; height: 100%; overflow: auto; }
      body.view-rank .rank-panel,
      body.view-observer-rank .observer-rank-panel { overflow: auto; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
        <div class="brand">
          <div class="brand-logo">
            <img src="/meshrank.png?v=1.1.2" alt="MeshRank logo"/>
          </div>
          <div class="brand-text">
            <strong>MeshRank.net</strong>
            <span>by G5AIL</span>
          </div>
        </div>
      <nav class="nav">
        <a href="#" class="active" data-view="channels">Channels</a>
        <a href="#" data-view="rank">Repeater Rank</a>
        <a href="#" data-view="meshscore">MeshRank</a>
        <a href="#" data-view="observer-rank">Observer Rank</a>
        <a href="#" data-view="rf">MeshFlow</a>
        <a href="#" data-view="why">Why MeshRank?</a>
        <a href="#" data-view="observer">Become an Observer</a>
      </nav>
      <button class="theme-toggle" id="themeToggle" type="button" aria-pressed="false">Dark mode</button>
      <button class="menu-toggle" id="menuToggle" type="button" aria-label="Open menu">
        <span class="burger" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
        </span>
      </button>
    </header>
    <div class="menu-backdrop" id="menuBackdrop"></div>
    <div class="mobile-menu" id="mobileMenu">
      <a href="#" class="active" data-view="channels">Channels</a>
      <a href="#" data-view="rank">Repeater Rank</a>
      <a href="#" data-view="meshscore">MeshRank</a>
      <a href="#" data-view="observer-rank">Observer Rank</a>
      <a href="#" data-view="rf">MeshFlow</a>
      <a href="#" data-view="why">Why MeshRank?</a>
      <a href="#" data-view="observer">Become an Observer</a>
    </div>

    <section class="panel sidebar-panel">
      <div class="title column">
        <span>Channels <span class="chip">UK Mesh</span></span>
        <button class="btn" id="addChannelBtn">Add Channel</button>
      </div>
      <div class="sidebar">
        <div id="channels"></div>
      </div>
    </section>

    <section class="panel content">
      <div class="title channel-title">
        <button class="channel-selector" type="button" data-channels-toggle>
          <span>Other channels</span>
          <span class="badge-bubble channels-unread">0</span>
        </button>
        <span class="channel-title-label">Other channels</span>
        <button class="channel-selector" id="channelsTab" type="button" data-channels-toggle>
          <span id="activeChannel">#public</span>
        </button>
      </div>
      <div class="messages" id="messages"></div>
    </section>

    <div class="route-backdrop" id="routeBackdrop"></div>
    <section class="panel analysis-panel">
      <div class="title">Route Path <span class="chip" id="routeKey">none</span><button class="route-close" id="routeClose" type="button">Close</button></div>
      <div class="analysis">
        <div id="routeMap"></div>
        <div class="analysis-body">
          <div class="row"><span>Message key</span><span id="routeMessage">-</span></div>
          <div class="row"><span>Source</span><span id="routeSource">-</span></div>
          <div class="row"><span>Confidence</span><span id="routeConfidence">-</span></div>
          <div class="row"><span>Path depth</span><span id="routeDepth">-</span></div>

          <div class="row"><span>Packets heard</span><span class="badge" id="routeCount">0</span></div>
          <div class="list" id="routeList"></div>
          <div style="display:flex;align-items:center;gap:8px;">
            <button class="link-btn" id="routeOverrideBtn" type="button" onclick="window.openRouteOverride && window.openRouteOverride()">Route path wrong?</button>
            <span style="font-size:12px;color:var(--muted);">Suggest a correction for a 2-digit code.</span>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rank-panel">
      <div class="title">Repeater Rank <span class="chip" id="rankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total repeaters</div>
          <strong id="rankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="rankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>MeshRank today</div>
          <strong id="rankMeshToday">0</strong>
          <div style="font-size:11px;color:var(--muted);">Yesterday: <span id="rankMeshYesterday">0</span></div>
        </div>
      </div>
      <div class="rank-body">
        <div class="rank-map">
          <div id="rankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="rankSearch" type="text" placeholder="Search repeaters"/>
          <div class="rank-scroll" id="rankScroll">
            <div id="rankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel meshscore-panel">
      <div class="title">MeshRank <span class="chip" id="meshUpdated">--</span></div>
      <div class="meshscore-body">
        <div class="meshscore-hero">
          <div style="font-weight:700;">MeshRank tracks network health using active repeaters, message volume, and repeat reliability.</div>
          <div style="font-size:12px;color:var(--muted);">Scores update from live RF logs and decoded mesh traffic. Higher scores mean wider coverage, better repeat density, and more reliable delivery.</div>
        </div>
        <div class="meshscore-cards">
          <div class="summary-card">
            <div>MeshRank today</div>
            <strong id="meshToday">0</strong>
          </div>
          <div class="summary-card">
            <div>MeshRank yesterday</div>
            <strong id="meshYesterday">0</strong>
          </div>
          <div class="summary-card">
            <div>Change</div>
            <strong id="meshDelta">0</strong>
          </div>
          <div class="summary-card">
            <div>Messages (24h)</div>
            <strong id="meshMessages">0</strong>
          </div>
        </div>
        <div class="meshscore-chart">
          <div class="range-tabs" id="meshRangeTabs">
            <button data-range="7" class="active">7d</button>
            <button data-range="30">30d</button>
            <button data-range="90">90d</button>
            <button data-range="365">1y</button>
          </div>
          <svg id="meshChart" viewBox="0 0 600 220" width="100%" height="220" style="background:var(--panel);border-radius:12px;">
            <polyline id="meshLine" fill="none" stroke="#007aff" stroke-width="3" points=""></polyline>
            <polyline id="meshArea" fill="rgba(0,122,255,0.12)" stroke="none" points=""></polyline>
          </svg>
        </div>
        <div class="meshscore-grid">
          <div class="summary-card">
            <div>Total devices</div>
            <strong id="meshDevices">0</strong>
          </div>
          <div class="summary-card">
            <div>Repeaters active</div>
            <strong id="meshRepeaters">0</strong>
          </div>
          <div class="summary-card">
            <div>Room servers</div>
            <strong id="meshRooms">0</strong>
          </div>
          <div class="summary-card">
            <div>Chat nodes</div>
            <strong id="meshChat">0</strong>
          </div>
          <div class="summary-card">
            <div>Companion nodes</div>
            <strong id="meshCompanions">0</strong>
          </div>
          <div class="summary-card">
            <div>Mesh msgs today</div>
            <strong id="meshMsgsToday">0</strong>
          </div>
          <div class="summary-card">
            <div>Observer msgs today</div>
            <strong id="meshMsgsObserver">0</strong>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rf-panel">
      <div class="title">MeshFlow <span class="chip" id="rfCount">0 packets</span></div>
      <div class="rf-body">
        <div class="rf-table">
          <div class="rf-controls">
            <input class="rf-input" id="rfSearch" type="text" placeholder="Search hash or hex"/>
            <select class="rf-input" id="rfTypeFilter">
              <option value="">All types</option>
              <option value="Advert">Advert</option>
              <option value="GroupText">GroupText</option>
              <option value="Request">Request</option>
              <option value="Response">Response</option>
              <option value="Path">Path</option>
              <option value="Ack">Ack</option>
            </select>
            <span class="chip" id="rfUpdated">--</span>
          </div>
          <div class="rf-summary">
            <div>Total packets<strong id="rfTotal">0</strong></div>
            <div>CRC ok<strong id="rfOk">0</strong></div>
            <div>CRC bad<strong id="rfBad">0</strong></div>
            <div>Top type<strong id="rfTopType">--</strong></div>
          </div>
          <div class="rf-list" id="rfList"></div>
        </div>
        <div class="rf-detail" id="rfDetail">
          <div class="rf-kv">Select a packet to inspect its payload.</div>
        </div>
      </div>
    </section>

    <section class="panel observer-panel">
      <div class="title">Become an Observer <span class="chip">Quick setup</span></div>
      <div class="observer-body">
          <div class="observer-card">
            <div style="font-weight:700;">Bring your observer online</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.5;">
              Observer Nodes listen silently and relay RF traffic to MeshRank without stressing repeaters.
              Place it where Wi-Fi and RF are strong. Firmware is Heltec V3 only.
            </div>
            <div class="observer-steps">
              <div class="observer-step"><strong>1</strong> Plug in your Heltec V3 in DFU mode.</div>
              <div class="observer-step">
                <strong>2</strong> Flash the firmware via MeshCore flasher.
                <div class="observer-actions">
                  <button class="btn" id="observerFlashLink" type="button">Open MeshRank Flasher</button>
                </div>
                <div style="font-size:12px;color:var(--muted);">The in-page flasher erases and writes the full merged firmware image, then reboots the device.</div>
                <div class="flash-panel" id="flashPanel">
                  <div style="font-weight:700;">MeshRank Observer Flasher</div>
                  <div style="font-size:12px;color:var(--muted);line-height:1.5;">
                    This flashes the full merged image for Heltec V3 (ESP32-S3). It will erase the device first.
                  </div>
                  <div class="flash-row">
                    <div>Firmware</div>
                    <strong id="flashVersion">observer-merged-1.1.8.bin</strong>
                  </div>
                  <div class="flash-row">
                    <div>Offset</div>
                    <strong>0x0 (full image)</strong>
                  </div>
                  <div class="flash-log" id="flashLog">Ready to flash.</div>
                  <div class="observer-actions">
                    <button class="btn" id="flashStart" type="button">Start flash</button>
                    <button class="btn" id="flashHide" type="button">Hide</button>
                  </div>
                </div>
              </div>
              <div class="observer-step">
                <strong>3</strong> Enter your Wi-Fi credentials and click send, then reboot the node.
                <div class="observer-grid">
                  <div>
                    <label for="observerName">Observer name</label>
                    <input id="observerName" type="text" placeholder="Observer name"/>
                  </div>
                  <div>
                    <label for="observerWifi">Wi-Fi SSID</label>
                    <input id="observerWifi" type="text" placeholder="MyWiFi"/>
                  </div>
                  <div>
                    <label for="observerPass">Wi-Fi password</label>
                    <input id="observerPass" type="password" placeholder="password"/>
                  </div>
                </div>
                <div class="observer-actions">
                  <button class="btn" type="button" id="observerSendConfig">Send Wi-Fi config</button>
                </div>
              </div>
              <div class="observer-step"><strong>4</strong> If your node appears in Pending Observers, send a repeater advert to speed up geolocation.</div>
              <div class="observer-step"><strong>5</strong> Once validated, it moves to Observer Rank automatically.</div>
            </div>
          <div class="observer-status" id="observerStatus"></div>
          <div id="installLog" class="install-log">Verbose install log ready.</div>
        </div>
        <div class="observer-right">
          <div class="observer-card">
            <div style="font-weight:700;">Current Observer Coverage</div>
            <div class="observer-legend">
              <span><i></i> Active &lt; 1h</span>
              <span><i class="warn"></i> Idle 1-24h</span>
              <span><i class="bad"></i> Idle 24-48h</span>
            </div>
            <div style="font-size:12px;color:var(--muted);">Location pending observers stay off the map until validated.</div>
            <div id="observerMap" class="observer-map"></div>
          </div>
          <div class="observer-card">
            <div style="font-weight:700;">Pending Observers</div>
            <div style="font-size:12px;color:var(--muted);">Only observers awaiting geolocation appear here.</div>
            <div id="observerList" class="rf-list"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel observer-rank-panel">
      <div class="title">Observer Rank <span class="chip" id="observerRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total observers</div>
          <strong id="observerRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (&lt;1h)</div>
          <strong id="observerRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Packets today</div>
          <strong id="observerRankPackets">0</strong>
        </div>
      </div>
      <div class="rank-body observer-rank-body">
        <div class="rank-map observer-rank-map">
          <div id="observerRankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="observerRankSearch" type="text" placeholder="Search observers"/>
          <div class="rank-scroll" id="observerRankScroll">
            <div id="observerRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <div class="observer-location-modal" id="observerLocationModal">
      <div class="observer-location-card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <strong>Set Observer Location</strong>
          <button class="observer-location-button" type="button" id="observerLocationClose">Close</button>
        </div>
        <div class="observer-location-map" id="observerLocationMap"></div>
        <div class="observer-location-meta">
          <span id="observerLocationLabel">Observer: --</span>
          <span id="observerLocationCoords">Lat/Lon: --</span>
        </div>
        <div class="observer-location-actions">
          <button class="btn" type="button" id="observerLocationSave">Save location</button>
        </div>
      </div>
    </div>

    <section class="panel why-panel">
      <div class="title">Why MeshRank?</div>
      <div class="why-body">
        <div class="why-card">
          <h3>Why MeshRank?</h3>
          <p>Mesh networks promise resilience, but in their early stages they often struggle with something more basic: confidence.</p>
          <p>With MeshCORE, new repeaters are frequently deployed into sparse or growing networks. When messages dont appear to move  or theres no clear feedback  operators naturally assume the repeater isnt helping. Too often, it gets switched off, and the network loses coverage just when it needs it most.</p>
          <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping?</p>
          <p>By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient. MeshRank exists to change that experience.</p>
          <p>It provides visibility into how the mesh is actually performing:</p>
          <p>Which repeaters are active and contributing over time. Which messages were delivered, with a confidence score rather than guesswork. Where messages were observed but failed to fully propagate.</p>
          <p>This feedback loop keeps operators engaged and informed, even when the network is still maturing.</p>
          <p>MeshRank uses a passive observer network to provide insight without increasing mesh traffic. By reducing the need for repeated test messages, it lowers network load while giving users meaningful information about whats happening behind the scenes.</p>
          <p>Repeaters are ranked based on real contribution, not assumptions  encouraging operators to keep nodes online, improve placement, and actively strengthen the network.</p>
          <p>MeshRank doesnt replace the mesh, and it doesnt route traffic through the internet. It simply helps the mesh understand itself.</p>
          <p>Visibility builds confidence. Confidence builds resilience.</p>
        </div>
        <div class="why-card">
          <h3>Frequently Asked Questions</h3>
          <div class="faq-item">
            <strong>Does MeshRank route messages over the internet?</strong>
            <p>No. MeshRank does not forward, relay, or complete mesh messages using the internet. All mesh communication still happens entirely over RF. MeshRank only observes what has already occurred and reports that information back to users.</p>
          </div>
          <div class="faq-item">
            <strong>Does this break the idea of a pure mesh?</strong>
            <p>No. The mesh remains fully autonomous and functional without MeshRank. If MeshRank disappeared tomorrow, the mesh would continue to operate exactly as it does today. MeshRank does not participate in routing decisions, message delivery, or network control  it provides visibility, not dependency.</p>
          </div>
          <div class="faq-item">
            <strong>Why involve the internet at all?</strong>
            <p>Because feedback matters. In early and sparse networks, lack of feedback causes repeaters to be switched off, not improved. MeshRank uses off-mesh observation to help operators understand whats happening without increasing RF traffic or adding test spam to the network. This strengthens the mesh  it doesnt weaken it.</p>
          </div>
          <div class="faq-item">
            <strong>Could this become a central point of failure?</strong>
            <p>No. MeshRank is not in the message path. It cannot block, delay, or interfere with mesh traffic. If MeshRank goes offline, the mesh continues to operate unchanged. There is no reliance on MeshRank for delivery, routing, or authentication.</p>
          </div>
          <div class="faq-item">
            <strong>Does this reduce resilience by encouraging internet dependence?</strong>
            <p>Quite the opposite. MeshRank encourages: better repeater placement, higher uptime, reduced test traffic, and faster identification of coverage gaps. All of these increase RF-only resilience, even when the internet is unavailable.</p>
          </div>
          <div class="faq-item">
            <strong>Is this surveillance or message tracking?</strong>
            <p>No. Observers do not inject traffic or control the network. They report limited metadata needed to understand propagation  not to monitor users. The goal is network health, not message content analysis.</p>
          </div>
          <div class="faq-item">
            <strong>Why ranking repeaters? Isnt that gamification?</strong>
            <p>Yes  intentionally. Visibility and motivation matter. Ranking makes contribution measurable, encourages operators to keep repeaters online, and helps the network grow during its most fragile phase. Strong networks are built by engaged operators.</p>
          </div>
          <div class="faq-item">
            <strong>What happens when the mesh becomes dense and mature?</strong>
            <p>MeshRank becomes less critical  and thats a success. As density increases, confidence becomes self-sustaining. MeshRanks role naturally shifts toward diagnostics, optimisation, and historical insight rather than reassurance.</p>
          </div>
          <div class="faq-item">
            <strong>So what is MeshRank really for?</strong>
            <p>MeshRank exists to answer one question early mesh networks struggle with: Is this helping? By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient.</p>
          </div>
        </div>
      </div>
    </section>
  </div>

    <div class="modal" id="channelModal">
      <div class="modal-card">
        <strong>Add Channel</strong>
      <div class="field">
        <label for="channelName"># Channel name</label>
        <input id="channelName" type="text" placeholder="#public"/>
      </div>
      <div class="field">
        <label for="channelSecret">Secret (32 hex chars)</label>
        <input id="channelSecret" type="text" placeholder="8b3387e9c5cdea6ac9e4edbaa115cd72"/>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelChannel">Cancel</button>
        <button class="btn" id="saveChannel">Save</button>
      </div>
      </div>
    </div>

    <div class="modal" id="routeOverrideModal">
      <div class="modal-card route-modal-card">
        <strong>Suggest route fixes</strong>
        <div style="font-size:12px;color:var(--muted);line-height:1.5;">
          Pick the correct repeater for each 2-digit code. Suggestions are weighted over time, so one user cannot rewrite the route.
        </div>
        <div class="route-override-list" id="routeOverrideList"></div>
        <div class="route-override-status" id="routeOverrideStatus">No changes submitted yet.</div>
        <div class="modal-actions">
          <button class="btn" id="routeOverrideClose">Close</button>
          <button class="btn" id="routeOverrideSave">Submit suggestions</button>
        </div>
      </div>
    </div>

  </div>

  <script type="module" src="https://unpkg.com/esp-web-tools@9.1.0/dist/web/install-button.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    document.body.classList.add("view-channels");
      const appData = {
        channels: [],
        messages: [],
        lastChannelsSig: "",
        lastMessagesSig: "",
        renderedIdsByChannel: {},
        meshScore: null,
        rankData: null,
        rankFilter: "",
        unreadByChannel: {},
        lastReadByChannel: {},
        rfPackets: [],
        rfSelected: null,
        rfLastSig: "",
        observerRank: null,
        observersById: {},
        observersByName: {},
        observersUpdatedAt: 0,
        routeSuggestions: null,
        repeatersByCode: null,
        routeActivePathCodes: [],
        routeActivePathPoints: [],
        routeActiveMsg: null
      };

    const colors = ["#007aff", "#5856d6", "#ff9500", "#34c759"];

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function hasValidGps(r) {
      const lat = r?.gps?.lat;
      const lon = r?.gps?.lon;
      return Number.isFinite(lat) && Number.isFinite(lon) && !(lat === 0 && lon === 0);
    }

    function isRepeaterHidden(r) {
      return !!r?.hiddenOnMap || !hasValidGps(r) || r?.stale;
    }

    function confidence(msg) {
      const repeats = msg.repeats || msg.pathLength || 1;
      const observerCount = Number.isFinite(msg.observerCount)
        ? msg.observerCount
        : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
      const repeatScore = clamp(repeats / 8, 0, 1);
      const observerScore = clamp(observerCount / 3, 0, 1);
      const score = 100 * clamp(0.2 + (0.5 * repeatScore) + (0.3 * observerScore), 0, 1);
      return Math.round(score);
    }

    function normalizeChannelId(value) {
      return String(value || "").trim().replace(/^#/, "").toLowerCase();
    }

    let activeChannelId = "public";
    function applyChannels(channels) {
      appData.channels = (channels || []).map((c) => ({
        ...c,
        id: normalizeChannelId(c.id || c.name)
      }));
      if (appData.channels.length) {
        const exists = appData.channels.some((c) => c.id === activeChannelId);
        if (!exists) activeChannelId = appData.channels[0].id;
        const active = appData.channels.find((c) => c.id === activeChannelId);
        if (active) document.getElementById("activeChannel").textContent = active.name;
      } else {
        activeChannelId = "public";
        document.getElementById("activeChannel").textContent = "#public";
      }
      renderChannels();
    }
    function updateChannelParam(channelId) {
      const url = new URL(window.location.href);
      if (channelId) {
        url.searchParams.set("channel", channelId);
      } else {
        url.searchParams.delete("channel");
      }
      window.history.replaceState({}, "", url.toString());
    }

    function renderChannels() {
      const el = document.getElementById("channels");
      const tabBadges = document.querySelectorAll(".channels-unread");
      el.innerHTML = "";
      const list = appData.channels.length
        ? appData.channels
        : [{ id: "public", name: "#public", snippet: "No channels yet.", time: "--" }];
      const totalUnread = Object.values(appData.unreadByChannel || {}).reduce((sum, v) => sum + (v || 0), 0);
      tabBadges.forEach((badge) => {
        badge.textContent = totalUnread || 0;
        badge.style.display = totalUnread ? "inline-flex" : "none";
      });
      list.forEach((ch, idx) => {
        const unread = appData.unreadByChannel[ch.id] || 0;
        const displayName = ch.name || "#unknown";
        const avatarChar = (displayName[1] || displayName[0] || "?").toUpperCase();
        const snippet = ch.snippet || "No recent messages.";
        const time = ch.time || "--";
        const row = document.createElement("div");
        row.className = "channel" + (ch.id === activeChannelId ? " active" : "") + (unread ? " unread" : "");
        row.innerHTML = `
          <div class="avatar" style="background:${colors[idx % colors.length]}">${avatarChar}</div>
          <div>
            <div class="name">${displayName}</div>
            <div class="snippet">${snippet}</div>
          </div>
          <div style="display:grid;gap:6px;justify-items:end;">
            <div class="muted">${time}</div>
            ${unread ? `<div class="badge-bubble">${unread}</div>` : ""}
            <button class="channel-remove" type="button" data-name="${ch.name}">Remove</button>
          </div>
        `;
        row.addEventListener("click", () => {
          activeChannelId = ch.id;
          document.getElementById("activeChannel").textContent = ch.name;
          updateChannelParam(activeChannelId);
          const latest = appData.messages
            .filter((msg) => msg.channelId === activeChannelId)
            .map((msg) => msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0)
            .reduce((a, b) => Math.max(a, b), 0);
          if (latest) appData.lastReadByChannel[activeChannelId] = latest;
          appData.unreadByChannel[activeChannelId] = 0;
          saveReadState();
          renderChannels();
          renderMessages(true);
          loadMessages(false);
          document.body.classList.remove("menu-open-left", "menu-open-right");
        });
        row.querySelector(".channel-remove").addEventListener("click", async (e) => {
          e.stopPropagation();
          const name = e.currentTarget.dataset.name;
          if (!name) return;
          if (!confirm(`Remove ${name}?`)) return;
          try {
            await fetch(`/api/channels?name=${encodeURIComponent(name)}`, { method: "DELETE" });
            await loadChannels();
          } catch {
            alert("Unable to remove channel.");
          }
        });
        el.appendChild(row);
      });
    }

    function renderMessages(full) {
      const el = document.getElementById("messages");
      const filtered = appData.messages.filter((msg) => msg.channelId === activeChannelId);
      const key = activeChannelId;
      let rendered = appData.renderedIdsByChannel[key] || new Set();
      if (!full && rendered.size !== filtered.length) {
        full = true;
      }
      if (full) {
        el.innerHTML = "";
        rendered = new Set();
        appData.renderedIdsByChannel[key] = rendered;
      }

      filtered.forEach((msg, idx) => {
        const keyId = msg.frameHash || msg.id;
        if (rendered.has(keyId)) {
          const existing = el.querySelector(`.message[data-id="${keyId}"]`);
          if (existing) {
            const observerEl = existing.querySelector(".msg-observers");
            if (observerEl) observerEl.textContent = `Observers: ${observerCount}`;
            const hopsEl = existing.querySelector(".msg-hops");
            if (hopsEl) {
              const hops = Number.isFinite(msg.uniqueHopCount)
                ? msg.uniqueHopCount
                : (msg.pathLength ?? msg.repeats ?? 0);
              hopsEl.textContent = `Total hops: ${hops}`;
            }
            const confEl = existing.querySelector(".msg-confidence");
            if (confEl) confEl.textContent = `MeshRank Confidence: ${conf}%`;
          }
          return;
        }
        const row = document.createElement("div");
        row.className = "message";
        row.dataset.id = keyId;
        const conf = confidence(msg);
        const observerCount = Number.isFinite(msg.observerCount)
          ? msg.observerCount
          : (Array.isArray(msg.observerHits) ? msg.observerHits.length : 0);
        const observerList = msg.observerHits ? msg.observerHits.join(", ") : "";
        row.innerHTML = `
          <div class="avatar" style="background:${colors[(idx + 1) % colors.length]}">${msg.sender[0]}</div>
          <div>
            <div class="meta">
              <strong>${msg.sender}</strong>
              <span>${msg.ts}</span>
              <span class="badge">${msg.type}</span>
            </div>
            <div class="bubble ${msg.type}">${msg.body}</div>
              <div class="msg-footer">
                <span class="msg-observers">Observers: ${observerCount}</span>
                <span class="msg-hops">Total hops: ${Number.isFinite(msg.uniqueHopCount) ? msg.uniqueHopCount : (msg.pathLength ?? msg.repeats ?? 0)}</span>
                <span class="msg-confidence">MeshRank Confidence: ${conf}%</span>
                <a class="analyze" href="#" data-id="${keyId}">Analyze</a>
              </div>
          </div>
        `;
        el.appendChild(row);
        rendered.add(keyId);
      });
      appData.renderedIdsByChannel[key] = rendered;
      el.scrollTop = el.scrollHeight;
    }

    let map;
    let routeLayer;

    function initMap() {
      map = L.map("routeMap", { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);
      routeLayer = L.layerGroup().addTo(map);
    }

    async function showRoute(msgId) {
      const msg = appData.messages.find((m) => (m.frameHash || m.id) === msgId || m.id === msgId);
      if (!msg) return;
      appData.routeActiveId = msgId;
      appData.routeActiveMsg = msg;
      if (window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.add("route-open");
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 120);
      }

      await ensureRouteSuggestions();
      await ensureObservers();
      document.getElementById("routeKey").textContent = msg.id;
      document.getElementById("routeMessage").textContent = msg.frameHash || msg.messageHash || msg.id;
      document.getElementById("routeSource").textContent = msg.type;
      document.getElementById("routeConfidence").textContent = confidence(msg) + "%";

      const depth = Math.max(1, msg.path.length || 1);
      const maxDepth = depth;
      document.getElementById("routeDepth").textContent = maxDepth + " hops";

      routeLayer.clearLayers();

      const list = document.getElementById("routeList");
      list.innerHTML = "";
        const lines = msg.path && msg.path.length ? msg.path : ["no route data"];
        const names = msg.pathNames && msg.pathNames.length ? msg.pathNames : [];
        const slicedLines = lines.slice(0, maxDepth);
        const slicedNames = names.slice(0, maxDepth);
        appData.routeActivePathCodes = slicedLines.slice();
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        slicedLines.forEach((node, idx) => {
          const label = resolveRouteName(node, slicedNames[idx] ? slicedNames[idx] : node);
          const code = String(node || "").toUpperCase();
          const isRepeater = repeatersByCode && repeatersByCode.has(code);
          const item = document.createElement("div");
          item.className = "list-item";
        item.innerHTML = isRepeater
          ? `<span>${label}</span><span class="repeater-tag">Repeater</span>`
          : `<span>${label}</span>`;
        list.appendChild(item);
      });

      const observerHits = Array.isArray(msg.observerHits) ? msg.observerHits : [];
      if (observerHits.length) {
        const byId = appData.observersById || {};
        const byName = appData.observersByName || {};
        observerHits.forEach((raw) => {
          const key = String(raw || "").trim();
          if (!key) return;
          const entry = byId[key] || byName[key] || null;
          const label = entry?.name || entry?.id || key;
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `<span>${label}</span><span class="observer-tag">Observer</span>`;
          list.appendChild(item);
        });
      }

      document.getElementById("routeCount").textContent = slicedLines.length + observerHits.length;

      if (routeLayer) {
        routeLayer.clearLayers();
        const path = Array.isArray(msg.path) ? msg.path.slice(0, maxDepth) : [];
          const rawPoints = Array.isArray(msg.pathPoints) ? msg.pathPoints.slice(0, maxDepth) : [];
          appData.routeActivePathPoints = rawPoints.slice();
        const pathLen = Math.max(path.length, rawPoints.length);
        const normalized = [];

        function hasGps(p) {
          if (!p || !p.gps || !Number.isFinite(p.gps.lat) || !Number.isFinite(p.gps.lon)) return false;
          if (p.gps.lat === 0 && p.gps.lon === 0) return false;
          return true;
        }

        function estimateFromNeighbors(idx) {
          let prev = null;
          for (let i = idx - 1; i >= 0; i -= 1) {
            const p = normalized[i];
            if (p && hasGps(p)) { prev = p; break; }
          }
          let next = null;
          for (let i = idx + 1; i < normalized.length; i += 1) {
            const p = normalized[i];
            if (p && hasGps(p)) { next = p; break; }
          }
          if (prev && next) {
            return {
              lat: (prev.gps.lat + next.gps.lat) / 2,
              lon: (prev.gps.lon + next.gps.lon) / 2
            };
          }
          if (prev) {
            return { lat: prev.gps.lat + 0.05, lon: prev.gps.lon - 0.05 };
          }
          if (next) {
            return { lat: next.gps.lat - 0.05, lon: next.gps.lon + 0.05 };
          }
          return null;
        }

        for (let i = 0; i < pathLen; i += 1) {
          const base = rawPoints[i] || { hash: path[i], name: msg.pathNames?.[i] || path[i] || "#unknown" };
          const resolvedName = resolveRouteName(base.hash || path[i], base.name);
          normalized.push({ ...base, name: resolvedName });
        }

        const latlngs = [];
        const COVERAGE_RADIUS_M = 16093; // 10 miles in meters
        normalized.forEach((p, idx) => {
          let gps = hasGps(p) ? p.gps : null;
          let estimated = false;
          if (!gps) {
            const guess = estimateFromNeighbors(idx);
            if (guess) {
              gps = guess;
              estimated = true;
            }
          }
          if (!gps) return;
          const latlng = [gps.lat, gps.lon];
          latlngs.push(latlng);
          const color = estimated ? "#ffcc00" : "#007aff";
          L.circle(latlng, {
            radius: COVERAGE_RADIUS_M,
            color,
            fillColor: color,
            fillOpacity: 0.15,
            weight: 1
          }).bindPopup(estimated ? `${p.name || "#unknown"} (estimated)` : (p.name || "#unknown")).addTo(routeLayer);
        });

        if (observerHits.length) {
          const byId = appData.observersById || {};
          const byName = appData.observersByName || {};
          observerHits.forEach((raw) => {
            const key = String(raw || "").trim();
            if (!key) return;
            const entry = byId[key] || byName[key] || null;
            const gps = entry?.manualLocation && entry?.gpsApprox
              ? entry.gpsApprox
              : (entry?.gps || entry?.gpsApprox);
            if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
            const latlng = [gps.lat, gps.lon];
            latlngs.push(latlng);
            const label = entry?.name || entry?.id || key;
            L.circleMarker(latlng, {
              radius: 6,
              color: entry?.locValidated ? "#00c853" : "#8fd3ff",
              fillColor: entry?.locValidated ? "#00c853" : "#8fd3ff",
              fillOpacity: 0.9,
              weight: 2
            }).bindPopup(`Observer: ${label}${entry?.locValidated ? "" : " (approx)"}`).addTo(routeLayer);
          });
        }

        if (latlngs.length >= 2) {
          map.fitBounds(latlngs, { padding: [20, 20] });
        } else if (latlngs.length === 1) {
          map.setView(latlngs[0], 9);
        }
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 120);
      }
    }

    document.addEventListener("click", (e) => {
      const link = e.target.closest(".analyze");
      if (!link) return;
      e.preventDefault();
      showRoute(link.dataset.id);
    });

    const routeClose = document.getElementById("routeClose");
    const routeBackdrop = document.getElementById("routeBackdrop");
    function closeRouteOverlay() {
      document.body.classList.remove("route-open");
    }
    routeClose?.addEventListener("click", closeRouteOverlay);
    routeBackdrop?.addEventListener("click", closeRouteOverlay);
    const messageList = document.getElementById("messages");
    const isMobile = () => window.matchMedia?.("(max-width: 860px)")?.matches;
    messageList?.addEventListener("scroll", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
    });
    messageList?.addEventListener("click", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
    });
    messageList?.addEventListener("touchstart", () => {
      if (isMobile() && document.body.classList.contains("route-open")) closeRouteOverlay();
    }, { passive: true });
    window.addEventListener("resize", () => {
      if (!window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
    });

    const routeOverrideBtn = document.getElementById("routeOverrideBtn");
    const routeOverrideModal = document.getElementById("routeOverrideModal");
    const routeOverrideList = document.getElementById("routeOverrideList");
    const routeOverrideStatus = document.getElementById("routeOverrideStatus");
    const routeOverrideClose = document.getElementById("routeOverrideClose");
    const routeOverrideSave = document.getElementById("routeOverrideSave");

    function getRouteVoterId() {
      const key = "routeVoterId";
      let id = localStorage.getItem(key);
      if (id) return id;
      id = Math.random().toString(36).slice(2, 12);
      localStorage.setItem(key, id);
      return id;
    }

    function openRouteOverrideModal() {
      if (!routeOverrideModal || !routeOverrideList) return;
      const codes = appData.routeActivePathCodes || [];
      routeOverrideList.innerHTML = "";
      if (!codes.length) {
        routeOverrideList.innerHTML = `<div class="route-override-empty">Select a packet in MeshFlow first, then try again.</div>`;
        if (routeOverrideStatus) routeOverrideStatus.textContent = "No route selected yet.";
        routeOverrideModal.classList.add("open");
        return;
      }
      const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const suggestions = appData.routeSuggestions?.byCode || {};
      const points = appData.routeActivePathPoints || [];

      codes.forEach((code, idx) => {
        const key = String(code || "").toUpperCase();
        const options = repeatersByCode.get(key) || [];
        const pointName = points[idx]?.name || appData.routeActiveMsg?.pathNames?.[idx] || key;
        const currentName = resolveRouteName(key, pointName);
        const best = suggestions[key];
        const bestText = best && best.accepted ? `${best.name || best.pub} (${best.confidence}% confidence)` : "No community match yet";

        const row = document.createElement("div");
        row.className = "route-override-row";

        const label = document.createElement("div");
        label.className = "route-override-label";
        label.innerHTML = `<strong>${key}</strong><div>Current: ${currentName}</div><div>Community: ${bestText}</div>`;

        const select = document.createElement("select");
        select.className = "route-override-select";
        select.dataset.code = key;

        const optKeep = document.createElement("option");
        optKeep.value = "keep";
        optKeep.textContent = "Keep current";
        select.appendChild(optKeep);

        const optNone = document.createElement("option");
        optNone.value = "none";
        optNone.textContent = "None of these";
        select.appendChild(optNone);

        if (options.length) {
          const divider = document.createElement("option");
          divider.disabled = true;
          divider.textContent = "-- Repeaters with this code --";
          select.appendChild(divider);
          options.forEach((opt) => {
            const o = document.createElement("option");
            o.value = opt.pub || "";
            o.textContent = opt.name || opt.pub || key;
            select.appendChild(o);
          });
        }

        row.appendChild(label);
        row.appendChild(select);
        routeOverrideList.appendChild(row);
      });

      if (routeOverrideStatus) routeOverrideStatus.textContent = "Select repeaters, then submit.";
      routeOverrideModal.classList.add("open");
    }

    if (routeOverrideBtn) {
      routeOverrideBtn.addEventListener("click", async () => {
        await ensureRouteSuggestions();
        openRouteOverrideModal();
      });
    }

    window.openRouteOverride = async () => {
      await ensureRouteSuggestions();
      openRouteOverrideModal();
    };

    if (routeOverrideClose) {
      routeOverrideClose.addEventListener("click", () => {
        if (routeOverrideModal) routeOverrideModal.classList.remove("open");
      });
    }

    if (routeOverrideSave) {
      routeOverrideSave.addEventListener("click", async () => {
        if (!routeOverrideList) return;
        const voterId = getRouteVoterId();
        const pathGps = (appData.routeActivePathPoints || []).map((p) => p?.gps).filter(Boolean);
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        const selects = routeOverrideList.querySelectorAll("select[data-code]");
        const requests = [];

        selects.forEach((select) => {
          const code = select.dataset.code;
          const choice = select.value;
          if (!code || choice === "keep") return;
          if (choice === "none") {
            overrideRouteName(code, "");
            return;
          }
          const options = repeatersByCode.get(code) || [];
          const picked = options.find((opt) => opt.pub === choice);
          if (!picked) return;
          overrideRouteName(code, picked.name || code);
          requests.push(fetch("/api/route-suggest", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              code,
              repeaterPub: picked.pub,
              repeaterName: picked.name || "",
              voterId,
              pathGps
            })
          }));
        });

        if (!requests.length) {
          if (routeOverrideStatus) routeOverrideStatus.textContent = "No changes selected.";
          return;
        }

        if (routeOverrideStatus) routeOverrideStatus.textContent = "Submitting suggestions...";
        await Promise.allSettled(requests);
        try {
          appData.routeSuggestions = await fetchRouteSuggestions();
        } catch {}
        if (routeOverrideStatus) routeOverrideStatus.textContent = "Suggestions saved. Community scores update over time.";
        if (appData.routeActiveId) showRoute(appData.routeActiveId);
        renderRfList();
        renderRfDetail();
      });
    }

    const observerLocationModal = document.getElementById("observerLocationModal");
    const observerLocationClose = document.getElementById("observerLocationClose");
    const observerLocationSave = document.getElementById("observerLocationSave");
    const observerListEl = document.getElementById("observerList");

    observerLocationClose?.addEventListener("click", closeObserverLocationModal);
    observerLocationModal?.addEventListener("click", (e) => {
      if (e.target === observerLocationModal) closeObserverLocationModal();
    });

    observerListEl?.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-observer-locate]");
      if (!btn) return;
      const id = btn.getAttribute("data-observer-locate");
      const entry = appData.observersById?.[id];
      if (!entry) return;
      openObserverLocationModal(entry);
    });

    observerLocationSave?.addEventListener("click", async () => {
      if (!observerLocationTarget || !observerLocationCoords) {
        alert("Click a location on the map first.");
        return;
      }
      try {
        const res = await fetch("/api/observer-location", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            id: observerLocationTarget.id,
            lat: observerLocationCoords.lat,
            lon: observerLocationCoords.lng
          })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await fetchObservers();
        updateObserversData(data);
        renderObserverMap(data);
        renderObserverList(data);
        closeObserverLocationModal();
      } catch (err) {
        alert("Unable to save location: " + (err?.message || err));
      }
    });

    const modal = document.getElementById("channelModal");
    const addBtn = document.getElementById("addChannelBtn");
    const cancelBtn = document.getElementById("cancelChannel");
    const saveBtn = document.getElementById("saveChannel");

    function openModal() {
      document.getElementById("channelName").value = "";
      document.getElementById("channelSecret").value = "";
      modal.classList.add("open");
    }

    function closeModal() {
      modal.classList.remove("open");
    }

    addBtn.addEventListener("click", openModal);
    cancelBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e) => {
      if (e.target === modal) closeModal();
    });

    saveBtn.addEventListener("click", async () => {
      const name = document.getElementById("channelName").value.trim();
      const secret = document.getElementById("channelSecret").value.trim();
      if (!name.startsWith("#")) {
        alert("Channel name must start with #");
        return;
      }
      if (!/^[0-9a-fA-F]{32}$/.test(secret)) {
        alert("Secret must be 32 hex characters");
        return;
      }
      try {
        const res = await fetch("/api/channels", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, secretHex: secret })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        await loadChannels();
        closeModal();
      } catch (err) {
        alert("Failed to add channel: " + (err?.message || err));
      }
    });

    async function loadChannels() {
      const res = await fetch("/api/channels", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      applyChannels(data.channels || []);
    }

    function mergeMessages(raw) {
      const byKey = new Map();
      raw.forEach((m) => {
        const stableId = m.hash || m.fp || m.id;
        const ts = m.ts ? new Date(m.ts).getTime() : 0;
        const bucket = ts ? Math.round(ts / 10000) * 10000 : 0;
        const body = (m.body || "").trim();
        const key = stableId
          ? String(stableId).toLowerCase()
          : `${m.channelName || ""}|${m.sender || ""}|${body}|${bucket}`;
        let entry = byKey.get(key);
        if (!entry) {
          entry = {
            ...m,
            id: m.id || stableId || key,
            _observerSet: new Set(),
            _pathSet: new Set()
          };
          byKey.set(key, entry);
        }
        const observerHits = Array.isArray(m.observerHits) ? m.observerHits : [];
        observerHits.forEach((o) => entry._observerSet.add(o));
        const singleObserver = m.observerName || m.observerId || m.observer || null;
        if (singleObserver) entry._observerSet.add(singleObserver);
        const path = Array.isArray(m.path) ? m.path : [];
        path.forEach((code) => {
          if (code !== undefined && code !== null && String(code).length) {
            entry._pathSet.add(String(code));
          }
        });
        if (!entry.path?.length && path.length) entry.path = path;
        if (!entry.pathNames?.length && Array.isArray(m.pathNames) && m.pathNames.length) entry.pathNames = m.pathNames;
        if (!entry.pathPoints?.length && Array.isArray(m.pathPoints) && m.pathPoints.length) entry.pathPoints = m.pathPoints;
        entry.repeats = Math.max(entry.repeats || 0, m.repeats || 0);
        if (Number.isFinite(m.pathLength)) {
          entry.pathLength = Math.max(entry.pathLength || 0, m.pathLength || 0);
        }
      });
      return Array.from(byKey.values()).map((entry) => {
        const observerHits = Array.from(entry._observerSet || []);
        const uniqueHopCount = entry._pathSet && entry._pathSet.size ? entry._pathSet.size : 1;
        const { _observerSet, _pathSet, ...clean } = entry;
        return {
          ...clean,
          observerHits,
          observerCount: observerHits.length || entry.observerCount || 0,
          uniqueHopCount
        };
      });
    }

    async function loadMessages(forceFull) {
      const res = await fetch("/api/messages", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const raw = mergeMessages(data.messages || []);
      appData.messages = raw.map((m) => ({
        id: m.id,
        frameHash: m.frameHash || null,
        messageHash: m.messageHash || null,
        channelId: normalizeChannelId(m.channelName || "#unknown"),
        sender: m.sender,
        body: m.body,
        tsRaw: m.ts || null,
        ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
        type: "mesh",
        repeats: m.repeats || 1,
        pathLength: Number.isFinite(m.pathLength) ? m.pathLength : null,
        uniqueHopCount: Number.isFinite(m.uniqueHopCount) ? m.uniqueHopCount : null,
        path: Array.isArray(m.path) ? m.path : [],
        pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
        pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : [],
        observerHits: Array.isArray(m.observerHits) ? m.observerHits : [],
        observerCount: Number.isFinite(m.observerCount) ? m.observerCount : null
      })).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
      const unread = {};
      const latestByChannel = {};
      appData.messages.forEach((msg) => {
        if (!msg.channelId) return;
        const t = msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0;
        if (!latestByChannel[msg.channelId] || t > latestByChannel[msg.channelId]) {
          latestByChannel[msg.channelId] = t;
        }
        const lastRead = appData.lastReadByChannel[msg.channelId] || 0;
        if (t > lastRead) {
          unread[msg.channelId] = (unread[msg.channelId] || 0) + 1;
        }
      });
      const activeLatest = latestByChannel[activeChannelId] || 0;
      if (activeLatest) {
        appData.lastReadByChannel[activeChannelId] = activeLatest;
        unread[activeChannelId] = 0;
        saveReadState();
      }
      appData.unreadByChannel = unread;
      if (Array.isArray(data.channels)) {
        applyChannels(data.channels);
      } else {
        renderChannels();
      }
      renderMessages(!!forceFull);
      if (forceFull && appData.messages.length && !isMobile()) {
        showRoute(appData.messages[0].id);
      }
    }

    async function checkServerStatus() {
      try {
        const res = await fetch("/api/channels?ts=" + Date.now(), { cache: "no-store" });
        setServerStatus(res.ok);
        return res.ok;
      } catch {
        setServerStatus(false);
        return false;
      }
    }

    function loadReadState() {
      try {
        const raw = localStorage.getItem("meshmonitor.lastReadByChannel");
        const parsed = raw ? JSON.parse(raw) : {};
        if (parsed && typeof parsed === "object") appData.lastReadByChannel = parsed;
      } catch {}
    }

    function saveReadState() {
      localStorage.setItem("meshmonitor.lastReadByChannel", JSON.stringify(appData.lastReadByChannel));
    }

    async function boot() {
      const url = new URL(window.location.href);
      const channelParam = url.searchParams.get("channel");
      if (channelParam) {
        activeChannelId = normalizeChannelId(channelParam);
      }
      await checkServerStatus();
      if (window.matchMedia?.("(max-width: 860px)")?.matches) {
        document.body.classList.remove("route-open");
      }
      try {
        await loadChannels();
        await loadMessages(true);
        try {
          const mesh = await fetchMeshScore();
          renderMeshScore(mesh, meshRangeDays);
        } catch {}
        setServerStatus(true);
      } catch (err) {
        const msg = document.createElement("div");
        msg.className = "rank-item";
        msg.textContent = "No messages yet.";
        document.getElementById("messages").appendChild(msg);
        setServerStatus(false);
      }
      initMap();
      initObserverMap();
      setInterval(async () => {
        const ok = await checkServerStatus();
        if (!ok) return;
        try {
          await loadMessages();
        } catch {}
      }, 2000);

      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        try {
          const mesh = await fetchMeshScore();
          renderMeshScore(mesh, meshRangeDays);
          const data = await fetchRank();
          renderRank(data);
        } catch {}
      }, 15 * 60 * 1000);

      setInterval(async () => {
        const activeRf = document.body.classList.contains("view-rf");
        if (!activeRf) return;
        try {
          const payload = await fetchRfLatest();
          const items = payload.items || [];
          const last = items[items.length - 1];
          const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
          if (sig !== appData.rfLastSig) {
            appData.rfLastSig = sig;
            appData.rfPackets = items;
            document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
            renderRfList();
          }
          if (!appData.rfSelected && appData.rfPackets.length) {
            appData.rfSelected = appData.rfPackets[appData.rfPackets.length - 1];
            renderRfDetail();
          }
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserver = document.body.classList.contains("view-observer");
        if (!activeObserver) return;
        try {
          const data = await fetchObservers();
          updateObserversData(data);
          renderObserverMap(data);
          renderObserverList(data);
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        try {
          const data = await fetchObserverRank();
          appData.observerRank = data;
          renderObserverRank(data);
          renderObserverRankMap(data);
        } catch {}
      }, 15 * 60 * 1000);
    }

    boot();

    let rankMap;
    let rankLayer;
    let rankMarkers = new Map();
    let meshRangeDays = 7;
    let observerMap;
    let observerLayer;
    let observerRankMap;
    let observerRankLayer;
    let observerRankRadiusLayer;

    function initRankMap() {
      rankMap = L.map("rankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rankMap);
      rankLayer = L.layerGroup().addTo(rankMap);
    }

    function initObserverMap() {
      const el = document.getElementById("observerMap");
      if (!el) return;
      observerMap = L.map("observerMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerMap);
      observerLayer = L.layerGroup().addTo(observerMap);
    }

    function initObserverRankMap() {
      const el = document.getElementById("observerRankMap");
      if (!el) return;
      observerRankMap = L.map("observerRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerRankMap);
      observerRankLayer = L.layerGroup().addTo(observerRankMap);
      observerRankRadiusLayer = L.layerGroup().addTo(observerRankMap);
    }

    async function fetchObservers() {
      const res = await fetch("/api/observers?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRank() {
      const res = await fetch("/api/observer-rank?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function updateObserversData(data) {
      appData.observersById = data?.byId || {};
      appData.observersByName = {};
      Object.values(appData.observersById).forEach((entry) => {
        if (!entry) return;
        const name = String(entry.name || "").trim();
        if (name) appData.observersByName[name] = entry;
      });
      appData.observersUpdatedAt = Date.now();
    }

    async function ensureObservers() {
      if (Date.now() - appData.observersUpdatedAt < 60000) return;
      const data = await fetchObservers();
      updateObserversData(data);
    }

    function observerColor(ageHours) {
      if (ageHours <= 1) return "#34c759";
      if (ageHours <= 24) return "#ff9500";
      if (ageHours <= 48) return "#ff3b30";
      return null;
    }

    function renderObserverMap(data) {
      if (!observerLayer || !data) return;
      observerLayer.clearLayers();
      const entries = Object.values(data.byId || {});
      const now = Date.now();
      const points = [];
      entries.forEach((entry) => {
        const gps = entry.manualLocation && entry.gpsApprox
          ? entry.gpsApprox
          : (entry.locValidated ? entry.gps : (entry.gpsApprox || null));
        if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        const color = observerColor(ageHours);
        if (!color) return;
        const circle = L.circle([gps.lat, gps.lon], {
          radius: 5000,
          color,
          fillColor: color,
          fillOpacity: entry.locValidated ? 0.35 : 0.12,
          weight: entry.locValidated ? 2 : 1,
          dashArray: entry.locValidated ? null : "4 6"
        });
      const name = entry.name || entry.id || "Observer";
      const tag = entry.locValidated ? "" : " (approx)";
      circle.bindTooltip(name + tag, { direction: "top", opacity: 0.9 });
        circle.addTo(observerLayer);
        points.push([gps.lat, gps.lon]);
      });
      if (points.length) {
        observerMap.fitBounds(points, { padding: [20, 20], maxZoom: 6 });
      } else {
        observerMap.setView([54.0, -2.5], 6);
      }
      if (observerMap) {
        observerMap.invalidateSize();
      }
    }

    function renderObserverList(data) {
      const list = document.getElementById("observerList");
      if (!list || !data) return;
      const entries = Object.values(data.byId || {}).filter((entry) => {
        if (entry.locValidated) return false;
        if (entry.manualLocation || entry.locSource === "manual" || entry.gpsApprox) return false;
        return true;
      });
      if (!entries.length) {
        list.innerHTML = "<div class='rf-row'>No pending observers.</div>";
        return;
      }
      const now = Date.now();
      entries.sort((a, b) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
      list.innerHTML = entries.map((entry) => {
        const name = entry.name || entry.id || "Observer";
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        let status = "Active";
        if (ageHours > 24) status = "Idle 24h+";
        else if (ageHours > 1) status = "Idle 1h+";
        const location = entry.locValidated
          ? (entry.gps ? `${entry.gps.lat.toFixed(4)}, ${entry.gps.lon.toFixed(4)}` : "Estimated")
          : "Location pending";
        const source = entry.locSource ? ` | ${entry.locSource}` : "";
        return `<div class="rf-row">
          <div class="rf-head">${name}</div>
          <div class="rf-meta">${status} | ${location}${source}</div>
          <div><button class="observer-location-button" type="button" data-observer-locate="${entry.id}">Set location</button></div>
        </div>`;
      }).join("");
    }

    function renderObserverRank(data) {
      const list = document.getElementById("observerRankList");
      if (!list || !data?.items) return;
      const query = (document.getElementById("observerRankSearch")?.value || "").trim().toLowerCase();
      const items = data.items.filter((o) => !query || String(o.name || o.id).toLowerCase().includes(query));
        list.innerHTML = items.length
          ? items.map((o) => {
              const scoreBadge = String(Math.round(o.score || 0)).padStart(2, "0");
              return `
                <div class="rank-item${o.stale ? " hidden" : ""}">
                  <div class="score">
                    <span class="rank-dot" style="background:${o.scoreColor}">${scoreBadge}</span>
                    <div class="rank-main">
                      <strong>${o.name || o.id}</strong>
                      <div class="rank-meta">Uptime: ${o.uptimeHours.toFixed(1)}h | Packets today: ${o.packetsToday}</div>
                      <div class="rank-meta">Coverage: ${o.coverageKm.toFixed(1)}km | Repeaters: ${o.coverageCount}</div>
                      <div class="rank-meta">Nearest repeater: ${o.nearestRepeaterName || "--"}${Number.isFinite(o.nearestRepeaterKm) ? ` (${o.nearestRepeaterKm}km)` : ""}</div>
                      ${badgeHtml(buildObserverBadges(o))}
                    </div>
                  </div>
                </div>
              `;
            }).join("")
          : "<div class='rank-item'>No observers yet.</div>";

      document.getElementById("observerRankUpdated").textContent = data.updatedAt
        ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = data.items.length;
      document.getElementById("observerRankActive").textContent = data.items.filter((o) => o.ageHours < 1).length;
      document.getElementById("observerRankPackets").textContent = data.items.reduce((sum, o) => sum + o.packetsToday, 0);
    }

    function renderObserverRankMap(data) {
      if (!observerRankMap || !observerRankLayer || !observerRankRadiusLayer || !data?.items) return;
      observerRankLayer.clearLayers();
      observerRankRadiusLayer.clearLayers();
      const points = [];
      data.items.forEach((o) => {
        if (!o.gps) return;
        const latlng = [o.gps.lat, o.gps.lon];
        points.push(latlng);
        const marker = L.circleMarker(latlng, {
          radius: 7,
          weight: 2,
          color: o.scoreColor,
          fillColor: o.scoreColor,
          fillOpacity: 0.9
        }).bindPopup(`${o.name || o.id} | ${o.packetsToday} pkts today`);
        marker.addTo(observerRankLayer);
        if (o.coverageKm > 0) {
          const circle = L.circle(latlng, {
            radius: o.coverageKm * 1000,
            color: o.scoreColor,
            weight: 1,
            fillColor: o.scoreColor,
            fillOpacity: 0.08
          });
          circle.addTo(observerRankRadiusLayer);
        }
      });
      if (observerRankMap) observerRankMap.setView([54.0, -2.5], 6);
    }

    let observerLocationMap;
    let observerLocationMarker;
    let observerLocationTarget = null;
    let observerLocationCoords = null;

    function openObserverLocationModal(entry) {
      const modal = document.getElementById("observerLocationModal");
      const label = document.getElementById("observerLocationLabel");
      const coords = document.getElementById("observerLocationCoords");
      if (!modal) return;
      observerLocationTarget = entry;
      observerLocationCoords = null;
      label.textContent = `Observer: ${entry?.name || entry?.id || "--"}`;
      coords.textContent = "Lat/Lon: --";
      modal.classList.add("open");

      if (!observerLocationMap) {
        observerLocationMap = L.map("observerLocationMap", { zoomControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(observerLocationMap);
        observerLocationMap.on("click", (ev) => {
          observerLocationCoords = ev.latlng;
          coords.textContent = `Lat/Lon: ${ev.latlng.lat.toFixed(5)}, ${ev.latlng.lng.toFixed(5)}`;
          if (observerLocationMarker) observerLocationMarker.remove();
          observerLocationMarker = L.circleMarker(ev.latlng, {
            radius: 6,
            color: "#007aff",
            fillColor: "#007aff",
            fillOpacity: 0.9,
            weight: 2
          }).addTo(observerLocationMap);
        });
      }

      const gps = entry?.manualLocation && entry?.gpsApprox
        ? entry.gpsApprox
        : (entry?.gps || entry?.gpsApprox || null);
      if (gps && Number.isFinite(gps.lat) && Number.isFinite(gps.lon)) {
        observerLocationMap.setView([gps.lat, gps.lon], 10);
        observerLocationCoords = { lat: gps.lat, lng: gps.lon };
        coords.textContent = `Lat/Lon: ${gps.lat.toFixed(5)}, ${gps.lon.toFixed(5)}`;
        if (observerLocationMarker) observerLocationMarker.remove();
        observerLocationMarker = L.circleMarker([gps.lat, gps.lon], {
          radius: 6,
          color: "#007aff",
          fillColor: "#007aff",
          fillOpacity: 0.9,
          weight: 2
        }).addTo(observerLocationMap);
      } else {
        observerLocationMap.setView([54.0, -2.5], 6);
      }
      setTimeout(() => observerLocationMap.invalidateSize(), 80);
    }

    function closeObserverLocationModal() {
      const modal = document.getElementById("observerLocationModal");
      if (!modal) return;
      modal.classList.remove("open");
    }

    function formatDateTime(value) {
      const d = new Date(value);
      if (!Number.isFinite(d.getTime())) return "unknown";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
    }

    function distanceKm(a, b) {
      const toRad = (v) => (v * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const val = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(val), Math.sqrt(1 - val));
    }

    function badgeHtml(badges) {
      if (!badges.length) return "";
      return `<div class="badge-row">${badges.map((b) => `<span class="badge badge-${b.tone}">${b.label}</span>`).join("")}</div>`;
    }

    function buildNearestObserverRepeaters(repeaters, observers) {
      const flagged = new Set();
      if (!Array.isArray(observers) || !Array.isArray(repeaters)) return flagged;
      const repeaterPoints = repeaters.filter((r) => r?.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon));
      observers.forEach((o) => {
        if (!o?.gps || !Number.isFinite(o.gps.lat) || !Number.isFinite(o.gps.lon)) return;
        let best = null;
        let bestKm = Infinity;
        repeaterPoints.forEach((r) => {
          const km = distanceKm(o.gps, r.gps);
          if (km < bestKm) {
            bestKm = km;
            best = r;
          }
        });
        if (best?.pub) flagged.add(String(best.pub).toUpperCase());
      });
      return flagged;
    }

    function buildRepeaterBadges(r, nearestObserverSet) {
      const badges = [];
      if (r.stale) badges.push({ label: "Stale repeater", tone: "gray" });
      if (Number(r.total24h || 0) >= 10) badges.push({ label: "Great TX", tone: "green" });
      if (Number.isFinite(r.avgRssi) && r.avgRssi >= -75) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(r.zeroHopNeighbors24h || 0) >= 4) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(r.zeroHopNeighbors24h || 0) >= 3) badges.push({ label: "Great Mesh Neighbour", tone: "amber" });
      if (Number(r.avgRepeats || 0) >= 3 && Number(r.total24h || 0) >= 10) badges.push({ label: "Great Throughput", tone: "amber" });
      if (nearestObserverSet && r.pub && nearestObserverSet.has(String(r.pub).toUpperCase())) {
        badges.push({ label: "Close to Observer", tone: "green" });
      }
      return badges;
    }

    function buildObserverBadges(o) {
      const badges = [];
      if (Number.isFinite(o.ageHours)) {
        const ageMinutes = o.ageHours * 60;
        if (ageMinutes <= 2) badges.push({ label: "Live", tone: "green" });
        else badges.push({ label: "Offline", tone: "gray" });
      }
      if (o.stale) badges.push({ label: "Stale observer", tone: "gray" });
      if (Number(o.uptimeHours || 0) >= 48) badges.push({ label: "Great Uptime", tone: "green" });
      if (Number(o.packetsToday || 0) >= 200) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(o.coverageCount || 0) >= 5) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(o.coverageKm || 0) >= 20) badges.push({ label: "Wide Coverage", tone: "amber" });
      if (Number(o.nearestRepeaterKm || 999) <= 5) badges.push({ label: "Close to Repeater", tone: "green" });
      return badges;
    }

    async function fetchRank() {
      const res = await fetch(`/api/repeater-rank?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchMeshScore() {
      const res = await fetch("/api/meshscore", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRfLatest() {
      const res = await fetch("/api/rf-latest?limit=80", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRouteSuggestions() {
      const res = await fetch(`/api/route-suggestions?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function shortHex(value, len) {
      if (!value) return "--";
      const s = String(value);
      if (s.length <= len) return s;
      return s.slice(0, len);
    }

    function buildRepeatersByCode(data) {
      const map = new Map();
      const items = data?.items || [];
      for (const item of items) {
        const code = String(item.hashByte || "").toUpperCase();
        if (!code) continue;
        if (!map.has(code)) map.set(code, []);
        map.get(code).push({
          pub: item.pub,
          name: item.name || code,
          gps: item.gps || null
        });
      }
      return map;
    }

    async function ensureRouteSuggestions() {
      if (appData.routeSuggestions) return;
      try {
        appData.routeSuggestions = await fetchRouteSuggestions();
      } catch {
        appData.routeSuggestions = { byCode: {} };
      }
    }

    const routeOverrides = (() => {
      try {
        return JSON.parse(localStorage.getItem("routeOverrides") || "{}");
      } catch {
        return {};
      }
    })();

    function saveRouteOverrides() {
      try {
        localStorage.setItem("routeOverrides", JSON.stringify(routeOverrides));
      } catch {}
    }

    function overrideRouteName(hash, name) {
      const key = String(hash || "").toUpperCase();
      if (!key) return;
      if (!name) {
        delete routeOverrides[key];
      } else {
        routeOverrides[key] = name;
      }
      saveRouteOverrides();
    }

    function resolveRouteName(hash, fallback) {
      const key = String(hash || "").toUpperCase();
      if (key && routeOverrides[key]) return routeOverrides[key];
      const suggestion = appData.routeSuggestions?.byCode?.[key];
      if (suggestion?.accepted && suggestion.name) return suggestion.name;
      return fallback || hash || "#unknown";
    }

    function formatPathLabel(p) {
      const names = Array.isArray(p.pathNames) ? p.pathNames : [];
      const codes = Array.isArray(p.path) ? p.path : [];
      if (names.length) {
        const merged = names.map((name, idx) => {
          const code = codes[idx] || "";
          if (name === "#unknown") return resolveRouteName(code, code || "#unknown");
          const resolved = resolveRouteName(code, name);
          return code ? `${resolved} (${code})` : resolved;
        });
        return merged.join(" > ");
      }
      if (codes.length) return codes.join(" > ");
      return "--";
    }

    function renderRfList() {
      const list = document.getElementById("rfList");
      if (!list) return;
      const search = document.getElementById("rfSearch")?.value?.trim().toLowerCase() || "";
      const typeFilter = document.getElementById("rfTypeFilter")?.value || "";
      const filtered = appData.rfPackets.filter((p) => {
        if (typeFilter && p.payloadType !== typeFilter) return false;
        if (!search) return true;
        const hay = [
          p.hash,
          p.fp,
          p.senderPublicKey,
          p.destinationHash,
          p.channelHash,
          p.channelName,
          p.routeTypeName,
          ...(p.path || []),
          ...(p.pathNames || [])
        ].filter(Boolean).join(" ").toLowerCase();
        return hay.includes(search);
      });
      list.innerHTML = "";
      document.getElementById("rfCount").textContent = `${filtered.length} packets`;
      const total = appData.rfPackets.length;
      const ok = appData.rfPackets.filter((p) => p.crc === true).length;
      const bad = appData.rfPackets.filter((p) => p.crc === false).length;
      const typeCounts = {};
      appData.rfPackets.forEach((p) => {
        const t = p.payloadType || "Unknown";
        typeCounts[t] = (typeCounts[t] || 0) + 1;
      });
      const topType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "--";
      document.getElementById("rfTotal").textContent = total;
      document.getElementById("rfOk").textContent = ok;
      document.getElementById("rfBad").textContent = bad;
      document.getElementById("rfTopType").textContent = topType;
      const slice = filtered.slice(-150).reverse();
      const frag = document.createDocumentFragment();
      const header = document.createElement("div");
      header.className = "rf-row rf-header";
        header.innerHTML = `
          <div>Time</div>
          <div>Type</div>
          <div>Route</div>
          <div>Hash</div>
          <div>Path</div>
          <div>Sender</div>
          <div>Observers</div>
          <div>RSSI</div>
          <div>SNR</div>
          <div>Len</div>
          <div>CRC</div>
          <div>Edit</div>
        `;
      frag.appendChild(header);
      slice.forEach((p) => {
        const row = document.createElement("div");
        row.className = "rf-row";
        const time = p.ts ? new Date(p.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" }) : "--";
        const hash = shortHex(p.hash || p.fp || "--", 10);
        const route = p.routeTypeName || "--";
        const pathLabel = formatPathLabel(p);
        const sender = p.senderName || (p.senderPublicKey ? shortHex(p.senderPublicKey, 12) : "--");
        row.innerHTML = `
          <div>${time}</div>
          <div><span class="rf-type">${p.payloadType || "Unknown"}</span></div>
          <div>${route}</div>
          <div>${hash}</div>
          <div title="${pathLabel}">${pathLabel}</div>
          <div>${sender}</div>
          <div>${p.observerCount ?? 1}</div>
          <div>${Number.isFinite(p.rssi) ? p.rssi : "--"}</div>
          <div>${Number.isFinite(p.snr) ? p.snr : "--"}</div>
          <div>${p.len ?? "--"}</div>
          <div>${p.crc === true ? "CRC" : p.crc === false ? "BAD" : "--"}</div>
          <div><button class="link-btn rf-edit" type="button">Edit</button></div>
        `;
        row.addEventListener("click", () => {
          appData.rfSelected = p;
          renderRfDetail();
        });
        row.querySelector(".rf-edit")?.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          appData.routeActiveId = p.hash || null;
          appData.routeActiveMsg = {
            id: p.hash || "--",
            path: Array.isArray(p.path) ? p.path : [],
            pathNames: Array.isArray(p.pathNames) ? p.pathNames : []
          };
          appData.routeActivePathCodes = Array.isArray(p.path) ? p.path.slice() : [];
          appData.routeActivePathPoints = [];
          await ensureRouteSuggestions();
          openRouteOverrideModal();
        });
        frag.appendChild(row);
      });
      list.appendChild(frag);
    }

    function renderRfDetail() {
      const detail = document.getElementById("rfDetail");
      if (!detail) return;
      const p = appData.rfSelected;
      if (!p) {
        detail.innerHTML = `<div class="rf-kv">Select a packet to inspect its payload.</div>`;
        return;
      }
      const pathLabel = formatPathLabel(p);
      const sender = p.senderName || p.senderPublicKey || "--";
      const channelLabel = p.channelName ? `${p.channelName} (${p.channelHash || "--"})` : (p.channelHash || "--");
      const appFlags = Number.isFinite(p.appFlags) ? `0x${p.appFlags.toString(16).toUpperCase().padStart(2, "0")}` : "--";
      const observerNames = Array.isArray(p.observerHits) && p.observerHits.length
        ? p.observerHits.join(", ")
        : (p.observerName || "--");
      detail.innerHTML = `
        <div class="rf-kv"><strong>Packet</strong></div>
        <div class="rf-kv">Type: ${p.payloadType || "Unknown"}</div>
        <div class="rf-kv">Route: ${p.routeTypeName || "--"}</div>
        <div class="rf-kv">Hash: ${(p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Full hash: ${(p.frameHash || p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Time: ${p.ts ? new Date(p.ts).toLocaleString() : "--"}</div>
        <div class="rf-kv">RSSI/SNR: ${Number.isFinite(p.rssi) ? p.rssi : "--"} / ${Number.isFinite(p.snr) ? p.snr : "--"}</div>
        <div class="rf-kv">CRC: ${p.crc === true ? "ok" : p.crc === false ? "fail" : "unknown"}</div>
        <div class="rf-kv">Length: ${p.len ?? "--"}</div>
        <div class="rf-kv">Observers: ${observerNames}</div>
        <div class="rf-kv">Fingerprint: ${p.fp || "--"}</div>
        <div class="rf-kv">Sender: ${sender}</div>
        <div class="rf-kv">Destination: ${p.destinationHash || "--"}</div>
        <div class="rf-kv">Channel: ${channelLabel}</div>
        <div class="rf-kv">Path (${p.pathLength ?? 0} hops): ${pathLabel}</div>
        <div class="rf-kv">Advert name: ${p.advertName || "--"}</div>
        <div class="rf-kv">App flags: ${appFlags}</div>
        <div class="rf-kv">Payload bytes: ${p.payloadBytes ?? "--"}</div>
        <div class="rf-kv">Decrypted: ${p.decrypted === true ? "yes" : "no"}</div>
        <div class="rf-kv">Valid: ${p.isValid === true ? "yes" : p.isValid === false ? "no" : "unknown"}</div>
      `;
    }

    function renderMeshScore(data, rangeDays) {
      if (!data) return;
      appData.meshScore = data;
      document.getElementById("meshUpdated").textContent = new Date(data.updatedAt).toLocaleTimeString();
      document.getElementById("meshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("meshYesterday").textContent = data.scores?.yesterday ?? 0;
      document.getElementById("meshDelta").textContent = data.scores?.delta ?? 0;
      document.getElementById("meshMessages").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshDevices").textContent = data.totals?.devices ?? 0;
      document.getElementById("meshRepeaters").textContent = data.totals?.activeRepeaters ?? 0;
      document.getElementById("meshRooms").textContent = data.totals?.roomServers ?? 0;
      document.getElementById("meshChat").textContent = data.totals?.chatNodes ?? 0;
      document.getElementById("meshCompanions").textContent = data.totals?.companions ?? 0;
      document.getElementById("meshMsgsToday").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshMsgsObserver").textContent = data.messages?.observerToday ?? 0;

      const series = data.series || [];
      const days = rangeDays || 7;
      const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const filtered = series.filter((s) => new Date(s.date) >= cutoff);
      const points = filtered.map((s, idx) => {
        const x = (idx / Math.max(1, filtered.length - 1)) * 580 + 10;
        const y = 200 - (Math.max(0, Math.min(100, s.score)) / 100) * 160;
        return `${x},${y}`;
      });
      const line = document.getElementById("meshLine");
      const area = document.getElementById("meshArea");
      if (points.length) {
        line.setAttribute("points", points.join(" "));
        const areaPoints = [`10,200`, ...points, `590,200`];
        area.setAttribute("points", areaPoints.join(" "));
      } else {
        line.setAttribute("points", "");
        area.setAttribute("points", "");
      }

      document.getElementById("rankMeshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("rankMeshYesterday").textContent = data.scores?.yesterday ?? 0;
    }

    function renderRank(data) {
      renderRankWithOptions(data, { preserveView: true });
    }

    function scrollRankItemToTop(pub) {
      if (!pub) return;
      const list = document.getElementById("rankList");
      const scroll = document.getElementById("rankScroll");
      const item = document.querySelector(`.rank-item[data-pub="${String(pub).toUpperCase()}"]`);
      if (!list || !scroll || !item) return;
      scroll.scrollTop = item.offsetTop - scroll.offsetTop;
    }

    function renderRankWithOptions(data, options) {
      const opts = options || {};
      appData.rankData = data;
      appData.repeatersByCode = buildRepeatersByCode(data);
      const list = document.getElementById("rankList");
      list.innerHTML = "";
      rankLayer.clearLayers();
      rankMarkers = new Map();

      document.getElementById("rankUpdated").textContent = formatDateTime(data.updatedAt);
      document.getElementById("rankTotal").textContent = data.items.length;
      const activeCount = data.items.filter((r) => !r.stale).length;
      document.getElementById("rankActive").textContent = activeCount;
      if (appData.meshScore) {
        document.getElementById("rankMeshToday").textContent = appData.meshScore.scores?.today ?? 0;
        document.getElementById("rankMeshYesterday").textContent = appData.meshScore.scores?.yesterday ?? 0;
      }

      const needle = (appData.rankFilter || "").toLowerCase();
      const sorted = [...data.items]
        .sort((a, b) => (b.score || 0) - (a.score || 0))
        .filter((r) => {
          if (!needle) return true;
          const name = String(r.name || "").toLowerCase();
          const pub = String(r.pub || "").toLowerCase();
          const code = String(r.hashByte || "").toLowerCase();
          return name.includes(needle) || pub.includes(needle) || code.includes(needle);
        });
        const nearestObserverSet = buildNearestObserverRepeaters(sorted, appData.observerRank?.items || []);
        sorted.forEach((r) => {
          const item = document.createElement("div");
          const isHidden = isRepeaterHidden(r);
          const hiddenLabel = r.stale ? "Stale repeater" : "GPS unreliable";
          const badges = buildRepeaterBadges(r, nearestObserverSet);
          item.className = "rank-item" + (isHidden ? " hidden" : "");
          item.dataset.pub = (r.pub || "").toUpperCase();
          const observerBadge = r.isObserver ? `<div class="row"><span class="badge">Observer</span></div>` : "";
          const code = r.hashByte ? `<span class="chip" style="margin-left:6px;">${r.hashByte}</span>` : "";
            const scoreBadge = String(Math.round(r.score || 0)).padStart(2, "0");
            item.innerHTML = `
              <div class="score">
                <span class="rank-dot" style="background:${r.color}">${scoreBadge}</span>
                ${r.name} ${code}
              </div>
            <div class="row">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
            <div class="row">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
            <div class="row">Zero-hop neighbors (24h): ${r.zeroHopNeighbors24h ?? 0}${(r.zeroHopNeighbors24h ?? 0) >= 3 && Array.isArray(r.zeroHopNeighborNames) && r.zeroHopNeighborNames.length ? `  ${r.zeroHopNeighborNames.slice(0, 5).join(", ")}${r.zeroHopNeighborNames.length > 5 ? ` +${r.zeroHopNeighborNames.length - 5}` : ""}` : ""}</div>
            <div class="row">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
            <div class="row">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
            ${badgeHtml(badges)}
              ${isHidden ? `<div class="row"><span class="badge">${hiddenLabel}</span></div>` : ""}
            ${observerBadge}
          `;
        item.addEventListener("click", () => {
          openRankPopup(r, false);
        });
        list.appendChild(item);

        if (!isHidden && r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon)) {
          const marker = L.circleMarker([r.gps.lat, r.gps.lon], {
            radius: 8,
            color: r.color,
            fillColor: r.color,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(buildRankPopupHtml(r)).addTo(rankLayer)
            .on("click", () => openRankPopup(r, true));
          if (r.pub) rankMarkers.set(r.pub, marker);
        }
      });

      if (!opts.preserveView && sorted.length) {
        const bounds = sorted
          .filter((r) => {
            if (isRepeaterHidden(r)) return false;
            return r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon);
          })
          .map((r) => [r.gps.lat, r.gps.lon]);
        if (bounds.length) rankMap.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    function buildRankPopupHtml(r) {
      const impact = Math.min(100, Math.max(0, r.score || 0));
      const code = r.hashByte ? ` <span class="chip">${r.hashByte}</span>` : "";
      return `
        <div style="min-width:220px;font-family:'Space Grotesk',system-ui,sans-serif;">
          <div style="font-weight:700;margin-bottom:6px;">${r.name}${code}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);">Score: <strong>${r.score}</strong> | ${r.stale ? "stale" : "active"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Zero-hop neighbors (24h): ${r.zeroHopNeighbors24h ?? 0}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
          <div style="margin-top:8px;font-size:12px;color:rgba(60,60,67,0.6);">Network impact</div>
          <div style="height:8px;border-radius:999px;background:rgba(0,122,255,0.12);overflow:hidden;">
            <div style="height:100%;width:${impact}%;background:linear-gradient(90deg,#34c759,#007aff);"></div>
          </div>
        </div>
      `;
    }

    function openRankPopup(r, skipPan) {
      if (!r) return;
      const list = document.getElementById("rankList");
      const listItem = document.querySelector(`.rank-item[data-pub="${(r.pub || "").toUpperCase()}"]`);
      document.querySelectorAll(".rank-item.focused").forEach((el) => el.classList.remove("focused"));
      if (listItem) {
        listItem.classList.add("focused");
        if (list && list.firstChild !== listItem) {
          list.prepend(listItem);
        }
        listItem.scrollIntoView({ block: "start", behavior: "smooth" });
      }
      const lat = r.gps?.lat;
      const lon = r.gps?.lon;
      const hasGps = Number.isFinite(lat) && Number.isFinite(lon);
      const marker = r.pub ? rankMarkers.get(r.pub) : null;
      const html = buildRankPopupHtml(r);

      if (marker) {
        marker.setPopupContent(html);
        marker.openPopup();
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView(marker.getLatLng(), targetZoom, { animate: true });
        }
        return;
      }

      if (hasGps) {
        const popup = L.popup({ closeButton: true, autoClose: true })
          .setLatLng([lat, lon])
          .setContent(html)
          .openOn(rankMap);
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView([lat, lon], targetZoom, { animate: true });
        }
      }
    }


    const navLinks = document.querySelectorAll(".nav a, .mobile-nav a, .mobile-menu a");
    const menuToggle = document.getElementById("menuToggle");
    const menuBackdrop = document.getElementById("menuBackdrop");
    const channelToggles = document.querySelectorAll("[data-channels-toggle]");
    const closeMenu = () => {
      document.body.classList.remove("menu-open-left", "menu-open-right");
    };
    menuToggle?.addEventListener("click", () => {
      document.body.classList.toggle("menu-open-right");
      document.body.classList.remove("menu-open-left");
    });
    menuBackdrop?.addEventListener("click", closeMenu);
    channelToggles.forEach((toggle) => {
      toggle.addEventListener("click", () => {
        document.body.classList.toggle("menu-open-left");
        document.body.classList.remove("menu-open-right");
      });
    });
    navLinks.forEach((link) => {
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          document.body.classList.remove("route-open");
          navLinks.forEach((l) => l.classList.remove("active"));
          navLinks.forEach((l) => {
            if (l.dataset.view === link.dataset.view) l.classList.add("active");
          });
          closeMenu();
          const view = link.dataset.view;
          document.body.classList.toggle("view-channels", view === "channels");
          document.body.classList.toggle("view-rank", view === "rank");
          document.body.classList.toggle("view-meshscore", view === "meshscore");
          document.body.classList.toggle("view-rf", view === "rf");
          document.body.classList.toggle("view-observer", view === "observer");
          document.body.classList.toggle("view-observer-rank", view === "observer-rank");
          document.body.classList.toggle("view-why", view === "why");

        if (view === "rank") {
          if (!rankMap) initRankMap();
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
            const data = await fetchRank();
            renderRank(data);
          } catch (err) {
            const list = document.getElementById("rankList");
            list.innerHTML = "<div class='rank-item'>No repeaters yet.</div>";
          }
        }

        if (view === "meshscore") {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        }

        if (view === "rf") {
          try {
            const payload = await fetchRfLatest();
            const items = payload.items || [];
            const last = items[items.length - 1];
            const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
            if (sig !== appData.rfLastSig) {
              appData.rfLastSig = sig;
              appData.rfPackets = items;
              document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
              renderRfList();
            }
          } catch {}
        }

        if (view === "observer") {
          if (!observerMap) initObserverMap();
          if (observerMap) {
            setTimeout(() => observerMap.invalidateSize(), 80);
          }
        }
        if (view === "observer-rank") {
          if (!observerRankMap) initObserverRankMap();
          if (observerRankMap) {
            setTimeout(() => observerRankMap.invalidateSize(), 80);
          }
          try {
            const data = await fetchObserverRank();
            appData.observerRank = data;
            renderObserverRank(data);
            renderObserverRankMap(data);
          } catch {}
        }
        if (view === "why") {
          // static content
        }
      });
    });

    document.getElementById("observerRankSearch")?.addEventListener("input", () => {
      if (!appData.observerRank) return;
      renderObserverRank(appData.observerRank);
      renderObserverRankMap(appData.observerRank);
    });

    function buildObserverEnvSnippet() {
      const ssid = (document.getElementById("observerWifi")?.value || "").trim();
      const pass = (document.getElementById("observerPass")?.value || "").trim();
      const name = (document.getElementById("observerName")?.value || "").trim();
      const lines = [
        `wifi.ssid ${ssid || "YOUR_WIFI_SSID"}`,
        `wifi.pass ${pass || "YOUR_WIFI_PASSWORD"}`,
        `observer.name ${name || "Observer"}`,
        "status"
      ];
      return lines.join("\n");
    }

    function copyText(text) {
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          alert("Config copied to clipboard.");
        }).catch(() => {
          alert(text);
        });
        return;
      }
      alert(text);
    }

    function setObserverStatus(text, isError) {
      const el = document.getElementById("observerStatus");
      if (!el) return;
      el.textContent = text;
      el.style.color = isError ? "#ff3b30" : "var(--muted)";
    }

    let observerAutoConfig = false;

    function concatUint8(chunks) {
      const total = chunks.reduce((sum, c) => sum + c.length, 0);
      const out = new Uint8Array(total);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.length;
      }
      return out;
    }

    async function readSerialOnce(port, timeoutMs) {
      if (!port.readable) return "";
      const reader = port.readable.getReader();
      const chunks = [];
      let timedOut = false;
      const timer = setTimeout(() => {
        timedOut = true;
        reader.cancel().catch(() => {});
      }, timeoutMs);
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) chunks.push(value);
        }
      } catch {
      } finally {
        clearTimeout(timer);
        reader.releaseLock();
      }
      if (!chunks.length) return timedOut ? "" : "";
      const bytes = concatUint8(chunks);
      return new TextDecoder().decode(bytes);
    }

      async function sendObserverConfig() {
        if (!navigator.serial) {
          setObserverStatus("WebSerial not available in this browser.", true);
          alert("WebSerial not available. Use Chrome/Edge over HTTPS.");
          return;
        }
        const ssidValue = (document.getElementById("observerWifi")?.value || "").trim();
        if (!ssidValue) {
          const msg = "Wi-Fi SSID is required before sending config.";
          setObserverStatus(msg, true);
          alert(msg);
          return;
        }
        const payloadLines = buildObserverEnvSnippet().split("\n").filter(Boolean);
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Select the observer serial port to send Wi-Fi config...";
          logEl.classList.add("active");
        }
        setObserverStatus("Waiting for serial port selection...", false);
        let port;
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          const writer = port.writable.getWriter();
          for (const line of payloadLines) {
            await writer.write(new TextEncoder().encode(line + "\r\n"));
            await new Promise((r) => setTimeout(r, 40));
          }
          writer.releaseLock();
          const reply = await readSerialOnce(port, 2000);
          if (reply && logEl) {
            logEl.textContent += "\nDevice replied:\n" + reply.trim();
          } else if (logEl) {
            logEl.textContent += "\nNo device reply detected. Check the serial port and power.";
          }
          await port.close();
          if (logEl) {
            logEl.textContent += "\nWi-Fi config sent. Device will reconnect using new settings.";
          }
        setObserverStatus("Wi-Fi config sent. Device will reconnect using new settings.", false);
        alert("Wi-Fi config sent.");
      } catch (err) {
        if (port && port.readable) {
          try { await port.close(); } catch {}
        }
        const msg = "Failed to send config: " + (err?.message || err);
        if (logEl) {
          logEl.textContent += "\n" + msg;
          logEl.classList.add("active");
        }
        setObserverStatus(msg, true);
        alert(msg);
      }
    }

    const observerSendBtn = document.getElementById("observerSendConfig");
    if (observerSendBtn) {
      observerSendBtn.addEventListener("click", () => {
        sendObserverConfig();
      });
    }

    function wireInstallLogging(button, verbose) {
      if (!button) return;
      const logEl = document.getElementById("installLog");
      const append = (msg) => {
        if (!logEl) return;
        logEl.classList.toggle("active", !!verbose);
        if (!verbose) return;
        const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logEl.textContent = (logEl.textContent || "").trim();
        logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + line;
        logEl.scrollTop = logEl.scrollHeight;
      };

      button.addEventListener("state-changed", (ev) => {
        const rawState = ev.detail?.state || "unknown";
        append(`state ${rawState}`);
        const state = String(rawState).toLowerCase();
        const isDone = ["finished", "installed", "done"].includes(state);
        if (observerAutoConfig && isDone) {
          observerAutoConfig = false;
          sendObserverConfig();
        }
      });
      button.addEventListener("log", (ev) => {
        append(ev.detail?.message || "log event");
      });
      button.addEventListener("error", (ev) => {
        append(`error ${ev.detail?.message || "unknown"}`);
      });
      button.addEventListener("click", () => {
        observerAutoConfig = true;
        if (logEl) {
          logEl.textContent = verbose ? "Verbose install log started..." : "Verbose install log ready.";
          logEl.classList.toggle("active", !!verbose);
        }
      });
    }

    wireInstallLogging(document.getElementById("observerFlash"), false);
    wireInstallLogging(document.getElementById("observerFlashVerbose"), true);

    const FLASH_BIN_URL = "/observer-merged-1.1.8.bin";
    const flashOpen = document.getElementById("observerFlashLink");
    const flashHide = document.getElementById("flashHide");
    const flashStart = document.getElementById("flashStart");
    const flashLog = document.getElementById("flashLog");
    const flashPanel = document.getElementById("flashPanel");

    function setFlashLog(msg) {
      flashLog.textContent = msg;
    }

    function appendFlashLog(line) {
      flashLog.textContent += `\n${line}`;
      flashLog.scrollTop = flashLog.scrollHeight;
    }

    function openFlashPanel() {
      flashPanel.classList.add("open");
      setFlashLog("Ready to flash.");
    }

    function closeFlashPanel() {
      flashPanel.classList.remove("open");
    }

    flashOpen?.addEventListener("click", openFlashPanel);
    flashHide?.addEventListener("click", closeFlashPanel);

    flashStart?.addEventListener("click", async () => {
      if (!navigator.serial) {
        setFlashLog("WebSerial is not supported in this browser. Use Chrome or Edge.");
        return;
      }

      flashStart.disabled = true;
      flashHide.disabled = true;
      setFlashLog("Downloading firmware...");

      try {
        const res = await fetch(FLASH_BIN_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`download failed (${res.status})`);
        const bin = new Uint8Array(await res.arrayBuffer());
        appendFlashLog(`Downloaded ${bin.byteLength} bytes.`);
        appendFlashLog("Preparing firmware...");
        appendFlashLog(`Firmware header: 0x${bin[0]?.toString(16).padStart(2, "0")}`);
        if (bin[0] === 0xe9) {
          const oldMode = bin[2];
          const oldFreqSize = bin[3];
          const newMode = 0x02; // DIO
          const newFreqSize = (oldFreqSize & 0xf0) | 0x00; // 40MHz
          if (oldMode !== newMode || oldFreqSize !== newFreqSize) {
            bin[2] = newMode;
            bin[3] = newFreqSize;
            appendFlashLog(`Patched header: mode 0x${oldMode.toString(16)}->0x${newMode.toString(16)}, freq 0x${oldFreqSize.toString(16)}->0x${newFreqSize.toString(16)}`);
          } else {
            appendFlashLog("Header already set for DIO/40MHz.");
          }
        }
        let binStr = "";
        for (let i = 0; i < bin.length; i++) {
          binStr += String.fromCharCode(bin[i]);
        }

        appendFlashLog("Requesting serial port...");
        const port = await navigator.serial.requestPort();
        appendFlashLog("Connecting to device...");

        let esptool;
        try {
          esptool = await import("/esp32.js");
        } catch (err) {
          try {
            esptool = await import("https://unpkg.com/esptool-js@0.5.4/bundle.js");
          } catch (err2) {
            esptool = await import("https://cdn.jsdelivr.net/npm/esptool-js@0.5.4/bundle.js");
          }
        }
        const transport = new esptool.Transport(port, true);
        const flashOptions = {
          transport,
          baudrate: 115200,
          romBaudrate: 115200,
          terminal: {
            clean: () => {},
            writeLine: appendFlashLog,
            write: (data) => appendFlashLog(String(data || "").trimEnd())
          },
          fileArray: [{ data: binStr, address: 0x0 }],
          flashSize: "keep",
          flashMode: "keep",
          flashFreq: "keep",
          compress: true
        };
        const loader = new esptool.ESPLoader(flashOptions);
        try {
          loader.hr = new esptool.HardReset(transport);
        } catch {}

        await loader.main();
        try {
          await loader.flashId?.();
        } catch {}
        try {
          if (typeof loader.chipName === "function") {
            appendFlashLog(`Chip: ${loader.chipName()}`);
          }
        } catch {}
        appendFlashLog("Erasing flash...");
        await loader.eraseFlash();
        appendFlashLog("Writing firmware...");

        await loader.writeFlash(flashOptions);

        appendFlashLog("Verifying header...");
        try {
          const verify = await loader.readFlash(0x0, 16);
          let ok = verify.length === 16;
          let mismatchAt = -1;
          for (let i = 0; i < 16 && ok; i++) {
            if (verify[i] !== bin[i]) {
              ok = false;
              mismatchAt = i;
            }
          }
          if (ok) {
            appendFlashLog("Header verify OK.");
          } else {
            const got = Array.from(verify).map((b) => b.toString(16).padStart(2, "0")).join("");
            const want = Array.from(bin.slice(0, 16)).map((b) => b.toString(16).padStart(2, "0")).join("");
            appendFlashLog(`Header verify mismatch at byte ${mismatchAt}: got 0x${got}, expected 0x${want}`);
          }
        } catch (err) {
          appendFlashLog(`Header verify failed: ${err?.message || err}`);
        }

        appendFlashLog("Flash complete. Rebooting...");
        try {
          await loader.after?.("hard_reset");
        } catch {}
        try {
          await transport.setRTS(true);
          await new Promise((resolve) => setTimeout(resolve, 100));
          await transport.setRTS(false);
        } catch {}
        await transport.disconnect();
        appendFlashLog("Done. You can now send Wi-Fi config.");
      } catch (err) {
        appendFlashLog(`Error: ${err?.message || err}`);
      } finally {
        flashStart.disabled = false;
        flashHide.disabled = false;
      }
    });

    const observerFlashBtn = document.getElementById("observerFlashBtn");
    const observerFlashVerboseBtn = document.getElementById("observerFlashVerboseBtn");
    const observerFlash = document.getElementById("observerFlash");
    const observerFlashVerbose = document.getElementById("observerFlashVerbose");

    if (observerFlashBtn && observerFlash) {
      observerFlashBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) logEl.classList.remove("active");
        observerFlash.click();
      });
    }

    if (observerFlashVerboseBtn && observerFlashVerbose) {
      observerFlashVerboseBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Verbose install log started...";
          logEl.classList.add("active");
        }
        observerFlashVerbose.click();
      });
    }

    const rangeTabs = document.getElementById("meshRangeTabs");
    if (rangeTabs) {
      rangeTabs.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-range]");
        if (!btn) return;
        rangeTabs.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        meshRangeDays = Number(btn.dataset.range || 7);
        if (!appData.meshScore) {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        } else {
          renderMeshScore(appData.meshScore, meshRangeDays);
        }
      });
    }

    function setServerStatus(ok) {
      const dot = document.getElementById("serverStatus");
      if (!dot) return;
      dot.classList.toggle("ok", !!ok);
    }

    const themeToggle = document.getElementById("themeToggle");
    const themeKey = "meshrank.theme";
    function applyTheme(theme) {
      const isDark = theme === "dark";
      document.body.classList.toggle("theme-dark", isDark);
      if (themeToggle) {
        themeToggle.setAttribute("aria-pressed", String(isDark));
        themeToggle.textContent = isDark ? "Light mode" : "Dark mode";
      }
    }
    const storedTheme = localStorage.getItem(themeKey);
    const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;
    applyTheme(storedTheme || (prefersDark ? "dark" : "light"));
    themeToggle?.addEventListener("click", () => {
      const nextTheme = document.body.classList.contains("theme-dark") ? "light" : "dark";
      localStorage.setItem(themeKey, nextTheme);
      applyTheme(nextTheme);
    });

    loadReadState();
    const rankSearch = document.getElementById("rankSearch");
    if (rankSearch) {
      rankSearch.addEventListener("input", () => {
        appData.rankFilter = rankSearch.value.trim();
        if (appData.rankData) {
          renderRankWithOptions(appData.rankData, { preserveView: true });
        }
      });
    }

    const rankList = document.getElementById("rankList");

    const rfSearch = document.getElementById("rfSearch");
    const rfTypeFilter = document.getElementById("rfTypeFilter");
    if (rfSearch) rfSearch.addEventListener("input", renderRfList);
    if (rfTypeFilter) rfTypeFilter.addEventListener("change", renderRfList);

    window.addEventListener("resize", () => {
      if (observerMap) observerMap.invalidateSize();
      if (rankMap) rankMap.invalidateSize();
    });
  </script>
</body>
</html>
