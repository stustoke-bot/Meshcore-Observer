<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MeshRank</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --ink: #0a0b0e;
      --paper: #f2f2f7;
      --panel: #ffffff;
      --line: rgba(60, 60, 67, 0.12);
      --blue: #007aff;
      --blue-dark: #0a60d1;
      --green: #34c759;
      --green-dark: #248a3d;
      --muted: rgba(60, 60, 67, 0.6);
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", system-ui, sans-serif;
      background:
        radial-gradient(1000px 520px at 85% -10%, rgba(0, 122, 255, 0.14) 0%, rgba(0, 122, 255, 0) 60%),
        radial-gradient(900px 520px at -10% 15%, rgba(52, 199, 89, 0.12) 0%, rgba(52, 199, 89, 0) 60%),
        var(--paper);
      color: var(--ink);
      height: 100vh;
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 280px 1fr 420px;
      gap: 16px;
      padding: 16px;
      height: 100vh;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .topbar {
      grid-column: 1 / -1;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      padding: 2px 12px;
      gap: 12px;
      min-height: 48px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      flex: 0 0 auto;
    }

    .brand-logo {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: block;
      overflow: hidden;
      border: none;
    }

    .brand-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display: block;
      min-width: 0;
    }

    .brand-text {
      display: grid;
      gap: 2px;
      line-height: 1.1;
    }

    .brand-text strong {
      font-size: 16px;
    }

    .brand-text span {
      font-size: 12px;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      background: #ff3b30;
      box-shadow: 0 0 0 4px rgba(255, 59, 48, 0.15);
    }

    .status-dot.ok {
      background: #34c759;
      box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.15);
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-weight: 600;
      color: var(--muted);
      margin-left: auto;
    }

    .nav a {
      color: inherit;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .nav a.active {
      color: var(--ink);
      background: rgba(0, 122, 255, 0.12);
    }

    .sidebar {
      padding: 14px 12px;
      gap: 10px;
    }

    .title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .title.column {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }

    .chip {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      font-weight: 600;
    }

    .btn {
      border: 1px solid var(--line);
      background: rgba(0, 122, 255, 0.1);
      color: var(--blue);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(0, 122, 255, 0.18);
    }

    .channel {
      display: grid;
      grid-template-columns: 44px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
    }

    .channel.active {
      background: #e8f0ff;
      border-color: rgba(11, 95, 255, 0.2);
    }

    .channel.unread .name {
      font-weight: 800;
    }

    .badge-bubble {
      min-width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #007aff;
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
    }

    .channel .name {
      font-weight: 700;
    }

    .channel .snippet {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .content {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .messages {
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow: auto;
    }

    .message {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      animation: slideIn 400ms ease-out;
    }

    .message .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .bubble {
      padding: 10px 14px;
      border-radius: 14px;
      max-width: 520px;
      color: #fff;
      font-weight: 500;
      line-height: 1.35;
      box-shadow: 0 10px 24px rgba(10, 11, 14, 0.16);
    }

    .bubble.mesh {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
    }

    .bubble.observer {
      background: linear-gradient(135deg, var(--green), var(--green-dark));
    }

    .bubble.mixed {
      background: linear-gradient(135deg, var(--blue), var(--blue-dark));
      outline: 2px solid var(--green);
    }

    .msg-footer {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .analyze {
      color: var(--blue);
      text-decoration: none;
      font-weight: 600;
    }

    .analyze:hover { text-decoration: underline; }

    .analysis {
      display: grid;
      grid-template-rows: 240px 1fr;
      min-height: 0;
    }

    .rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rank-body {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rank-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
    }

    .summary-card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #ffffff;
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .summary-card strong {
      font-size: 16px;
      color: var(--ink);
    }

    .rank-map {
      border-radius: 16px;
      border: 1px solid var(--line);
      overflow: hidden;
      min-height: 360px;
    }

    #rankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    #observerRankMap {
      width: 100%;
      height: 100%;
      min-height: 360px;
    }

    .rank-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      height: 100%;
    }

    .rank-search {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
      outline: none;
      box-shadow: 0 6px 16px rgba(10, 11, 14, 0.06);
      margin-bottom: 6px;
    }

    .rank-scroll {
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      flex: 1;
    }

    .rank-search::placeholder {
      color: rgba(60, 60, 67, 0.45);
    }

    .rank-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
      background: #fafafa;
    }


    .rank-item.hidden {
      opacity: 0.45;
      filter: grayscale(0.4);
    }

    .rank-item.focused {
      border-color: rgba(0, 122, 255, 0.4);
      background: rgba(0, 122, 255, 0.1);
      box-shadow: 0 10px 24px rgba(0, 122, 255, 0.18);
    }

    .rank-item .row {
      font-size: 12px;
      color: var(--muted);
    }

    .rank-item .score {
      font-weight: 700;
      font-size: 14px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .rank-dot {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: #fff;
    }

    .meshscore-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .rf-body {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
    }

    .rf-table {
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .rf-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #ffffff;
    }

    .rf-input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      font-family: "IBM Plex Mono", monospace;
    }

    .rf-list {
      overflow: auto;
      min-height: 0;
    }

    .rf-row {
      display: grid;
      grid-template-columns: 90px 110px 90px 140px minmax(160px, 2fr) 140px 60px 60px 60px 60px 70px;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 12px;
      cursor: pointer;
      align-items: center;
    }

    .rf-row:hover {
      background: #f7f7f7;
    }

    .rf-row.rf-header {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f4f6fb;
      font-weight: 700;
      color: #5b6b84;
      cursor: default;
    }

    .rf-type {
      font-weight: 700;
      color: #fff;
      border-radius: 8px;
      padding: 2px 6px;
      display: inline-flex;
      justify-content: center;
      background: #007aff;
      font-size: 11px;
    }

    .rf-detail {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      overflow: auto;
      min-height: 0;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .rf-summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
      font-size: 12px;
      color: var(--muted);
    }

    .rf-summary strong {
      display: block;
      color: var(--ink);
      font-size: 14px;
      margin-top: 2px;
    }

    .rf-hex {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      background: #f7f7f7;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      word-break: break-all;
    }

    .rf-kv {
      font-size: 12px;
      color: var(--muted);
      display: grid;
      gap: 4px;
    }

    .meshscore-body {
      padding: 16px;
      display: grid;
      gap: 16px;
      overflow: auto;
    }

    .meshscore-hero {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px 16px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .meshscore-cards {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .meshscore-chart {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: #ffffff;
      display: grid;
      gap: 10px;
    }

    .range-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .range-tabs button {
      border: 1px solid var(--line);
      background: #f7f7f7;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .range-tabs button.active {
      background: rgba(0, 122, 255, 0.12);
      color: var(--blue);
    }

    .meshscore-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    #routeMap {
      height: 100%;
      width: 100%;
      background: repeating-linear-gradient(
        135deg,
        rgba(10, 11, 14, 0.04),
        rgba(10, 11, 14, 0.04) 14px,
        transparent 14px,
        transparent 28px
      );
    }

    .analysis-body {
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }

    .modal.open {
      display: flex;
    }

    .modal-card {
      width: min(420px, 100%);
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 18px;
      display: grid;
      gap: 12px;
    }

    .route-modal-card {
      width: min(760px, 100%);
    }

    .route-override-list {
      display: grid;
      gap: 10px;
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
    }

    .route-override-row {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 8px;
    }

    .route-override-label {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .route-override-label strong {
      font-size: 13px;
      color: var(--ink);
    }

    .route-override-select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #ffffff;
    }

    .route-override-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .field {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .field input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 13px;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    body.view-channels .rank-panel,
    body.view-channels .meshscore-panel { display: none; }
    body.view-channels .sidebar-panel,
    body.view-channels .content,
    body.view-channels .analysis-panel { display: flex; }

    body.view-rank .sidebar-panel,
    body.view-rank .content,
    body.view-rank .analysis-panel,
    body.view-rank .meshscore-panel { display: none; }
    body.view-rank .rank-panel { display: flex; }

    body.view-meshscore .sidebar-panel,
    body.view-meshscore .content,
    body.view-meshscore .analysis-panel,
    body.view-meshscore .rank-panel { display: none; }
    body.view-meshscore .meshscore-panel { display: flex; }

    body.view-rf .sidebar-panel,
    body.view-rf .content,
    body.view-rf .analysis-panel,
    body.view-rf .rank-panel,
    body.view-rf .meshscore-panel { display: none; }
    body.view-rf .rf-panel { display: flex; }

    body.view-observer .sidebar-panel,
    body.view-observer .content,
    body.view-observer .analysis-panel,
    body.view-observer .rank-panel,
    body.view-observer .meshscore-panel,
    body.view-observer .rf-panel,
    body.view-observer .observer-rank-panel { display: none; }
    body.view-observer .observer-panel { display: flex; }
    body.view-why .sidebar-panel,
    body.view-why .content,
    body.view-why .analysis-panel,
    body.view-why .rank-panel,
    body.view-why .meshscore-panel,
    body.view-why .rf-panel,
    body.view-why .observer-panel,
    body.view-why .observer-rank-panel { display: none; }
    body.view-why .why-panel { display: flex; }

    body.view-observer-rank .sidebar-panel,
    body.view-observer-rank .content,
    body.view-observer-rank .analysis-panel,
    body.view-observer-rank .rank-panel,
    body.view-observer-rank .meshscore-panel,
    body.view-observer-rank .rf-panel,
    body.view-observer-rank .observer-panel { display: none; }
    body.view-observer-rank .observer-rank-panel { display: flex; }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .badge {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-weight: 600;
      color: var(--ink);
      background: #f7f7f7;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .badge.badge-green { background: rgba(52, 199, 89, 0.16); border-color: rgba(52, 199, 89, 0.28); color: #1b6b35; }
    .badge.badge-blue { background: rgba(0, 122, 255, 0.16); border-color: rgba(0, 122, 255, 0.28); color: #0a60d1; }
    .badge.badge-amber { background: rgba(255, 149, 0, 0.18); border-color: rgba(255, 149, 0, 0.28); color: #9a5b00; }
    .badge.badge-purple { background: rgba(88, 86, 214, 0.18); border-color: rgba(88, 86, 214, 0.28); color: #3b39a5; }
    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .list-item {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      background: #fafafa;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .channel-remove {
      border: 0;
      background: transparent;
      color: #ff3b30;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .slider {
      width: 100%;
    }

    .observer-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .observer-rank-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
    }

    .why-panel {
      grid-column: 1 / -1;
      display: none;
      min-height: 0;
      overflow: auto;
    }

    .why-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .why-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 18px;
      background: #ffffff;
      display: grid;
      gap: 14px;
      align-content: start;
    }

    .why-card h3 {
      margin: 0;
      font-size: 16px;
    }

    .why-card p {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--ink);
    }

    .faq-item strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .faq-item p {
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
    }

    .observer-body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      padding: 16px;
      min-height: 0;
      height: 100%;
      overflow: auto;
    }

    .observer-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 12px 14px;
      background: #ffffff;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .observer-right {
      display: grid;
      gap: 16px;
      align-content: start;
    }

    .observer-log {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .observer-steps {
      display: grid;
      gap: 8px;
    }

    .observer-step {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: #fafafa;
      display: grid;
      gap: 4px;
    }

    .observer-step strong {
      font-size: 13px;
    }

    .observer-grid {
      display: grid;
      gap: 8px;
    }

    .observer-grid label {
      font-size: 12px;
      color: var(--muted);
    }

    .observer-grid input,
    .observer-grid select {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
    }

    .observer-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .observer-map {
      width: 100%;
      height: 360px;
      border-radius: 16px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }

    .observer-map .leaflet-container {
      width: 100%;
      height: 100%;
    }

    .observer-legend {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }

    .observer-legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .observer-legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #34c759;
    }

    .observer-legend i.warn { background: #ff9500; }
    .observer-legend i.bad { background: #ff3b30; }

    .observer-status {
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }

    .link-btn {
      border: 0;
      background: transparent;
      color: var(--blue-dark);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      padding: 0;
    }

    .install-log {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #0b1120;
      color: #e2e8f0;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .install-log.active {
      display: block;
    }

    @keyframes slideIn {
      from { transform: translateY(8px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @media (max-width: 1200px) {
      .app { grid-template-columns: 240px 1fr; }
      .analysis-panel { display: none; }
    }

    @media (max-width: 860px) {
      body { height: auto; overflow: auto; }
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        height: auto;
        padding: 12px;
      }
      .topbar {
        height: auto;
        gap: 8px;
        padding: 8px 10px;
        min-height: 44px;
      }
      .brand-logo { width: 40px; height: 40px; }
      .nav { flex-wrap: wrap; gap: 8px; }
      .sidebar-panel { display: none; }
      .panel { min-height: auto; }
      .content { min-height: 50vh; }
      .messages { max-height: 60vh; }
      .analysis { grid-template-rows: 220px auto; }
      #routeMap { min-height: 220px; }
      .rank-body { grid-template-columns: 1fr; }
      .rank-map { min-height: 280px; }
      .rf-body { grid-template-columns: 1fr; }
      .rf-table { overflow-x: auto; }
      .rf-row { min-width: 760px; }
      .observer-body { grid-template-columns: 1fr; }
      .observer-map { height: 260px; }
      .observer-rank-body { grid-template-columns: 1fr; }
      .observer-rank-map { min-height: 280px; }
      .why-body { grid-template-columns: 1fr; }
      body.view-observer .observer-panel { display: none; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
        <div class="brand">
          <div class="brand-logo">
            <img src="/meshrank.png?v=1.1.2" alt="MeshRank logo"/>
          </div>
          <div class="brand-text">
            <strong>MeshRank.net</strong>
            <span>by G5AIL</span>
          </div>
        </div>
      <nav class="nav">
        <a href="#" class="active" data-view="channels">Channels</a>
        <a href="#" data-view="rank">Repeater Rank</a>
        <a href="#" data-view="meshscore">MeshRank</a>
        <a href="#" data-view="observer-rank">Observer Rank</a>
        <a href="#" data-view="rf">MeshFlow</a>
        <a href="#" data-view="why">Why MeshRank?</a>
        <a href="#" data-view="observer">Become an Observer</a>
      </nav>
    </header>

    <section class="panel sidebar-panel">
      <div class="title column">
        <span>Channels <span class="chip">UK Mesh</span></span>
        <button class="btn" id="addChannelBtn">Add Channel</button>
      </div>
      <div class="sidebar">
        <div id="channels"></div>
      </div>
    </section>

    <section class="panel content">
      <div class="title">Public <span class="chip" id="activeChannel">#public</span></div>
      <div class="messages" id="messages"></div>
    </section>

    <section class="panel analysis-panel">
      <div class="title">Route Path <span class="chip" id="routeKey">none</span></div>
      <div class="analysis">
        <div id="routeMap"></div>
        <div class="analysis-body">
          <div class="row"><span>Message key</span><span id="routeMessage">-</span></div>
          <div class="row"><span>Source</span><span id="routeSource">-</span></div>
          <div class="row"><span>Confidence</span><span id="routeConfidence">-</span></div>
          <div class="row"><span>Path depth</span><span id="routeDepth">-</span></div>

          <input id="depthSlider" class="slider" type="range" min="1" max="16" value="8"/>

          <div class="row"><span>Packets heard</span><span class="badge" id="routeCount">0</span></div>
          <div class="list" id="routeList"></div>
          <div style="display:flex;align-items:center;gap:8px;">
            <button class="link-btn" id="routeOverrideBtn" type="button">Route path wrong?</button>
            <span style="font-size:12px;color:var(--muted);">Suggest a correction for a 2-digit code.</span>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rank-panel">
      <div class="title">Repeater Rank <span class="chip" id="rankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total repeaters</div>
          <strong id="rankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (24h)</div>
          <strong id="rankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>MeshRank today</div>
          <strong id="rankMeshToday">0</strong>
          <div style="font-size:11px;color:var(--muted);">Yesterday: <span id="rankMeshYesterday">0</span></div>
        </div>
      </div>
      <div class="rank-body">
        <div class="rank-map">
          <div id="rankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="rankSearch" type="text" placeholder="Search repeaters"/>
          <div class="rank-scroll" id="rankScroll">
            <div id="rankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel meshscore-panel">
      <div class="title">MeshRank <span class="chip" id="meshUpdated">--</span></div>
      <div class="meshscore-body">
        <div class="meshscore-hero">
          <div style="font-weight:700;">MeshRank tracks network health using active repeaters, message volume, and repeat reliability.</div>
          <div style="font-size:12px;color:var(--muted);">Scores update from live RF logs and decoded mesh traffic. Higher scores mean wider coverage, better repeat density, and more reliable delivery.</div>
        </div>
        <div class="meshscore-cards">
          <div class="summary-card">
            <div>MeshRank today</div>
            <strong id="meshToday">0</strong>
          </div>
          <div class="summary-card">
            <div>MeshRank yesterday</div>
            <strong id="meshYesterday">0</strong>
          </div>
          <div class="summary-card">
            <div>Change</div>
            <strong id="meshDelta">0</strong>
          </div>
          <div class="summary-card">
            <div>Messages (24h)</div>
            <strong id="meshMessages">0</strong>
          </div>
        </div>
        <div class="meshscore-chart">
          <div class="range-tabs" id="meshRangeTabs">
            <button data-range="7" class="active">7d</button>
            <button data-range="30">30d</button>
            <button data-range="90">90d</button>
            <button data-range="365">1y</button>
          </div>
          <svg id="meshChart" viewBox="0 0 600 220" width="100%" height="220" style="background:#f7f7f7;border-radius:12px;">
            <polyline id="meshLine" fill="none" stroke="#007aff" stroke-width="3" points=""></polyline>
            <polyline id="meshArea" fill="rgba(0,122,255,0.12)" stroke="none" points=""></polyline>
          </svg>
        </div>
        <div class="meshscore-grid">
          <div class="summary-card">
            <div>Total devices</div>
            <strong id="meshDevices">0</strong>
          </div>
          <div class="summary-card">
            <div>Repeaters active</div>
            <strong id="meshRepeaters">0</strong>
          </div>
          <div class="summary-card">
            <div>Room servers</div>
            <strong id="meshRooms">0</strong>
          </div>
          <div class="summary-card">
            <div>Chat nodes</div>
            <strong id="meshChat">0</strong>
          </div>
          <div class="summary-card">
            <div>Companion nodes</div>
            <strong id="meshCompanions">0</strong>
          </div>
          <div class="summary-card">
            <div>Mesh msgs today</div>
            <strong id="meshMsgsToday">0</strong>
          </div>
          <div class="summary-card">
            <div>Observer msgs today</div>
            <strong id="meshMsgsObserver">0</strong>
          </div>
        </div>
      </div>
    </section>

    <section class="panel rf-panel">
      <div class="title">MeshFlow <span class="chip" id="rfCount">0 packets</span></div>
      <div class="rf-body">
        <div class="rf-table">
          <div class="rf-controls">
            <input class="rf-input" id="rfSearch" type="text" placeholder="Search hash or hex"/>
            <select class="rf-input" id="rfTypeFilter">
              <option value="">All types</option>
              <option value="Advert">Advert</option>
              <option value="GroupText">GroupText</option>
              <option value="Request">Request</option>
              <option value="Response">Response</option>
              <option value="Path">Path</option>
              <option value="Ack">Ack</option>
            </select>
            <span class="chip" id="rfUpdated">--</span>
          </div>
          <div class="rf-summary">
            <div>Total packets<strong id="rfTotal">0</strong></div>
            <div>CRC ok<strong id="rfOk">0</strong></div>
            <div>CRC bad<strong id="rfBad">0</strong></div>
            <div>Top type<strong id="rfTopType">--</strong></div>
          </div>
          <div class="rf-list" id="rfList"></div>
        </div>
        <div class="rf-detail" id="rfDetail">
          <div class="rf-kv">Select a packet to inspect its payload.</div>
        </div>
      </div>
    </section>

    <section class="panel observer-panel">
      <div class="title">Become an Observer <span class="chip">Quick setup</span></div>
      <div class="observer-body">
          <div class="observer-card">
            <div style="font-weight:700;">Bring your observer online</div>
            <div style="font-size:12px;color:var(--muted);line-height:1.5;">
              Observer Nodes listen silently and relay RF traffic to MeshRank without stressing repeaters.
              Place it where Wi-Fi and RF are strong. Firmware is Heltec V3 only.
            </div>
            <div class="observer-steps">
              <div class="observer-step"><strong>1</strong> Plug in your Heltec V3 in DFU mode.</div>
              <div class="observer-step">
                <strong>2</strong> Download the latest observer firmware.
                <div class="observer-actions">
                  <a class="btn" id="observerBinLink" href="/observer-merged.bin?v=1.1.1" target="_blank" rel="noopener">Download observer .bin</a>
                </div>
              </div>
              <div class="observer-step">
                <strong>3</strong> Flash the firmware via MeshCore flasher.
                <div class="observer-actions">
                  <a class="btn" id="observerFlashLink" href="https://flasher.meshcore.co.uk/?manifest=https://meshrank.net/observer-manifest.json" target="_blank" rel="noopener">Open MeshCore Flasher</a>
                </div>
                <div style="font-size:12px;color:var(--muted);">Scroll to Custom Firmware, select the .bin, enable Erase, flash, then press RST.</div>
              </div>
              <div class="observer-step">
                <strong>4</strong> Enter your Wi-Fi credentials and click send, then reboot the node.
                <div class="observer-grid">
                  <div>
                    <label for="observerName">Observer name</label>
                    <input id="observerName" type="text" placeholder="Observer name"/>
                  </div>
                  <div>
                    <label for="observerWifi">Wi-Fi SSID</label>
                    <input id="observerWifi" type="text" placeholder="MyWiFi"/>
                  </div>
                  <div>
                    <label for="observerPass">Wi-Fi password</label>
                    <input id="observerPass" type="password" placeholder="password"/>
                  </div>
                </div>
                <div class="observer-actions">
                  <button class="btn" type="button" id="observerSendConfig">Send Wi-Fi config</button>
                </div>
              </div>
              <div class="observer-step"><strong>5</strong> If your node appears in Pending Observers, send a repeater advert to speed up geolocation.</div>
              <div class="observer-step"><strong>6</strong> Once validated, it moves to Observer Rank automatically.</div>
            </div>
          <div class="observer-status" id="observerStatus">Flash via MeshCore flasher, then send Wi-Fi config. MQTT is fixed to `meshrank.net:8883` TLS.</div>
          <div id="installLog" class="install-log">Verbose install log ready.</div>
          <div style="font-size:12px;color:var(--muted);">Location is estimated automatically from strong repeater signals.</div>
        </div>
        <div class="observer-right">
          <div class="observer-card">
            <div style="font-weight:700;">Current Observer Coverage</div>
            <div class="observer-legend">
              <span><i></i> Active &lt; 1h</span>
              <span><i class="warn"></i> Idle 1-24h</span>
              <span><i class="bad"></i> Idle 24-48h</span>
            </div>
            <div style="font-size:12px;color:var(--muted);">Location pending observers stay off the map until validated.</div>
            <div id="observerMap" class="observer-map"></div>
          </div>
          <div class="observer-card">
            <div style="font-weight:700;">Pending Observers</div>
            <div style="font-size:12px;color:var(--muted);">Only observers awaiting geolocation appear here.</div>
            <div id="observerList" class="rf-list"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel observer-rank-panel">
      <div class="title">Observer Rank <span class="chip" id="observerRankUpdated">--</span></div>
      <div class="rank-summary">
        <div class="summary-card">
          <div>Total observers</div>
          <strong id="observerRankTotal">0</strong>
        </div>
        <div class="summary-card">
          <div>Active (&lt;1h)</div>
          <strong id="observerRankActive">0</strong>
        </div>
        <div class="summary-card">
          <div>Packets today</div>
          <strong id="observerRankPackets">0</strong>
        </div>
      </div>
      <div class="rank-body observer-rank-body">
        <div class="rank-map observer-rank-map">
          <div id="observerRankMap"></div>
        </div>
        <div class="rank-list">
          <input class="rank-search" id="observerRankSearch" type="text" placeholder="Search observers"/>
          <div class="rank-scroll" id="observerRankScroll">
            <div id="observerRankList"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel why-panel">
      <div class="title">Why MeshRank?</div>
      <div class="why-body">
        <div class="why-card">
          <h3>Why MeshRank?</h3>
          <p>Mesh networks promise resilience, but in their early stages they often struggle with something more basic: confidence.</p>
          <p>With MeshCORE, new repeaters are frequently deployed into sparse or growing networks. When messages don’t appear to move — or there’s no clear feedback — operators naturally assume the repeater isn’t helping. Too often, it gets switched off, and the network loses coverage just when it needs it most.</p>
          <p>MeshRank exists to answer one question early mesh networks struggle with: “Is this helping?”</p>
          <p>By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient. MeshRank exists to change that experience.</p>
          <p>It provides visibility into how the mesh is actually performing:</p>
          <p>Which repeaters are active and contributing over time. Which messages were delivered, with a confidence score rather than guesswork. Where messages were observed but failed to fully propagate.</p>
          <p>This feedback loop keeps operators engaged and informed, even when the network is still maturing.</p>
          <p>MeshRank uses a passive observer network to provide insight without increasing mesh traffic. By reducing the need for repeated test messages, it lowers network load while giving users meaningful information about what’s happening behind the scenes.</p>
          <p>Repeaters are ranked based on real contribution, not assumptions — encouraging operators to keep nodes online, improve placement, and actively strengthen the network.</p>
          <p>MeshRank doesn’t replace the mesh, and it doesn’t route traffic through the internet. It simply helps the mesh understand itself.</p>
          <p>Visibility builds confidence. Confidence builds resilience.</p>
        </div>
        <div class="why-card">
          <h3>Frequently Asked Questions</h3>
          <div class="faq-item">
            <strong>Does MeshRank route messages over the internet?</strong>
            <p>No. MeshRank does not forward, relay, or complete mesh messages using the internet. All mesh communication still happens entirely over RF. MeshRank only observes what has already occurred and reports that information back to users.</p>
          </div>
          <div class="faq-item">
            <strong>Does this break the idea of a “pure” mesh?</strong>
            <p>No. The mesh remains fully autonomous and functional without MeshRank. If MeshRank disappeared tomorrow, the mesh would continue to operate exactly as it does today. MeshRank does not participate in routing decisions, message delivery, or network control — it provides visibility, not dependency.</p>
          </div>
          <div class="faq-item">
            <strong>Why involve the internet at all?</strong>
            <p>Because feedback matters. In early and sparse networks, lack of feedback causes repeaters to be switched off, not improved. MeshRank uses off-mesh observation to help operators understand what’s happening without increasing RF traffic or adding test spam to the network. This strengthens the mesh — it doesn’t weaken it.</p>
          </div>
          <div class="faq-item">
            <strong>Could this become a central point of failure?</strong>
            <p>No. MeshRank is not in the message path. It cannot block, delay, or interfere with mesh traffic. If MeshRank goes offline, the mesh continues to operate unchanged. There is no reliance on MeshRank for delivery, routing, or authentication.</p>
          </div>
          <div class="faq-item">
            <strong>Does this reduce resilience by encouraging internet dependence?</strong>
            <p>Quite the opposite. MeshRank encourages: better repeater placement, higher uptime, reduced test traffic, and faster identification of coverage gaps. All of these increase RF-only resilience, even when the internet is unavailable.</p>
          </div>
          <div class="faq-item">
            <strong>Is this surveillance or message tracking?</strong>
            <p>No. Observers do not inject traffic or control the network. They report limited metadata needed to understand propagation — not to monitor users. The goal is network health, not message content analysis.</p>
          </div>
          <div class="faq-item">
            <strong>Why ranking repeaters? Isn’t that gamification?</strong>
            <p>Yes — intentionally. Visibility and motivation matter. Ranking makes contribution measurable, encourages operators to keep repeaters online, and helps the network grow during its most fragile phase. Strong networks are built by engaged operators.</p>
          </div>
          <div class="faq-item">
            <strong>What happens when the mesh becomes dense and mature?</strong>
            <p>MeshRank becomes less critical — and that’s a success. As density increases, confidence becomes self-sustaining. MeshRank’s role naturally shifts toward diagnostics, optimisation, and historical insight rather than reassurance.</p>
          </div>
          <div class="faq-item">
            <strong>So what is MeshRank really for?</strong>
            <p>MeshRank exists to answer one question early mesh networks struggle with: “Is this helping?” By giving honest, low-impact feedback, MeshRank helps good repeaters stay online long enough for the mesh to become truly resilient.</p>
          </div>
        </div>
      </div>
    </section>
  </div>

    <div class="modal" id="channelModal">
      <div class="modal-card">
        <strong>Add Channel</strong>
      <div class="field">
        <label for="channelName"># Channel name</label>
        <input id="channelName" type="text" placeholder="#public"/>
      </div>
      <div class="field">
        <label for="channelSecret">Secret (32 hex chars)</label>
        <input id="channelSecret" type="text" placeholder="8b3387e9c5cdea6ac9e4edbaa115cd72"/>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelChannel">Cancel</button>
        <button class="btn" id="saveChannel">Save</button>
      </div>
    </div>

    <div class="modal" id="routeOverrideModal">
      <div class="modal-card route-modal-card">
        <strong>Suggest route fixes</strong>
        <div style="font-size:12px;color:var(--muted);line-height:1.5;">
          Pick the correct repeater for each 2-digit code. Suggestions are weighted over time, so one user cannot rewrite the route.
        </div>
        <div class="route-override-list" id="routeOverrideList"></div>
        <div class="route-override-status" id="routeOverrideStatus">No changes submitted yet.</div>
        <div class="modal-actions">
          <button class="btn" id="routeOverrideClose">Close</button>
          <button class="btn" id="routeOverrideSave">Submit suggestions</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module" src="https://unpkg.com/esp-web-tools@9.1.0/dist/web/install-button.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    document.body.classList.add("view-channels");
      const appData = {
        channels: [],
        messages: [],
        lastChannelsSig: "",
        lastMessagesSig: "",
        renderedIdsByChannel: {},
        meshScore: null,
        rankData: null,
        rankFilter: "",
        unreadByChannel: {},
        lastReadByChannel: {},
        rfPackets: [],
        rfSelected: null,
        rfLastSig: "",
        observerRank: null,
        routeSuggestions: null,
        repeatersByCode: null,
        routeActivePathCodes: [],
        routeActivePathPoints: [],
        routeActiveMsg: null
      };

    const colors = ["#007aff", "#5856d6", "#ff9500", "#34c759"];

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function hasValidGps(r) {
      const lat = r?.gps?.lat;
      const lon = r?.gps?.lon;
      return Number.isFinite(lat) && Number.isFinite(lon) && !(lat === 0 && lon === 0);
    }

    function isRepeaterHidden(r) {
      return !!r?.hiddenOnMap || !hasValidGps(r);
    }

    function confidence(msg) {
      const repeats = msg.repeats || 1;
      const repeatScore = clamp(repeats / 8, 0, 1);
      const score = 100 * clamp(0.7 * repeatScore + 0.3, 0, 1);
      return Math.round(score);
    }

    let activeChannelId = "public";

    function renderChannels() {
      const el = document.getElementById("channels");
      el.innerHTML = "";
      const list = appData.channels.length
        ? appData.channels
        : [{ id: "public", name: "#public", snippet: "No channels yet.", time: "--" }];
      list.forEach((ch, idx) => {
        const unread = appData.unreadByChannel[ch.id] || 0;
        const displayName = ch.name || "#unknown";
        const avatarChar = (displayName[1] || displayName[0] || "?").toUpperCase();
        const snippet = ch.snippet || "No recent messages.";
        const time = ch.time || "--";
        const row = document.createElement("div");
        row.className = "channel" + (ch.id === activeChannelId ? " active" : "") + (unread ? " unread" : "");
        row.innerHTML = `
          <div class="avatar" style="background:${colors[idx % colors.length]}">${avatarChar}</div>
          <div>
            <div class="name">${displayName}</div>
            <div class="snippet">${snippet}</div>
          </div>
          <div style="display:grid;gap:6px;justify-items:end;">
            <div class="muted">${time}</div>
            ${unread ? `<div class="badge-bubble">${unread}</div>` : ""}
            <button class="channel-remove" type="button" data-name="${ch.name}">Remove</button>
          </div>
        `;
        row.addEventListener("click", () => {
          activeChannelId = ch.id;
          document.getElementById("activeChannel").textContent = ch.name;
          const latest = appData.messages
            .filter((msg) => msg.channelId === activeChannelId)
            .map((msg) => msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0)
            .reduce((a, b) => Math.max(a, b), 0);
          if (latest) appData.lastReadByChannel[activeChannelId] = latest;
          appData.unreadByChannel[activeChannelId] = 0;
          saveReadState();
          renderChannels();
          loadMessages(true);
        });
        row.querySelector(".channel-remove").addEventListener("click", async (e) => {
          e.stopPropagation();
          const name = e.currentTarget.dataset.name;
          if (!name) return;
          if (!confirm(`Remove ${name}?`)) return;
          try {
            await fetch(`/api/channels?name=${encodeURIComponent(name)}`, { method: "DELETE" });
            await loadChannels();
          } catch {
            alert("Unable to remove channel.");
          }
        });
        el.appendChild(row);
      });
    }

    function renderMessages(full) {
      const el = document.getElementById("messages");
      const filtered = appData.messages.filter((msg) => msg.channelId === activeChannelId);
      const key = activeChannelId;
      if (full) {
        el.innerHTML = "";
        appData.renderedIdsByChannel[key] = new Set();
      }
      const rendered = appData.renderedIdsByChannel[key] || new Set();

      filtered.forEach((msg, idx) => {
        if (rendered.has(msg.id)) return;
        const row = document.createElement("div");
        row.className = "message";
        const conf = confidence(msg);
        const observerList = msg.observerHits ? msg.observerHits.join(", ") : "";
        row.innerHTML = `
          <div class="avatar" style="background:${colors[(idx + 1) % colors.length]}">${msg.sender[0]}</div>
          <div>
            <div class="meta">
              <strong>${msg.sender}</strong>
              <span>${msg.ts}</span>
              <span class="badge">${msg.type}</span>
            </div>
            <div class="bubble ${msg.type}">${msg.body}</div>
            <div class="msg-footer">
              <span>Repeater hops heard: ${msg.repeats || 0}</span>
              <span>Confidence: ${conf}%</span>
              <a class="analyze" href="#" data-id="${msg.id}">Analyze</a>
            </div>
          </div>
        `;
        el.appendChild(row);
        rendered.add(msg.id);
      });
      appData.renderedIdsByChannel[key] = rendered;
      el.scrollTop = el.scrollHeight;
    }

    let map;
    let routeLayer;

    function initMap() {
      map = L.map("routeMap", { zoomControl: true }).setView([52.2, -1.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);
      routeLayer = L.layerGroup().addTo(map);
    }

    async function showRoute(msgId) {
      const msg = appData.messages.find((m) => m.id === msgId);
      if (!msg) return;
      appData.routeActiveId = msgId;
      appData.routeActiveMsg = msg;

      await ensureRouteSuggestions();
      document.getElementById("routeKey").textContent = msg.id;
      document.getElementById("routeMessage").textContent = msg.id;
      document.getElementById("routeSource").textContent = msg.type;
      document.getElementById("routeConfidence").textContent = confidence(msg) + "%";

      const depth = Math.max(1, msg.path.length || 1);
      const slider = document.getElementById("depthSlider");
      slider.max = Math.max(6, depth);
      slider.value = Math.min(8, slider.max);
      const maxDepth = slider.value;
      document.getElementById("routeDepth").textContent = maxDepth + " hops";

      routeLayer.clearLayers();

      const list = document.getElementById("routeList");
      list.innerHTML = "";
        const lines = msg.path && msg.path.length ? msg.path : ["no route data"];
        const names = msg.pathNames && msg.pathNames.length ? msg.pathNames : [];
        const slicedLines = lines.slice(0, maxDepth);
        const slicedNames = names.slice(0, maxDepth);
        appData.routeActivePathCodes = slicedLines.slice();
        slicedLines.forEach((node, idx) => {
          const label = resolveRouteName(node, slicedNames[idx] ? slicedNames[idx] : node);
          const item = document.createElement("div");
          item.className = "list-item";
        item.innerHTML = `<span>${label}</span><span>${idx + 1}/${slicedLines.length}</span>`;
        list.appendChild(item);
      });

      document.getElementById("routeCount").textContent = slicedLines.length;

      if (routeLayer) {
        routeLayer.clearLayers();
        const path = Array.isArray(msg.path) ? msg.path.slice(0, maxDepth) : [];
          const rawPoints = Array.isArray(msg.pathPoints) ? msg.pathPoints.slice(0, maxDepth) : [];
          appData.routeActivePathPoints = rawPoints.slice();
        const pathLen = Math.max(path.length, rawPoints.length);
        const normalized = [];

        function hasGps(p) {
          return p && p.gps && Number.isFinite(p.gps.lat) && Number.isFinite(p.gps.lon);
        }

        function estimateFromNeighbors(idx) {
          let prev = null;
          for (let i = idx - 1; i >= 0; i -= 1) {
            const p = normalized[i];
            if (p && hasGps(p)) { prev = p; break; }
          }
          let next = null;
          for (let i = idx + 1; i < normalized.length; i += 1) {
            const p = normalized[i];
            if (p && hasGps(p)) { next = p; break; }
          }
          if (prev && next) {
            return {
              lat: (prev.gps.lat + next.gps.lat) / 2,
              lon: (prev.gps.lon + next.gps.lon) / 2
            };
          }
          if (prev) {
            return { lat: prev.gps.lat + 0.05, lon: prev.gps.lon - 0.05 };
          }
          if (next) {
            return { lat: next.gps.lat - 0.05, lon: next.gps.lon + 0.05 };
          }
          return null;
        }

        for (let i = 0; i < pathLen; i += 1) {
          const base = rawPoints[i] || { hash: path[i], name: msg.pathNames?.[i] || path[i] || "#unknown" };
          const resolvedName = resolveRouteName(base.hash || path[i], base.name);
          normalized.push({ ...base, name: resolvedName });
        }

        const latlngs = [];
        normalized.forEach((p, idx) => {
          let gps = hasGps(p) ? p.gps : null;
          let estimated = false;
          if (!gps) {
            const guess = estimateFromNeighbors(idx);
            if (guess) {
              gps = guess;
              estimated = true;
            }
          }
          if (!gps) return;
          const latlng = [gps.lat, gps.lon];
          latlngs.push(latlng);
          const color = estimated ? "#ffcc00" : "#007aff";
          L.circleMarker(latlng, {
            radius: 7,
            color,
            fillColor: color,
            fillOpacity: 0.85,
            weight: 2
          }).bindPopup(estimated ? `${p.name || "#unknown"} (estimated)` : (p.name || "#unknown")).addTo(routeLayer);
        });

        if (latlngs.length >= 2) {
          L.polyline(latlngs, { color: "#007aff", weight: 3, opacity: 0.7 }).addTo(routeLayer);
          map.fitBounds(latlngs, { padding: [20, 20] });
        } else if (latlngs.length === 1) {
          map.setView(latlngs[0], 9);
        }
      }
    }

    document.addEventListener("click", (e) => {
      const link = e.target.closest(".analyze");
      if (!link) return;
      e.preventDefault();
      showRoute(link.dataset.id);
    });

    const routeOverrideBtn = document.getElementById("routeOverrideBtn");
    const routeOverrideModal = document.getElementById("routeOverrideModal");
    const routeOverrideList = document.getElementById("routeOverrideList");
    const routeOverrideStatus = document.getElementById("routeOverrideStatus");
    const routeOverrideClose = document.getElementById("routeOverrideClose");
    const routeOverrideSave = document.getElementById("routeOverrideSave");

    function getRouteVoterId() {
      const key = "routeVoterId";
      let id = localStorage.getItem(key);
      if (id) return id;
      id = Math.random().toString(36).slice(2, 12);
      localStorage.setItem(key, id);
      return id;
    }

    function openRouteOverrideModal() {
      if (!routeOverrideModal || !routeOverrideList) return;
      const codes = appData.routeActivePathCodes || [];
      if (!codes.length) return;
      routeOverrideList.innerHTML = "";
      const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
      const suggestions = appData.routeSuggestions?.byCode || {};
      const points = appData.routeActivePathPoints || [];

      codes.forEach((code, idx) => {
        const key = String(code || "").toUpperCase();
        const options = repeatersByCode.get(key) || [];
        const pointName = points[idx]?.name || appData.routeActiveMsg?.pathNames?.[idx] || key;
        const currentName = resolveRouteName(key, pointName);
        const best = suggestions[key];
        const bestText = best && best.accepted ? `${best.name || best.pub} (${best.confidence}% confidence)` : "No community match yet";

        const row = document.createElement("div");
        row.className = "route-override-row";

        const label = document.createElement("div");
        label.className = "route-override-label";
        label.innerHTML = `<strong>${key}</strong><div>Current: ${currentName}</div><div>Community: ${bestText}</div>`;

        const select = document.createElement("select");
        select.className = "route-override-select";
        select.dataset.code = key;

        const optKeep = document.createElement("option");
        optKeep.value = "keep";
        optKeep.textContent = "Keep current";
        select.appendChild(optKeep);

        const optNone = document.createElement("option");
        optNone.value = "none";
        optNone.textContent = "None of these";
        select.appendChild(optNone);

        if (options.length) {
          const divider = document.createElement("option");
          divider.disabled = true;
          divider.textContent = "-- Repeaters with this code --";
          select.appendChild(divider);
          options.forEach((opt) => {
            const o = document.createElement("option");
            o.value = opt.pub || "";
            o.textContent = opt.name || opt.pub || key;
            select.appendChild(o);
          });
        }

        row.appendChild(label);
        row.appendChild(select);
        routeOverrideList.appendChild(row);
      });

      if (routeOverrideStatus) routeOverrideStatus.textContent = "Select repeaters, then submit.";
      routeOverrideModal.classList.add("open");
    }

    if (routeOverrideBtn) {
      routeOverrideBtn.addEventListener("click", async () => {
        await ensureRouteSuggestions();
        openRouteOverrideModal();
      });
    }

    if (routeOverrideClose) {
      routeOverrideClose.addEventListener("click", () => {
        if (routeOverrideModal) routeOverrideModal.classList.remove("open");
      });
    }

    if (routeOverrideSave) {
      routeOverrideSave.addEventListener("click", async () => {
        if (!routeOverrideList) return;
        const voterId = getRouteVoterId();
        const pathGps = (appData.routeActivePathPoints || []).map((p) => p?.gps).filter(Boolean);
        const repeatersByCode = appData.repeatersByCode || buildRepeatersByCode(appData.rankData || {});
        const selects = routeOverrideList.querySelectorAll("select[data-code]");
        const requests = [];

        selects.forEach((select) => {
          const code = select.dataset.code;
          const choice = select.value;
          if (!code || choice === "keep") return;
          if (choice === "none") {
            overrideRouteName(code, "");
            return;
          }
          const options = repeatersByCode.get(code) || [];
          const picked = options.find((opt) => opt.pub === choice);
          if (!picked) return;
          overrideRouteName(code, picked.name || code);
          requests.push(fetch("/api/route-suggest", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              code,
              repeaterPub: picked.pub,
              repeaterName: picked.name || "",
              voterId,
              pathGps
            })
          }));
        });

        if (!requests.length) {
          if (routeOverrideStatus) routeOverrideStatus.textContent = "No changes selected.";
          return;
        }

        if (routeOverrideStatus) routeOverrideStatus.textContent = "Submitting suggestions...";
        await Promise.allSettled(requests);
        try {
          appData.routeSuggestions = await fetchRouteSuggestions();
        } catch {}
        if (routeOverrideStatus) routeOverrideStatus.textContent = "Suggestions saved. Community scores update over time.";
        if (appData.routeActiveId) showRoute(appData.routeActiveId);
        renderRfList();
        renderRfDetail();
      });
    }

    const depthSliderEl = document.getElementById("depthSlider");
    if (depthSliderEl) {
      depthSliderEl.addEventListener("input", () => {
        if (appData.routeActiveId) showRoute(appData.routeActiveId);
      });
    }

    const modal = document.getElementById("channelModal");
    const addBtn = document.getElementById("addChannelBtn");
    const cancelBtn = document.getElementById("cancelChannel");
    const saveBtn = document.getElementById("saveChannel");

    function openModal() {
      document.getElementById("channelName").value = "";
      document.getElementById("channelSecret").value = "";
      modal.classList.add("open");
    }

    function closeModal() {
      modal.classList.remove("open");
    }

    addBtn.addEventListener("click", openModal);
    cancelBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e) => {
      if (e.target === modal) closeModal();
    });

    saveBtn.addEventListener("click", async () => {
      const name = document.getElementById("channelName").value.trim();
      const secret = document.getElementById("channelSecret").value.trim();
      if (!name.startsWith("#")) {
        alert("Channel name must start with #");
        return;
      }
      if (!/^[0-9a-fA-F]{32}$/.test(secret)) {
        alert("Secret must be 32 hex characters");
        return;
      }
      try {
        const res = await fetch("/api/channels", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, secretHex: secret })
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        await loadChannels();
        closeModal();
      } catch (err) {
        alert("Failed to add channel: " + (err?.message || err));
      }
    });

    async function loadChannels() {
      const res = await fetch("/api/channels", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const channels = data.channels || [];
      appData.channels = channels;
      if (appData.channels.length) {
        const exists = appData.channels.some((c) => c.id === activeChannelId);
        if (!exists) activeChannelId = appData.channels[0].id;
        const active = appData.channels.find((c) => c.id === activeChannelId);
        if (active) document.getElementById("activeChannel").textContent = active.name;
      } else {
        activeChannelId = "public";
        document.getElementById("activeChannel").textContent = "#public";
      }
      renderChannels();
    }

    async function loadMessages(forceFull) {
      const res = await fetch("/api/messages", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const raw = data.messages || [];
      appData.messages = raw.map((m) => ({
        id: m.id,
        channelId: (m.channelName || "#unknown").replace(/^#/, ""),
        sender: m.sender,
        body: m.body,
        tsRaw: m.ts || null,
        ts: m.ts ? new Date(m.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", hour12: false }) : "--",
        type: "mesh",
        repeats: m.repeats || 1,
        path: Array.isArray(m.path) ? m.path : [],
        pathNames: Array.isArray(m.pathNames) ? m.pathNames : [],
        pathPoints: Array.isArray(m.pathPoints) ? m.pathPoints : []
      })).sort((a, b) => {
        const ta = a.tsRaw ? new Date(a.tsRaw).getTime() : 0;
        const tb = b.tsRaw ? new Date(b.tsRaw).getTime() : 0;
        return ta - tb;
      });
      const unread = {};
      const latestByChannel = {};
      appData.messages.forEach((msg) => {
        if (!msg.channelId) return;
        const t = msg.tsRaw ? new Date(msg.tsRaw).getTime() : 0;
        if (!latestByChannel[msg.channelId] || t > latestByChannel[msg.channelId]) {
          latestByChannel[msg.channelId] = t;
        }
        const lastRead = appData.lastReadByChannel[msg.channelId] || 0;
        if (t > lastRead) {
          unread[msg.channelId] = (unread[msg.channelId] || 0) + 1;
        }
      });
      const activeLatest = latestByChannel[activeChannelId] || 0;
      if (activeLatest) {
        appData.lastReadByChannel[activeChannelId] = activeLatest;
        unread[activeChannelId] = 0;
        saveReadState();
      }
      appData.unreadByChannel = unread;
      renderChannels();
      renderMessages(!!forceFull);
      if (forceFull && appData.messages.length) showRoute(appData.messages[0].id);
    }

    async function checkServerStatus() {
      try {
        const res = await fetch("/api/channels?ts=" + Date.now(), { cache: "no-store" });
        setServerStatus(res.ok);
        return res.ok;
      } catch {
        setServerStatus(false);
        return false;
      }
    }

    function loadReadState() {
      try {
        const raw = localStorage.getItem("meshmonitor.lastReadByChannel");
        const parsed = raw ? JSON.parse(raw) : {};
        if (parsed && typeof parsed === "object") appData.lastReadByChannel = parsed;
      } catch {}
    }

    function saveReadState() {
      localStorage.setItem("meshmonitor.lastReadByChannel", JSON.stringify(appData.lastReadByChannel));
    }

    async function boot() {
      await checkServerStatus();
      try {
        await loadChannels();
        await loadMessages(true);
        try {
          const mesh = await fetchMeshScore();
          renderMeshScore(mesh, meshRangeDays);
        } catch {}
        setServerStatus(true);
      } catch (err) {
        const msg = document.createElement("div");
        msg.className = "rank-item";
        msg.textContent = "No messages yet.";
        document.getElementById("messages").appendChild(msg);
        setServerStatus(false);
      }
      initMap();
      initObserverMap();
      setInterval(async () => {
        const ok = await checkServerStatus();
        if (!ok) return;
        try {
          await loadChannels();
          await loadMessages();
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeRank = document.body.classList.contains("view-rank");
        if (!activeRank) return;
        try {
          const mesh = await fetchMeshScore();
          renderMeshScore(mesh, meshRangeDays);
          const data = await fetchRank();
          renderRank(data);
        } catch {}
      }, 15000);

      setInterval(async () => {
        const activeRf = document.body.classList.contains("view-rf");
        if (!activeRf) return;
        try {
          const payload = await fetchRfLatest();
          const items = payload.items || [];
          const last = items[items.length - 1];
          const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
          if (sig !== appData.rfLastSig) {
            appData.rfLastSig = sig;
            appData.rfPackets = items;
            document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
            renderRfList();
          }
          if (!appData.rfSelected && appData.rfPackets.length) {
            appData.rfSelected = appData.rfPackets[appData.rfPackets.length - 1];
            renderRfDetail();
          }
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserver = document.body.classList.contains("view-observer");
        if (!activeObserver) return;
        try {
          const data = await fetchObservers();
          renderObserverMap(data);
          renderObserverList(data);
        } catch {}
      }, 5000);

      setInterval(async () => {
        const activeObserverRank = document.body.classList.contains("view-observer-rank");
        if (!activeObserverRank) return;
        try {
          const data = await fetchObserverRank();
          appData.observerRank = data;
          renderObserverRank(data);
          renderObserverRankMap(data);
        } catch {}
      }, 15000);
    }

    boot();

    let rankMap;
    let rankLayer;
    let rankMarkers = new Map();
    let meshRangeDays = 7;
    let observerMap;
    let observerLayer;
    let observerRankMap;
    let observerRankLayer;
    let observerRankRadiusLayer;

    function initRankMap() {
      rankMap = L.map("rankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(rankMap);
      rankLayer = L.layerGroup().addTo(rankMap);
    }

    function initObserverMap() {
      const el = document.getElementById("observerMap");
      if (!el) return;
      observerMap = L.map("observerMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerMap);
      observerLayer = L.layerGroup().addTo(observerMap);
    }

    function initObserverRankMap() {
      const el = document.getElementById("observerRankMap");
      if (!el) return;
      observerRankMap = L.map("observerRankMap", { zoomControl: true }).setView([54.0, -2.5], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(observerRankMap);
      observerRankLayer = L.layerGroup().addTo(observerRankMap);
      observerRankRadiusLayer = L.layerGroup().addTo(observerRankMap);
    }

    async function fetchObservers() {
      const res = await fetch("/api/observers?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchObserverRank() {
      const res = await fetch("/api/observer-rank?_ts=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function observerColor(ageHours) {
      if (ageHours <= 1) return "#34c759";
      if (ageHours <= 24) return "#ff9500";
      if (ageHours <= 48) return "#ff3b30";
      return null;
    }

    function renderObserverMap(data) {
      if (!observerLayer || !data) return;
      observerLayer.clearLayers();
      const entries = Object.values(data.byId || {});
      const now = Date.now();
      const points = [];
      entries.forEach((entry) => {
        const gps = entry.gps;
        if (!entry.locValidated) return;
        if (!gps || !Number.isFinite(gps.lat) || !Number.isFinite(gps.lon)) return;
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        const color = observerColor(ageHours);
        if (!color) return;
        const circle = L.circle([gps.lat, gps.lon], {
          radius: 5000,
          color,
          fillColor: color,
          fillOpacity: 0.35,
          weight: 2
        });
      const name = entry.name || entry.id || "Observer";
      circle.bindTooltip(name, { direction: "top", opacity: 0.9 });
        circle.addTo(observerLayer);
        points.push([gps.lat, gps.lon]);
      });
      if (points.length) {
        observerMap.fitBounds(points, { padding: [20, 20], maxZoom: 6 });
      } else {
        observerMap.setView([54.0, -2.5], 6);
      }
      if (observerMap) {
        observerMap.invalidateSize();
      }
    }

    function renderObserverList(data) {
      const list = document.getElementById("observerList");
      if (!list || !data) return;
      const entries = Object.values(data.byId || {}).filter((entry) => !entry.locValidated);
      if (!entries.length) {
        list.innerHTML = "<div class='rf-row'>No pending observers.</div>";
        return;
      }
      const now = Date.now();
      entries.sort((a, b) => new Date(b.lastSeen || 0) - new Date(a.lastSeen || 0));
      list.innerHTML = entries.map((entry) => {
        const name = entry.name || entry.id || "Observer";
        const ts = entry.lastSeen ? new Date(entry.lastSeen).getTime() : 0;
        const ageHours = ts ? (now - ts) / 3600000 : 999;
        let status = "Active";
        if (ageHours > 24) status = "Idle 24h+";
        else if (ageHours > 1) status = "Idle 1h+";
        const location = entry.locValidated
          ? (entry.gps ? `${entry.gps.lat.toFixed(4)}, ${entry.gps.lon.toFixed(4)}` : "Estimated")
          : "Location pending";
        const source = entry.locSource ? ` | ${entry.locSource}` : "";
        return `<div class="rf-row">
          <div class="rf-head">${name}</div>
          <div class="rf-meta">${status} | ${location}${source}</div>
        </div>`;
      }).join("");
    }

    function renderObserverRank(data) {
      const list = document.getElementById("observerRankList");
      if (!list || !data?.items) return;
      const query = (document.getElementById("observerRankSearch")?.value || "").trim().toLowerCase();
      const items = data.items.filter((o) => !query || String(o.name || o.id).toLowerCase().includes(query));
        list.innerHTML = items.length
          ? items.map((o) => {
              const scoreBadge = String(Math.round(o.score || 0)).padStart(2, "0");
              return `
                <div class="rank-item">
                  <div class="score">
                    <span class="rank-dot" style="background:${o.scoreColor}">${scoreBadge}</span>
                    <div class="rank-main">
                      <strong>${o.name || o.id}</strong>
                      <div class="rank-meta">Uptime: ${o.uptimeHours.toFixed(1)}h | Packets today: ${o.packetsToday}</div>
                      <div class="rank-meta">Coverage: ${o.coverageKm.toFixed(1)}km | Repeaters: ${o.coverageCount}</div>
                      <div class="rank-meta">Nearest repeater: ${o.nearestRepeaterName || "--"}${Number.isFinite(o.nearestRepeaterKm) ? ` (${o.nearestRepeaterKm}km)` : ""}</div>
                      ${badgeHtml(buildObserverBadges(o))}
                    </div>
                  </div>
                </div>
              `;
            }).join("")
          : "<div class='rank-item'>No observers yet.</div>";

      document.getElementById("observerRankUpdated").textContent = data.updatedAt
        ? new Date(data.updatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--";
      document.getElementById("observerRankTotal").textContent = data.items.length;
      document.getElementById("observerRankActive").textContent = data.items.filter((o) => o.ageHours < 1).length;
      document.getElementById("observerRankPackets").textContent = data.items.reduce((sum, o) => sum + o.packetsToday, 0);
    }

    function renderObserverRankMap(data) {
      if (!observerRankMap || !observerRankLayer || !observerRankRadiusLayer || !data?.items) return;
      observerRankLayer.clearLayers();
      observerRankRadiusLayer.clearLayers();
      const points = [];
      data.items.forEach((o) => {
        if (!o.gps) return;
        const latlng = [o.gps.lat, o.gps.lon];
        points.push(latlng);
        const marker = L.circleMarker(latlng, {
          radius: 7,
          weight: 2,
          color: o.scoreColor,
          fillColor: o.scoreColor,
          fillOpacity: 0.9
        }).bindPopup(`${o.name || o.id} | ${o.packetsToday} pkts today`);
        marker.addTo(observerRankLayer);
        if (o.coverageKm > 0) {
          const circle = L.circle(latlng, {
            radius: o.coverageKm * 1000,
            color: o.scoreColor,
            weight: 1,
            fillColor: o.scoreColor,
            fillOpacity: 0.08
          });
          circle.addTo(observerRankRadiusLayer);
        }
      });
      if (observerRankMap) observerRankMap.setView([54.0, -2.5], 6);
    }

    function formatDateTime(value) {
      const d = new Date(value);
      if (!Number.isFinite(d.getTime())) return "unknown";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
    }

    function distanceKm(a, b) {
      const toRad = (v) => (v * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const val = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(val), Math.sqrt(1 - val));
    }

    function badgeHtml(badges) {
      if (!badges.length) return "";
      return `<div class="badge-row">${badges.map((b) => `<span class="badge badge-${b.tone}">${b.label}</span>`).join("")}</div>`;
    }

    function buildNearestObserverRepeaters(repeaters, observers) {
      const flagged = new Set();
      if (!Array.isArray(observers) || !Array.isArray(repeaters)) return flagged;
      const repeaterPoints = repeaters.filter((r) => r?.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon));
      observers.forEach((o) => {
        if (!o?.gps || !Number.isFinite(o.gps.lat) || !Number.isFinite(o.gps.lon)) return;
        let best = null;
        let bestKm = Infinity;
        repeaterPoints.forEach((r) => {
          const km = distanceKm(o.gps, r.gps);
          if (km < bestKm) {
            bestKm = km;
            best = r;
          }
        });
        if (best?.pub) flagged.add(String(best.pub).toUpperCase());
      });
      return flagged;
    }

    function buildRepeaterBadges(r, nearestObserverSet) {
      const badges = [];
      if (Number(r.total24h || 0) >= 10) badges.push({ label: "Great TX", tone: "green" });
      if (Number.isFinite(r.avgRssi) && r.avgRssi >= -75) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(r.zeroHopNeighbors24h || 0) >= 4) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(r.avgRepeats || 0) >= 3 && Number(r.total24h || 0) >= 10) badges.push({ label: "Great Throughput", tone: "amber" });
      if (nearestObserverSet && r.pub && nearestObserverSet.has(String(r.pub).toUpperCase())) {
        badges.push({ label: "Close to Observer", tone: "green" });
      }
      return badges;
    }

    function buildObserverBadges(o) {
      const badges = [];
      if (Number(o.uptimeHours || 0) >= 48) badges.push({ label: "Great Uptime", tone: "green" });
      if (Number(o.packetsToday || 0) >= 200) badges.push({ label: "Great RX", tone: "blue" });
      if (Number(o.coverageCount || 0) >= 5) badges.push({ label: "Strong Local Mesh", tone: "purple" });
      if (Number(o.coverageKm || 0) >= 20) badges.push({ label: "Wide Coverage", tone: "amber" });
      if (Number(o.nearestRepeaterKm || 999) <= 5) badges.push({ label: "Close to Repeater", tone: "green" });
      return badges;
    }

    async function fetchRank() {
      const res = await fetch(`/api/repeater-rank?refresh=1&_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchMeshScore() {
      const res = await fetch("/api/meshscore", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRfLatest() {
      const res = await fetch("/api/rf-latest?limit=80", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    async function fetchRouteSuggestions() {
      const res = await fetch(`/api/route-suggestions?_ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function shortHex(value, len) {
      if (!value) return "--";
      const s = String(value);
      if (s.length <= len) return s;
      return s.slice(0, len);
    }

    function buildRepeatersByCode(data) {
      const map = new Map();
      const items = data?.items || [];
      for (const item of items) {
        const code = String(item.hashByte || "").toUpperCase();
        if (!code) continue;
        if (!map.has(code)) map.set(code, []);
        map.get(code).push({
          pub: item.pub,
          name: item.name || code,
          gps: item.gps || null
        });
      }
      return map;
    }

    async function ensureRouteSuggestions() {
      if (appData.routeSuggestions) return;
      try {
        appData.routeSuggestions = await fetchRouteSuggestions();
      } catch {
        appData.routeSuggestions = { byCode: {} };
      }
    }

    const routeOverrides = (() => {
      try {
        return JSON.parse(localStorage.getItem("routeOverrides") || "{}");
      } catch {
        return {};
      }
    })();

    function saveRouteOverrides() {
      try {
        localStorage.setItem("routeOverrides", JSON.stringify(routeOverrides));
      } catch {}
    }

    function overrideRouteName(hash, name) {
      const key = String(hash || "").toUpperCase();
      if (!key) return;
      if (!name) {
        delete routeOverrides[key];
      } else {
        routeOverrides[key] = name;
      }
      saveRouteOverrides();
    }

    function resolveRouteName(hash, fallback) {
      const key = String(hash || "").toUpperCase();
      if (key && routeOverrides[key]) return routeOverrides[key];
      const suggestion = appData.routeSuggestions?.byCode?.[key];
      if (suggestion?.accepted && suggestion.name) return suggestion.name;
      return fallback || hash || "#unknown";
    }

    function formatPathLabel(p) {
      const names = Array.isArray(p.pathNames) ? p.pathNames : [];
      const codes = Array.isArray(p.path) ? p.path : [];
      if (names.length) {
        const merged = names.map((name, idx) => {
          const code = codes[idx] || "";
          if (name === "#unknown") return resolveRouteName(code, code || "#unknown");
          const resolved = resolveRouteName(code, name);
          return code ? `${resolved} (${code})` : resolved;
        });
        return merged.join(" > ");
      }
      if (codes.length) return codes.join(" > ");
      return "--";
    }

    function renderRfList() {
      const list = document.getElementById("rfList");
      if (!list) return;
      const search = document.getElementById("rfSearch")?.value?.trim().toLowerCase() || "";
      const typeFilter = document.getElementById("rfTypeFilter")?.value || "";
      const filtered = appData.rfPackets.filter((p) => {
        if (typeFilter && p.payloadType !== typeFilter) return false;
        if (!search) return true;
        const hay = [
          p.hash,
          p.fp,
          p.senderPublicKey,
          p.destinationHash,
          p.channelHash,
          p.channelName,
          p.routeTypeName,
          ...(p.path || []),
          ...(p.pathNames || [])
        ].filter(Boolean).join(" ").toLowerCase();
        return hay.includes(search);
      });
      list.innerHTML = "";
      document.getElementById("rfCount").textContent = `${filtered.length} packets`;
      const total = appData.rfPackets.length;
      const ok = appData.rfPackets.filter((p) => p.crc === true).length;
      const bad = appData.rfPackets.filter((p) => p.crc === false).length;
      const typeCounts = {};
      appData.rfPackets.forEach((p) => {
        const t = p.payloadType || "Unknown";
        typeCounts[t] = (typeCounts[t] || 0) + 1;
      });
      const topType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "--";
      document.getElementById("rfTotal").textContent = total;
      document.getElementById("rfOk").textContent = ok;
      document.getElementById("rfBad").textContent = bad;
      document.getElementById("rfTopType").textContent = topType;
      const slice = filtered.slice(-150).reverse();
      const frag = document.createDocumentFragment();
      const header = document.createElement("div");
      header.className = "rf-row rf-header";
        header.innerHTML = `
          <div>Time</div>
          <div>Type</div>
          <div>Route</div>
          <div>Hash</div>
          <div>Path</div>
          <div>Sender</div>
          <div>Observers</div>
          <div>RSSI</div>
          <div>SNR</div>
          <div>Len</div>
          <div>CRC</div>
          <div>Edit</div>
        `;
      frag.appendChild(header);
      slice.forEach((p) => {
        const row = document.createElement("div");
        row.className = "rf-row";
        const time = p.ts ? new Date(p.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" }) : "--";
        const hash = shortHex(p.hash || p.fp || "--", 10);
        const route = p.routeTypeName || "--";
        const pathLabel = formatPathLabel(p);
        const sender = p.senderName || (p.senderPublicKey ? shortHex(p.senderPublicKey, 12) : "--");
        row.innerHTML = `
          <div>${time}</div>
          <div><span class="rf-type">${p.payloadType || "Unknown"}</span></div>
          <div>${route}</div>
          <div>${hash}</div>
          <div title="${pathLabel}">${pathLabel}</div>
          <div>${sender}</div>
          <div>${p.observerCount ?? 1}</div>
          <div>${Number.isFinite(p.rssi) ? p.rssi : "--"}</div>
          <div>${Number.isFinite(p.snr) ? p.snr : "--"}</div>
          <div>${p.len ?? "--"}</div>
          <div>${p.crc === true ? "CRC" : p.crc === false ? "BAD" : "--"}</div>
          <div><button class="link-btn rf-edit" type="button">Edit</button></div>
        `;
        row.addEventListener("click", () => {
          appData.rfSelected = p;
          renderRfDetail();
        });
        row.querySelector(".rf-edit")?.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          appData.routeActiveId = p.hash || null;
          appData.routeActiveMsg = {
            id: p.hash || "--",
            path: Array.isArray(p.path) ? p.path : [],
            pathNames: Array.isArray(p.pathNames) ? p.pathNames : []
          };
          appData.routeActivePathCodes = Array.isArray(p.path) ? p.path.slice() : [];
          appData.routeActivePathPoints = [];
          await ensureRouteSuggestions();
          openRouteOverrideModal();
        });
        frag.appendChild(row);
      });
      list.appendChild(frag);
    }

    function renderRfDetail() {
      const detail = document.getElementById("rfDetail");
      if (!detail) return;
      const p = appData.rfSelected;
      if (!p) {
        detail.innerHTML = `<div class="rf-kv">Select a packet to inspect its payload.</div>`;
        return;
      }
      const pathLabel = formatPathLabel(p);
      const sender = p.senderName || p.senderPublicKey || "--";
      const channelLabel = p.channelName ? `${p.channelName} (${p.channelHash || "--"})` : (p.channelHash || "--");
      const appFlags = Number.isFinite(p.appFlags) ? `0x${p.appFlags.toString(16).toUpperCase().padStart(2, "0")}` : "--";
      const observerNames = Array.isArray(p.observerHits) && p.observerHits.length
        ? p.observerHits.join(", ")
        : (p.observerName || "--");
      detail.innerHTML = `
        <div class="rf-kv"><strong>Packet</strong></div>
        <div class="rf-kv">Type: ${p.payloadType || "Unknown"}</div>
        <div class="rf-kv">Route: ${p.routeTypeName || "--"}</div>
        <div class="rf-kv">Hash: ${(p.hash || p.fp || "--").toString()}</div>
        <div class="rf-kv">Time: ${p.ts ? new Date(p.ts).toLocaleString() : "--"}</div>
        <div class="rf-kv">RSSI/SNR: ${Number.isFinite(p.rssi) ? p.rssi : "--"} / ${Number.isFinite(p.snr) ? p.snr : "--"}</div>
        <div class="rf-kv">CRC: ${p.crc === true ? "ok" : p.crc === false ? "fail" : "unknown"}</div>
        <div class="rf-kv">Length: ${p.len ?? "--"}</div>
        <div class="rf-kv">Observers: ${observerNames}</div>
        <div class="rf-kv">Fingerprint: ${p.fp || "--"}</div>
        <div class="rf-kv">Sender: ${sender}</div>
        <div class="rf-kv">Destination: ${p.destinationHash || "--"}</div>
        <div class="rf-kv">Channel: ${channelLabel}</div>
        <div class="rf-kv">Path (${p.pathLength ?? 0} hops): ${pathLabel}</div>
        <div class="rf-kv">Advert name: ${p.advertName || "--"}</div>
        <div class="rf-kv">App flags: ${appFlags}</div>
        <div class="rf-kv">Payload bytes: ${p.payloadBytes ?? "--"}</div>
        <div class="rf-kv">Decrypted: ${p.decrypted === true ? "yes" : "no"}</div>
        <div class="rf-kv">Valid: ${p.isValid === true ? "yes" : p.isValid === false ? "no" : "unknown"}</div>
      `;
    }

    function renderMeshScore(data, rangeDays) {
      if (!data) return;
      appData.meshScore = data;
      document.getElementById("meshUpdated").textContent = new Date(data.updatedAt).toLocaleTimeString();
      document.getElementById("meshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("meshYesterday").textContent = data.scores?.yesterday ?? 0;
      document.getElementById("meshDelta").textContent = data.scores?.delta ?? 0;
      document.getElementById("meshMessages").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshDevices").textContent = data.totals?.devices ?? 0;
      document.getElementById("meshRepeaters").textContent = data.totals?.activeRepeaters ?? 0;
      document.getElementById("meshRooms").textContent = data.totals?.roomServers ?? 0;
      document.getElementById("meshChat").textContent = data.totals?.chatNodes ?? 0;
      document.getElementById("meshCompanions").textContent = data.totals?.companions ?? 0;
      document.getElementById("meshMsgsToday").textContent = data.messages?.meshToday ?? 0;
      document.getElementById("meshMsgsObserver").textContent = data.messages?.observerToday ?? 0;

      const series = data.series || [];
      const days = rangeDays || 7;
      const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const filtered = series.filter((s) => new Date(s.date) >= cutoff);
      const points = filtered.map((s, idx) => {
        const x = (idx / Math.max(1, filtered.length - 1)) * 580 + 10;
        const y = 200 - (Math.max(0, Math.min(100, s.score)) / 100) * 160;
        return `${x},${y}`;
      });
      const line = document.getElementById("meshLine");
      const area = document.getElementById("meshArea");
      if (points.length) {
        line.setAttribute("points", points.join(" "));
        const areaPoints = [`10,200`, ...points, `590,200`];
        area.setAttribute("points", areaPoints.join(" "));
      } else {
        line.setAttribute("points", "");
        area.setAttribute("points", "");
      }

      document.getElementById("rankMeshToday").textContent = data.scores?.today ?? 0;
      document.getElementById("rankMeshYesterday").textContent = data.scores?.yesterday ?? 0;
    }

    function renderRank(data) {
      renderRankWithOptions(data, { preserveView: true });
    }

    function scrollRankItemToTop(pub) {
      if (!pub) return;
      const list = document.getElementById("rankList");
      const scroll = document.getElementById("rankScroll");
      const item = document.querySelector(`.rank-item[data-pub="${String(pub).toUpperCase()}"]`);
      if (!list || !scroll || !item) return;
      scroll.scrollTop = item.offsetTop - scroll.offsetTop;
    }

    function renderRankWithOptions(data, options) {
      const opts = options || {};
      appData.rankData = data;
      appData.repeatersByCode = buildRepeatersByCode(data);
      const list = document.getElementById("rankList");
      list.innerHTML = "";
      rankLayer.clearLayers();
      rankMarkers = new Map();

      document.getElementById("rankUpdated").textContent = formatDateTime(data.updatedAt);
      document.getElementById("rankTotal").textContent = data.items.length;
      const activeCount = data.items.filter((r) => !r.stale).length;
      document.getElementById("rankActive").textContent = activeCount;
      if (appData.meshScore) {
        document.getElementById("rankMeshToday").textContent = appData.meshScore.scores?.today ?? 0;
        document.getElementById("rankMeshYesterday").textContent = appData.meshScore.scores?.yesterday ?? 0;
      }

      const needle = (appData.rankFilter || "").toLowerCase();
      const sorted = [...data.items]
        .sort((a, b) => (b.score || 0) - (a.score || 0))
        .filter((r) => {
          if (!needle) return true;
          const name = String(r.name || "").toLowerCase();
          const pub = String(r.pub || "").toLowerCase();
          const code = String(r.hashByte || "").toLowerCase();
          return name.includes(needle) || pub.includes(needle) || code.includes(needle);
        });
        const nearestObserverSet = buildNearestObserverRepeaters(sorted, appData.observerRank?.items || []);
        sorted.forEach((r) => {
          const item = document.createElement("div");
          const isHidden = isRepeaterHidden(r);
          const badges = buildRepeaterBadges(r, nearestObserverSet);
          item.className = "rank-item" + (isHidden ? " hidden" : "");
          item.dataset.pub = (r.pub || "").toUpperCase();
          const observerBadge = r.isObserver ? `<div class="row"><span class="badge">Observer</span></div>` : "";
          const code = r.hashByte ? `<span class="chip" style="margin-left:6px;">${r.hashByte}</span>` : "";
            const scoreBadge = String(Math.round(r.score || 0)).padStart(2, "0");
            item.innerHTML = `
              <div class="score">
                <span class="rank-dot" style="background:${r.color}">${scoreBadge}</span>
                ${r.name} ${code}
              </div>
            <div class="row">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
            <div class="row">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
            <div class="row">Zero-hop neighbors (24h): ${r.zeroHopNeighbors24h ?? 0}</div>
            <div class="row">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
            <div class="row">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
            ${badgeHtml(badges)}
            ${isHidden ? `<div class="row"><span class="badge">GPS unreliable</span></div>` : ""}
            ${observerBadge}
          `;
        item.addEventListener("click", () => {
          openRankPopup(r, false);
        });
        list.appendChild(item);

        if (!isHidden && r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon)) {
          const marker = L.circleMarker([r.gps.lat, r.gps.lon], {
            radius: 8,
            color: r.color,
            fillColor: r.color,
            fillOpacity: 0.9,
            weight: 2
          }).bindPopup(buildRankPopupHtml(r)).addTo(rankLayer)
            .on("click", () => openRankPopup(r, true));
          if (r.pub) rankMarkers.set(r.pub, marker);
        }
      });

      if (!opts.preserveView && sorted.length) {
        const bounds = sorted
          .filter((r) => {
            if (isRepeaterHidden(r)) return false;
            return r.gps && Number.isFinite(r.gps.lat) && Number.isFinite(r.gps.lon);
          })
          .map((r) => [r.gps.lat, r.gps.lon]);
        if (bounds.length) rankMap.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    function buildRankPopupHtml(r) {
      const impact = Math.min(100, Math.max(0, r.score || 0));
      const code = r.hashByte ? ` <span class="chip">${r.hashByte}</span>` : "";
      return `
        <div style="min-width:220px;font-family:'Space Grotesk',system-ui,sans-serif;">
          <div style="font-weight:700;margin-bottom:6px;">${r.name}${code}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);">Score: <strong>${r.score}</strong> | ${r.stale ? "stale" : "active"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Last seen: ${r.lastSeen ? formatDateTime(r.lastSeen) : "unknown"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Adverts 24h: ${r.total24h} | Avg repeats: ${r.avgRepeats}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Zero-hop neighbors (24h): ${r.zeroHopNeighbors24h ?? 0}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Avg RSSI: ${r.avgRssi ?? "?"} | Avg SNR: ${r.avgSnr ?? "?"}</div>
          <div style="font-size:12px;color:rgba(60,60,67,0.6);margin-top:4px;">Best RSSI: ${r.bestRssi} | Best SNR: ${r.bestSnr}</div>
          <div style="margin-top:8px;font-size:12px;color:rgba(60,60,67,0.6);">Network impact</div>
          <div style="height:8px;border-radius:999px;background:rgba(0,122,255,0.12);overflow:hidden;">
            <div style="height:100%;width:${impact}%;background:linear-gradient(90deg,#34c759,#007aff);"></div>
          </div>
        </div>
      `;
    }

    function openRankPopup(r, skipPan) {
      if (!r) return;
      const list = document.getElementById("rankList");
      const listItem = document.querySelector(`.rank-item[data-pub="${(r.pub || "").toUpperCase()}"]`);
      document.querySelectorAll(".rank-item.focused").forEach((el) => el.classList.remove("focused"));
      if (listItem) {
        listItem.classList.add("focused");
        if (list && list.firstChild !== listItem) {
          list.prepend(listItem);
        }
        listItem.scrollIntoView({ block: "start", behavior: "smooth" });
      }
      const lat = r.gps?.lat;
      const lon = r.gps?.lon;
      const hasGps = Number.isFinite(lat) && Number.isFinite(lon);
      const marker = r.pub ? rankMarkers.get(r.pub) : null;
      const html = buildRankPopupHtml(r);

      if (marker) {
        marker.setPopupContent(html);
        marker.openPopup();
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView(marker.getLatLng(), targetZoom, { animate: true });
        }
        return;
      }

      if (hasGps) {
        const popup = L.popup({ closeButton: true, autoClose: true })
          .setLatLng([lat, lon])
          .setContent(html)
          .openOn(rankMap);
        if (!skipPan) {
          const targetZoom = Math.max(rankMap.getZoom(), 8);
          rankMap.setView([lat, lon], targetZoom, { animate: true });
        }
      }
    }


    const navLinks = document.querySelectorAll(".nav a");
    navLinks.forEach((link) => {
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          navLinks.forEach((l) => l.classList.remove("active"));
          link.classList.add("active");
          const view = link.dataset.view;
          document.body.classList.toggle("view-channels", view === "channels");
          document.body.classList.toggle("view-rank", view === "rank");
          document.body.classList.toggle("view-meshscore", view === "meshscore");
          document.body.classList.toggle("view-rf", view === "rf");
      document.body.classList.toggle("view-observer", view === "observer");
      document.body.classList.toggle("view-observer-rank", view === "observer-rank");
          document.body.classList.toggle("view-why", view === "why");

        if (view === "rank") {
          if (!rankMap) initRankMap();
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
            const data = await fetchRank();
            renderRank(data);
          } catch (err) {
            const list = document.getElementById("rankList");
            list.innerHTML = "<div class='rank-item'>No repeaters yet.</div>";
          }
        }

        if (view === "meshscore") {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        }

        if (view === "rf") {
          try {
            const payload = await fetchRfLatest();
            const items = payload.items || [];
            const last = items[items.length - 1];
            const sig = `${payload.updatedAt}:${last?.ts || ""}:${last?.hash || ""}`;
            if (sig !== appData.rfLastSig) {
              appData.rfLastSig = sig;
              appData.rfPackets = items;
              document.getElementById("rfUpdated").textContent = new Date(payload.updatedAt).toLocaleTimeString();
              renderRfList();
            }
          } catch {}
        }

        if (view === "observer") {
          if (!observerMap) initObserverMap();
          if (observerMap) {
            setTimeout(() => observerMap.invalidateSize(), 80);
          }
        }
        if (view === "observer-rank") {
          if (!observerRankMap) initObserverRankMap();
          if (observerRankMap) {
            setTimeout(() => observerRankMap.invalidateSize(), 80);
          }
          try {
            const data = await fetchObserverRank();
            appData.observerRank = data;
            renderObserverRank(data);
            renderObserverRankMap(data);
          } catch {}
        }
        if (view === "why") {
          // static content
        }
      });
    });

    document.getElementById("observerRankSearch")?.addEventListener("input", () => {
      if (!appData.observerRank) return;
      renderObserverRank(appData.observerRank);
      renderObserverRankMap(appData.observerRank);
    });

    function buildObserverEnvSnippet() {
      const ssid = (document.getElementById("observerWifi")?.value || "").trim();
      const pass = (document.getElementById("observerPass")?.value || "").trim();
      const name = (document.getElementById("observerName")?.value || "").trim();
      const lines = [
        `wifi.ssid ${ssid || "YOUR_WIFI_SSID"}`,
        `wifi.pass ${pass || "YOUR_WIFI_PASSWORD"}`,
        `observer.name ${name || "Observer"}`,
        "status"
      ];
      return lines.join("\n");
    }

    function copyText(text) {
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          alert("Config copied to clipboard.");
        }).catch(() => {
          alert(text);
        });
        return;
      }
      alert(text);
    }

    function setObserverStatus(text, isError) {
      const el = document.getElementById("observerStatus");
      if (!el) return;
      el.textContent = text;
      el.style.color = isError ? "#ff3b30" : "var(--muted)";
    }

    let observerAutoConfig = false;

    async function sendObserverConfig() {
      if (!navigator.serial) {
        setObserverStatus("WebSerial not available in this browser.", true);
        alert("WebSerial not available. Use Chrome/Edge over HTTPS.");
        return;
      }
      const payload = buildObserverEnvSnippet() + "\n";
      const logEl = document.getElementById("installLog");
      if (logEl) {
        logEl.textContent = "Select the observer serial port to send Wi-Fi config...";
        logEl.classList.add("active");
      }
      setObserverStatus("Waiting for serial port selection...", false);
      let port;
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        const writer = port.writable.getWriter();
        await writer.write(new TextEncoder().encode(payload));
        writer.releaseLock();
        await port.close();
        if (logEl) {
          logEl.textContent += "\nWi-Fi config sent. Device will reconnect using new settings.";
        }
        setObserverStatus("Wi-Fi config sent. Device will reconnect using new settings.", false);
        alert("Wi-Fi config sent.");
      } catch (err) {
        if (port && port.readable) {
          try { await port.close(); } catch {}
        }
        const msg = "Failed to send config: " + (err?.message || err);
        if (logEl) {
          logEl.textContent += "\n" + msg;
          logEl.classList.add("active");
        }
        setObserverStatus(msg, true);
        alert(msg);
      }
    }

    const observerSendBtn = document.getElementById("observerSendConfig");
    if (observerSendBtn) {
      observerSendBtn.addEventListener("click", () => {
        sendObserverConfig();
      });
    }

    function wireInstallLogging(button, verbose) {
      if (!button) return;
      const logEl = document.getElementById("installLog");
      const append = (msg) => {
        if (!logEl) return;
        logEl.classList.toggle("active", !!verbose);
        if (!verbose) return;
        const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logEl.textContent = (logEl.textContent || "").trim();
        logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + line;
        logEl.scrollTop = logEl.scrollHeight;
      };

      button.addEventListener("state-changed", (ev) => {
        const rawState = ev.detail?.state || "unknown";
        append(`state ${rawState}`);
        const state = String(rawState).toLowerCase();
        const isDone = ["finished", "installed", "done"].includes(state);
        if (observerAutoConfig && isDone) {
          observerAutoConfig = false;
          sendObserverConfig();
        }
      });
      button.addEventListener("log", (ev) => {
        append(ev.detail?.message || "log event");
      });
      button.addEventListener("error", (ev) => {
        append(`error ${ev.detail?.message || "unknown"}`);
      });
      button.addEventListener("click", () => {
        observerAutoConfig = true;
        if (logEl) {
          logEl.textContent = verbose ? "Verbose install log started..." : "Verbose install log ready.";
          logEl.classList.toggle("active", !!verbose);
        }
      });
    }

    wireInstallLogging(document.getElementById("observerFlash"), false);
    wireInstallLogging(document.getElementById("observerFlashVerbose"), true);

    const observerFlashBtn = document.getElementById("observerFlashBtn");
    const observerFlashVerboseBtn = document.getElementById("observerFlashVerboseBtn");
    const observerFlash = document.getElementById("observerFlash");
    const observerFlashVerbose = document.getElementById("observerFlashVerbose");

    if (observerFlashBtn && observerFlash) {
      observerFlashBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) logEl.classList.remove("active");
        observerFlash.click();
      });
    }

    if (observerFlashVerboseBtn && observerFlashVerbose) {
      observerFlashVerboseBtn.addEventListener("click", () => {
        observerAutoConfig = true;
        const logEl = document.getElementById("installLog");
        if (logEl) {
          logEl.textContent = "Verbose install log started...";
          logEl.classList.add("active");
        }
        observerFlashVerbose.click();
      });
    }

    const rangeTabs = document.getElementById("meshRangeTabs");
    if (rangeTabs) {
      rangeTabs.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-range]");
        if (!btn) return;
        rangeTabs.querySelectorAll("button").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        meshRangeDays = Number(btn.dataset.range || 7);
        if (!appData.meshScore) {
          try {
            const mesh = await fetchMeshScore();
            renderMeshScore(mesh, meshRangeDays);
          } catch {}
        } else {
          renderMeshScore(appData.meshScore, meshRangeDays);
        }
      });
    }

    function setServerStatus(ok) {
      const dot = document.getElementById("serverStatus");
      if (!dot) return;
      dot.classList.toggle("ok", !!ok);
    }

    loadReadState();
    const rankSearch = document.getElementById("rankSearch");
    if (rankSearch) {
      rankSearch.addEventListener("input", () => {
        appData.rankFilter = rankSearch.value.trim();
        if (appData.rankData) {
          renderRankWithOptions(appData.rankData, { preserveView: true });
        }
      });
    }

    const rankList = document.getElementById("rankList");

    const rfSearch = document.getElementById("rfSearch");
    const rfTypeFilter = document.getElementById("rfTypeFilter");
    if (rfSearch) rfSearch.addEventListener("input", renderRfList);
    if (rfTypeFilter) rfTypeFilter.addEventListener("change", renderRfList);

    window.addEventListener("resize", () => {
      if (observerMap) observerMap.invalidateSize();
      if (rankMap) rankMap.invalidateSize();
    });
  </script>
</body>
</html>
